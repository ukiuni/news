---
layout: post
title: "Provenance Is the New Version Control - 由来（プロヴェナンス）は新しいバージョン管理だ"
date: 2026-01-13T06:56:59.662Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://aicoding.leaflet.pub/3mcbiyal7jc2y"
source_title: "Provenance Is the New Version Control  - The Phoenix Architecture"
source_id: 46597023
excerpt: "AI時代、なぜ変更したかを意図グラフとハッシュで記録し再生成する版管理"
image: "https://leaflet.pub/lish/did%253Aplc%253A4qsyxmnsblo4luuycm3572bq/3majnsnvafs2b/3mcbiyal7jc2y/opengraph-image?f3a3a13b3930d7d9"
---

# Provenance Is the New Version Control - 由来（プロヴェナンス）は新しいバージョン管理だ
コードを捨てても理由が残れば大丈夫──「意図（プロヴェナンス）版管理」が変えるソフトウェア開発の未来

## 要約
AIで実装を再生成できる世界では、差分ではなく「なぜ変更したか（理由）」がバージョンの単位になる。仕様・制約・意思決定をノード化した意図グラフ（プロヴェナンス）が、新しいソース・オブ・トゥルースになる、という主張。

## この記事を読むべき理由
AI支援によるコード生成が普及すると、日本の企業や開発チームでも「コード自体が正史である」という前提が崩れる可能性が高い。規制対応、品質管理、外注やオフショアとの協働で「なぜそうなったか」の追跡性が重要になるため、今から意図を扱う仕組みを考える価値がある。

## 詳細解説
- 再生成可能なシステムとは  
  仕様・制約・決定（＝意図）を保存しておけば、コンポーネントを削除しても同じ振る舞いで再生成できるシステム。こうなるとコードは「成果物」であって「意図の記録」ではなくなる。

- 差分（diff）の限界  
  伝統的なバージョン管理は「誰がどの行を書いたか」を追うことで意思を推定してきたが、AIが仕様からコードを生成する場合、コード差分は「結果」を示すだけで「なぜそうしたか」を説明しない。つまり、コード中心の履歴は情報損失的（lossy）になる。

- 仕様は説明から実行可能な入力へ  
  仕様やエージェントの計画は単なるドキュメントではなく、再生成のための実行可能な入力（executable intent）になる。計画そのもの（選んだ戦略、却下した代替案、課した制約）は実装の一部と見なすべき。

- 意図グラフ（content-addressed graph）  
  要件・制約・計画・決定・環境条件をノードにし、各ノードは内容に基づくハッシュを持つ。エッジは因果関係を示す。生成器やテストはこのグラフに紐づく評価アーティファクトとして扱う。変更はノード単位で伝播し、ルートハッシュがその「バージョン」を表す。

- 既存の類似技術との関係  
  BazelやNixのような入力ハッシュによるビルド追跡や、形式手法の仕様記述といった既存技術の延長線上にあるが、違いは「仕様→生成→実装」を強制的に結びつける点にある。

- 課題と失敗モード  
  自然言語仕様の正規化、同義表現の検出、生成器の非決定性、暗黙の前提の記録漏れといった課題がある。完璧さは要らないが、可検査性と再現性を高める設計が必要。

## 実践ポイント
- 要件を構造化する：単なるチケットや文書ではなく、タイプ（機能要件、制約、非機能）を持つ構造化されたアーティファクトに落とす。
- 意図とテストを結びつける：各要件ノードに対応するテストやチェックを明示し、再生成後の検証を自動化する。
- 生成器に決定記録を出力させる：どのアプローチを選んだか、却下した代替案、使ったモデルやテンプレートをメタデータ化する。
- コンテンツアドレス（ハッシュ）を活用する：仕様→計画→生成物をハッシュで結び、変更の伝播を追いやすくする。BazelやNixの考え方が参考になる。
- 小さく試す：まずは単機能のコンポーネント（バリデータや認証周り）で意図グラフと再生成パイプラインを試作し、運用コストと恩恵を評価する。
- 組織的な価値提示：規制対応やインシデント調査で「なぜこうなったか」を説明できる点を強調してステークホルダーを巻き込む。

以上を踏まえると、AI時代の「バージョン管理」はコードの履歴ではなく、意図の追跡と再現性が中心になる。日本の現場でも、まずは仕様の構造化と生成プロセスの可視化から取り組むのが現実的な一歩。
