---
layout: post
title: 'SDSL : a new/old shader programming language'
date: 2025-12-27 13:42:50.380000+00:00
categories:
- tech
- world-news
tags:
- tech-news
- japan
source_url: https://www.stride3d.net/blog/
source_title: Blog - Stride Game Engine
source_id: 436963096
excerpt: StrideのSDSLは低メモリ・高性能な式パーサでSPIR‑V連携を目指す新旧折衷のシェーダ言語だ
---
# 新旧のいいとこ取りで描く“次世代シェーダ言語”──SDSLが示すパフォーマンスと実装の勘所

## 要約
Stride が提案する SDSL（新旧折衷のシェーダ言語）は、SPIR‑V 対応を見据えつつ、低メモリ・高性能を実現する新しいパーサ設計を採用している。この記事では、Part 3 の「プロトタイプ式パーサ」実装を手がかりに、その技術的要点と日本の開発現場での意義を整理する。

## この記事を読むべき理由
- 日本でも増える Vulkan／マルチプラットフォーム開発や、Unity 代替・オープンソース採用の流れで、軽量で高速なシェーダ処理は現場の注目点。  
- Stride の取り組みは .NET/C# 環境での低レイテンシ実装例として学ぶ価値が高い。

## 詳細解説
- 背景：Stride は SPIR‑V を軸に既存シェーダシステムの改善を進めており、SDSL（「新/旧」スタイルを融合したシェーダ言語）を使った再設計が進行している。Part 3 では特に「新しい SDSL パーサをどう実装したか」を、プロトタイプの式（expression）パーサを通して解説している。  
- パーサ設計の方向性：リアルタイムレンダリング向けのシェーダ処理では、パース時のメモリ割当と GC 発生を最小限にすることが重要。Stride の試みは「プロトタイプ段階から低割当を意識したパーサ」を作り、後段の SPIR‑V 生成へ効率的に繋げる点にある。  
- 典型的なテクニック（元記事の示唆に基づく実践的アプローチ）：
  - 式パーサは再帰下降や Pratt パーサのようなシンプルで高速な手法を採用し、不要な AST ノード生成を避ける。  
  - 一時データはスタックやアリーナ（メモリプール）で管理し、短命オブジェクトのヒープ割当を削減する。  
  - .NET 環境では Span<T>/ref struct、ArrayPool、構造体ベースのトークン表現などを使って GC 負荷を低減する工夫が有効（Stride も .NET を前提にしているため親和性が高い）。  
  - 最終的な出力は SPIR‑V のような中間表現へ直結させ、シェーダ最適化やパイプライン生成を簡素化する設計が狙い。  
- 既存システムとの違い：従来のパーサが AST を重視していたのに対し、SDSL のパーサは「必要最小限の構造で処理を進める」ことで、パース時のメモリと時間を節約し、ランタイムやコンパイルパイプライン全体のスループット改善を目指している。

## 実践ポイント
- Stride のブログ（Part 1→3 を順に追う）で系列的な設計意図を読む。特に SPIR‑V を目指した変更点は見逃さないこと。  
- .NET/C# 環境でシェーダ関連ツールを作るなら、Span<T>／ArrayPool／構造体トークンといった「ヒープ割当を避ける実装」を試す。  
- 小さな式パーサを自分で実装してみる（再帰下降 or Pratt）。まずは AST を作らず評価や中間表現へ直接変換する流れを確認するのが学びやすい。  
- Vulkan や SPIR‑V 対応を考えるチームは、Stride 4.3 の「Vulkan compute shaders」などのリリースノートを参照し、自社パイプラインとの整合性を検討する。  
- 実プロジェクトではプロファイリングを忘れずに：パースでのアロケーション、GC 発生、コンパイル時間を定量的に測ることが改善の近道。

