---
layout: post
title: "A 4-part technical series on how I built NES in VS Code for a coding agent - VS Codeでコーディングエージェント向けに作ったNESの4部構成技術シリーズ"
date: 2026-01-15T07:15:59.459Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://docs.getpochi.com/developer-updates/how-we-created-nes-model/"
source_title: "NES Series (Part 1): The Edit Model Behind Tab Completion - Pochi"
source_id: 426449165
excerpt: "編集履歴から「次に直す場所と方法」を予測するNESの実装と運用ノウハウ"
image: "https://docs.getpochi.com/og-image/nes-part-1-og-image.png"
---

# A 4-part technical series on how I built NES in VS Code for a coding agent - VS Codeでコーディングエージェント向けに作ったNESの4部構成技術シリーズ
次に何を直すべきかを予測してくれる「Next Edit Suggestion (NES)」――タブ補完を超える編集支援の作り方

## 要約
PochiがVS Code拡張向けに開発した「NES」は、ファイル全体と直近の編集履歴を見て「次にどこを、どう編集するか」を予測する編集モデル。訓練フォーマット、データ正規化、ベースモデル選定、推論時のコンテキスト強化までを設計しているのが本稿の要点です。

## この記事を読むべき理由
日本の開発現場でも「高速で正確なコード補助」は生産性を大きく左右します。特に大規模リポジトリやチーム開発では、単行や関数単位の補完では追いつかない「次の編集」を提示できるとレビューやバグ修正が劇的に速くなります。本稿はその実装上の実務的知見が詰まっており、プロダクト設計や実装方針の参考になります。

## 詳細解説
- 問題意識  
  従来のタブ補完はその場の文字列生成が中心だが、実際の開発では「どの箇所をどう変えるか」の意図が連続的で、ファイル全体や編集の流れ（編集履歴）を見ないと適切な提案ができない。さらに実コミットは無秩序で、実際の開発フローをそのまま学習データにするとノイズが多い。

- 学習フォーマット（編集トークン）  
  NESは「editable_region」マーカーで編集可能領域を明示し、「user_cursor_is_here」等のトークンでカーソル位置や既存編集を表現する特殊マークアップで学習データを構成。モデルはその領域内部での「次の編集」を予測するように学習されるため、自由文生成とは目的が異なる。

- データ整備とソース  
  CommitPackFTやZetaといったデータを統合し、統一フォーマットへ正規化。実コミットの非連続的な編集（PRに混ざる余分な差分など）は、GPT-4.1 miniを小さなインコンテキスト判別器として使い、順序性のない編集をフィルタリングしている。

- ベースモデル選定と運用判断  
  技術的にはOSSモデルも候補に上がるが、低レイテンシでスケールする運用コストを抑えるために Gemini 2.5 Flash Lite（管理型）を採用。SFT（Supervised Fine-Tuning）APIでLoRAベースの微調整を行い、モデルパラメータは最小限の更新にとどめて軽量性と基礎能力を保っている。これにより頻繁な改善やバージョン管理がしやすく、エディタ内体験の一貫性が高まる。

- 評価方法  
  トークン一致ではなく「意味的に正しいか」を判定するため、Gemini 2.5 ProをLLM-as-a-Judgeとして使って自動評価。人間の判定に近い尺度で大規模な継続評価が可能になる。

- 推論時のコンテキスト強化  
  実際の編集支援では現在のファイルスナップショットに加え、<|edit_history|>（直近の編集の流れ）や<|additional_context|>（型情報、ドキュメントなど）を与え、モデルが「今何をしようとしているのか」を理解できるようにする。結果として提案は編集領域に限定され、文脈に沿ったものになる。

## 実践ポイント
- 編集提案を作るなら「編集マークアップ」を作る：editable_regionやuser_cursor_is_hereで意図を明示する。
- 学習データはそのまま使わない：コミット/PRはノイズが多いので順序性フィルタを用意する（小型の判別モデルが有効）。
- モデル選定は「体験（レイテンシ、可用性）」と「コスト」を天秤に：管理型は運用負荷を下げる一方、OSSはカスタム性で有利。
- 軽量微調整（LoRAなど）を検討する：ベース能力を残したまま素早く改善できる。
- 評価は意味ベースで自動化する：LLMをジャッジに使うとスケールするし人間評価に近い。
- 推論時は編集履歴と追加コンテキストを送る：編集の流れと型情報を取り込むことで精度が上がる。

短く言えば、NESは「どこを・どう直すか」を編集の流れから予測するための設計・運用の集合体です。日本のチームでも、データ整備と運用設計をきちんとやれば実用的な次編集支援は十分に実現可能です。
