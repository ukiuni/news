---
layout: post
title: "Making Pyrefly's Diagnostics 18x Faster - Pyrefly の診断表示が18倍高速化された話"
date: 2026-02-10T15:30:25.509Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://pyrefly.org/blog/2026/02/06/performance-improvements/"
source_title: "Making Pyrefly Diagnostics 18x Faster | Pyrefly"
source_id: 446376595
excerpt: "Pyreflyが依存追跡と診断ストリーミングで保存後の型エラー表示を平均18倍高速化"
image: "https://pyrefly.org/assets/images/18x_faster-064e9ea631da625f6e1a88464b444f95.png"
---

# Making Pyrefly's Diagnostics 18x Faster - Pyrefly の診断表示が18倍高速化された話
驚くほど速くなる！保存してすぐに型エラーが返ってくるPyreflyの裏側

## 要約
Pyreflyは「ある特定の大きな依存関係を持つファイルを保存すると再チェックが数秒かかる」問題を、型依存の粒度を細かくすることと診断のストリーミング配信で解決し、診断表示を平均18x高速化しました。

## この記事を読むべき理由
大規模コードベースやモノレポで開発する日本のエンジニアにとって、保存後の即時フィードバックは生産性に直結します。Pyreflyの改善はIDE体験を劇的に速くする具体例で、Pythonの型チェック運用を考える上で参考になります。

## 詳細解説
- 問題の状況  
  - モジュール単位で解析するPyreflyでは、「ロードベアリング（多くに参照される）ファイルA」を変えると、その逆方向依存（Aを直接／間接にimportする全ファイル）を再チェックしていたため、最悪で数秒〜数秒以上の遅延が発生していた。  
- どうして無駄な再チェックが起きるか  
  - 以前は「依存モジュールのエクスポートが変わったら再チェックする」方針で、モジュールが実際に使っている型やメンバーの違いを区別していなかったため、影響がないファイルまで再検査してしまう。  
  - 実プロジェクトではimportしている名前以外に、メソッドの戻り型やクラス階層を通した依存など、型依存の伝播が複雑になる（例：from module import Class → Class().returns_type().operation() のように戻り型に依存する）。  
- 解決策1：細粒度の依存追跡（v0.51.1）  
  - 「そのモジュールが実際にどの型／メンバーを参照しているか」を記録して、不要なモジュール無効化（invalidations）を避ける。  
  - 結果、極端なケースで2000超の無効化が100程度に削減された。  
- 解決策2：診断のストリーミング（v0.52.0）  
  - 従来は全影響範囲の再チェックが完了するまでIDEに診断を送らなかったが、ユーザーが開いているファイルへは「関連部分の再チェックが終わり次第」順次診断を送る方式に変更。  
  - 実装上は再チェックスレッドが直接フロントエンドへ送れるようにし、同一ファイルについてはメインスレッドと再チェックスレッドが出す診断が競合しないよう制御している。  
- 効果  
  - 組み合わせることで、特定ケースで診断更新が約3.6秒→200ms未満に短縮（M4 MacBook Proで計測）。開発者にとって「保存してすぐに型エラーが見える」体験が実現。

## 実践ポイント
- Pyreflyを使っているなら最新版（少なくとも v0.51.1/v0.52.0 以降）にアップデートする。  
- 大規模リポジトリでは、依存追跡の改善でCPU負荷とLATENCYが下がることを期待できる。アップデート前後で簡単なベンチ（保存→診断反映時間）を測ると効果が見える。  
- IDE（例：VS Code）で「開いているファイルへの即時診断」が有効か確認する／問題があれば公式GitHubにIssueを投げる。  
- プロジェクトで型ヒントを広げると、こうした型チェッカーの恩恵がより大きくなる。

以上。Pyreflyの改善は「IDEでの瞬時フィードバック」を現実に近づける好例なので、Python開発のUX改善を考える人は注目してください。
