---
layout: post
title: "Visualizing the ARM64 Instruction Set - ARM64命令セットの視覚化"
date: 2026-02-19T09:00:10.141Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://zyedidia.github.io/blog/posts/6-arm64/"
source_title: "Visualizing the ARM64 Instruction Set | Zachary Yedidia&#39;s blog"
source_id: 47028803
excerpt: "ヒルベルト曲線でARM64全命令空間を可視化し、LFI適合領域や逆アセンブラ検証ツールを公開"
---

# Visualizing the ARM64 Instruction Set - ARM64命令セットの視覚化
ARM命令の“海”をヒルベルト曲線で一望——32ビット空間を色で読み解く

## 要約
ARM64の全32ビット命令空間をヒルベルト曲線で可視化し、命令クラスやサンドボックス（LFI）の許容範囲を色分けして示したプロジェクトの紹介。手元で試せるインタラクティブ版とツールも公開されている。

## この記事を読むべき理由
ARMはスマホ、組込み、サーバ（Apple/Arm/Graviton）で支配的。命令セットの構造やサンドボックス検証の「可視化」は、デバッガ／逆アセンブラ作成、バイナリ解析、セキュリティ実装に直結する実践的知見だから。

## 詳細解説
- アプローチ概要  
  - ARMのMachine Readable Architecture（MRA）仕様(XML/HTML)をパースし、固有エンコーディング約3,000件を抽出。  
  - 32ビット全空間（2^32）を走査して各命令の種類を割り当て、ヒルベルト曲線上にプロット。ピクセルは256命令を表し、アルファで密度を表現。  
- 命令分類と可視化  
  - 一般（general）、system、float、advsimd、sve/sve2、mortlach 等のクラスを色分け。SVE2/SME2の追加で特徴的なパターンが現れる。  
- 実装上の課題と対処  
  - 仕様中のビット表現は0/1/xに加えて(0)/(1)という表記があり曖昧さがある。ASL（Arm Specification Language）による意味論的な上書きも存在し、単純なビット比較だけでは不正なエンコーディングを除外できない。  
  - 解決策として、生成後にCapstone（逆アセンブラ）で全命令を走らせて無効なエンコーディングを取り除く後処理を導入。インタラクティブ版はCapstoneをWASMで動かして逆アセンブル表示（古いCapstoneのため未対応命令は名前で表示）。  
- LFI（Lightweight Fault Isolation）との合成可視化  
  - LFIは命令単位でレジスタやアドレッシングに関する不変条件を課すことでサンドボックス適合性を判定。これをヒルベルト可視化すると、許可される命令領域が熱マップとして現れる（赤：許可多数、青：ほぼ禁止）。  
  - 例：x18,x21,x22,x23,x24,sp など保護対象レジスタがある領域はスパースに。ロード/ストアのアドレッシングモードによりチェック模様が生じる。現状はARMv8.0までサポートで約7.5億命令が許可。  
- ツールとインタラクティブ版  
  - インタラクティブ（ブラウザ）版や解析ツールは公開済み（元記事のリポジトリ参照）。将来的にASLを完全解釈して自動逆アセンブラ生成を目指す計画あり。

## 実践ポイント
- まずはインタラクティブ版で命令空間を触ってみる：命令密度やクラス分布で、解析すべき領域が一目で分かる。  
- 逆アセンブラやサンドボックス実装時は、MRAのビット表記だけでなくASLの意味論（条件付き無効化等）を意識する。Capstone等の信頼できる実装で検証すると効率的。  
- 組込み/自動車/クラウドでARMを使う日本の開発者は、ISAの「見える化」をデバッグやセキュリティ要件の設計に活用すると有益。  
- 興味があればリポジトリをクローンして、RISC‑Vなど別ISAで同様の可視化を試して比較してみると学びが深い。

（元記事のインタラクティブ版・ツールは作者の公開ページ／GitHubを参照）
