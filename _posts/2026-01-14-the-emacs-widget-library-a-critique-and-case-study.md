---
layout: post
title: "The Emacs Widget Library: A Critique and Case Study - Emacsウィジェットライブラリ：批評とケーススタディ"
date: 2026-01-14T03:25:48.410Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.d12frosted.io/posts/2025-11-26-emacs-widget-library"
source_title: "The Emacs Widget Library: A Critique and Case Study - Boris Buliga"
source_id: 46584864
excerpt: "Emacsのwidgetで編集可能な表を高速に実装する実践技法と限界を、測定→描画の二段戦略で解説"
---

# The Emacs Widget Library: A Critique and Case Study - Emacsウィジェットライブラリ：批評とケーススタディ
Emacsの古典APIで表まで作ったら見えた「得意」と「限界」

## 要約
Emacs標準のwidgetライブラリは「テキストとしてのUI」を巧みに利用し高速・軽量なフォーム実装を可能にする一方、レイアウトや状態管理の抽象化がほとんどなく、複雑なインタラクティブUI（例：列幅が可変で編集可能な表）を作るときに苦労する、という話です。著者は実装例（editable table）を通して実務的な解法とトレードオフを示します。

## この記事を読むべき理由
- Emacsでカスタム設定画面やパッケージのUIを作る日本の開発者・パッケージ作者にとって、widgetの限界と回避策は実務直結の知見だから。  
- 既存のCustomizeや多くのパッケージはこの仕組みを使っており、うまく扱えば高速で端末互換のUIが作れますが、ハマりどころを知らないと長時間のデバッグ地獄に陥ります。

## 詳細解説
1) 長所（良いところ）
- テキストとして描画：widgetsはバッファ内のテキスト／オーバーレイとして振る舞うため、GUI・terminal問わず一貫した操作性が得られ、Emacsの既存機能（検索やキーボードマクロ）がそのまま使える。
- 高速：重いGUIオブジェクトがないので大量のウィジェットでもスナップに動く。
- 型階層：widgetの定義体系は拡張しやすく、新規ウィジェットの派生も作れる（ただし古典的な継承中心）。

2) 欠点（痛いところ）
- レイアウト機能が無い：ウィジェットの「何をするか」は定義できるが、空間的配置（列揃え、グリッドなど）を自動で行うエンジンが無く、開発者が文字数計算やパディングで手計算する必要がある。
- 状態管理が無い：リアクティブな依存管理や単方向データフローといった現代的パターンがなく、ウィジェット間の連携はコールバックで手続き的に実装するしかない。
- ツリー構造が貧弱：親子の一般的なUIツリーがないため、イベント伝播やスコープ管理が自前になる。

3) ケーススタディ（表ウィジェットの要点）
- 要求例：列幅揃え、編集で列幅が変われば再レイアウト、再描画してもカーソル位置を保つ、テーブルを一つの単位で扱う。
- 基本戦略（著者のアプローチ）：
  - 測る→描画：セルの幅を知るため、各セル用ウィジェットを一時バッファで描画して長さを測り、列ごとの最大幅を算出してから本描画する（＝二段処理）。
  - パディングで揃える：最大幅との差をスペースで埋める。widgetの:offsetやカスタムフォーマットを使って連携する。
  - 子ウィジェットに位置情報を付与：各子に :row-index / :col-index を書き込んでおき、notifyで変更が来たらどのセルか特定できるようにする。
  - 変更時の手順：子が編集される→親の :notify が呼ばれる→内部引数(:args)を更新→列幅再計算→テーブル全体再描画→カーソル位置はマーカーで保存して復元。
- 性能トレードオフ：各セルを一時作成して測るため二度描画が発生する。小〜中サイズの表では許容だが、大きいならテンポラリバッファの再利用や幅キャッシュが必要。

例（幅測定のイメージ）：
```emacs-lisp
(with-temp-buffer
  (widget-create some-cell-widget)
  (- (point) 1)) ;; 描画後の長さを取得
```

## 実践ポイント
- まずは「measure first, render second」。複雑なレイアウトは先にサイズ情報を揃えてから描画する設計にする。
- 一時バッファは再利用する：毎回作ると無駄。temp bufferを使い回してコストを下げる。
- 位置保存にマーカーを使う：再描画後にカーソルを同論理位置に戻すにはマーカーで相対位置を持つと安全。
- 子にインデックスを付ける：:row-index/:col-indexなどを付与しておくとnotifyでの特定が容易。
- 状態は集中管理する：バッファローカル変数や明示的なstateオブジェクトに集約して、notifyはstate更新＋再描画に留めると保守しやすい。
- 最初から複雑なレイアウトを避ける：可能なら線形フォームで収まるUI設計にするか、GUIフレームワークや別プロセスのUI（webビューやGTK）を検討する。
- 既存の拡張ライブラリを活用：著者の widget-extra のような拡張を利用すると、ラベル整列や簡易レイアウトが楽になる（ソースを読んでプロトコルを真似するのも学びが多い）。

最後に一言：Emacsのwidgetは「バッファ＝UI」という哲学に忠実で、狭い要求には強力です。しかし、動的で相互依存する複雑なUIを作るなら、設計上の工夫（状態の集中管理、二段描画、マーカーによる位置復元）が不可欠で、場合によっては別のアプローチを選ぶ判断も合理的です。
