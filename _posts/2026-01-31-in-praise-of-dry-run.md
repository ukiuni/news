---
layout: post
title: "In Praise of --dry-run - 「--dry-run」を称える"
date: 2026-01-31T21:16:24.799Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://henrikwarne.com/2026/01/31/in-praise-of-dry-run/"
source_title: "In Praise of &#8211;dry-run | Henrik Warne&#039;s blog"
source_id: 412601683
excerpt: "本番を汚さず即検証できる--dry-run導入で毎朝のバッチ確認を安全かつ高速化、運用リスクも削減"
image: "https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg"
---

# In Praise of --dry-run - 「--dry-run」を称える
本番を汚さず確認できる小さなフラグが、開発効率と安心感を劇的に高める話

## 要約
コマンドに --dry-run オプションを早期に入れると、実行前に「何が起きるか」を出力して副作用を避けつつ素早く検証できる。特に日次バッチやレポート生成系で効果が大きい。

## この記事を読むべき理由
日本の企業システムでは定期バッチやSFTPを使ったファイル連携が多く、誤操作のリスクを下げつつ開発・テストを高速化できる現実的な手法だから。

## 詳細解説
- 対象アプリは平日ごとにレポートを生成するバッチ：DB読み取り→ロジック適用→ZIP→SFTPアップロード→エラーフィードバック取得→通知メール、各ステップでファイルを移動する。  
- --dry-run を付けると「どのレポートが生成されるか」「どのファイルをZIP/移動/アップロード/ダウンロードするか（SFTPは一覧のみ）」をログ出力し、実際の変更は行わない。  
- 利点：  
  - 安全に毎朝チェックできる（設定やアクセス、状態確認のために気軽に実行）。  
  - 状態ファイルの日付をいじったとき、重い処理を走らせず挙動確認ができるためフィードバックが速い。  
- 欠点：コードの各フェーズでフラグ判定が必要になるため若干の「フラグ汚染」は増えるが、実装は浅く、実際の処理ロジックに深く影響しない。  
- 適用範囲：コマンド型のバッチ処理に最適。イベント駆動やリアクティブなサービスには向かない場合がある。

## 日本市場との関連性
多くの日本企業が帳票・決済・帳簿連携でSFTPや夜間バッチを使うため、本番データを汚さずに確認できる手段は運用リスク低減や監査対応にも直結する。CIやデプロイ前検証としても有用で、属人的な「実行してみる」文化を安全に置き換えられる。

## 実践ポイント
- プロジェクト初期に導入する（早期導入で開発中から恩恵を受けられる）。  
- フラグ判定は呼び出し側（フェーズの開始）で行い、実処理コードは副作用を持たないまま呼べる設計にする。  
- SFTPや外部APIは「一覧のみ」「シュミレーション応答」を返す実装にして、外部状態確認を実現する。  
- ログは「dry-run」であることを明示し、何が実行されるかを詳細に出す。  
- 本番検証時はdry-run→限定実行→フル実行の順で段階的に確認する。

参考：実装パターン（例、Python）
```python
# python
def maybe_run(action, dry_run):
    if dry_run:
        print(f"[dry-run] would: {action.__name__}")
    else:
        action()

def generate_reports():
    # 実処理
    pass

maybe_run(generate_reports, dry_run=True)
```
以上。
