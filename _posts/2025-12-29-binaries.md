---
layout: post
title: "Binaries"
date: 2025-12-29T07:50:48.742Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://fzakaria.com/2025/12/28/huge-binaries"
source_title: "Huge binaries | Farid Zakaria’s Blog"
source_id: 46417791
excerpt: "巨大ELFが暴くx86_64の2GiB相対CALL限界とリンク失敗や対処法"
---

# 2GiBの壁を破るか？ 巨大バイナリが暴く「静的リンク」の限界

## 要約
巨大モノリポや静的リンクで生成されるELFが数GB〜数十GBになると、x86_64の相対ジャンプ（CALL）が持つ32ビットオフセットの限界、いわゆる「2GiBのリロケーション障壁」に当たってリンクが失敗したり、対処でコード肥大や性能影響が出たりします。

## この記事を読むべき理由
コンテナやサーバレス、小〜大規模モノリポで「起動速度を優先して静的にビルドする」ケースは増えています。日本のプロダクトでも大規模コードベースやスタティック配布を検討する場面があり、知らないとリンク地獄にハマる技術的落とし穴です。

## 詳細解説
- 問題の核心  
  x86_64のCALL命令（opcode e8）は32ビット符号付き相対オフセットをオペランドに取り、その到達範囲は $[-2^{31}, 2^{31}-1]$、概算で約 $2\,\text{GiB}$ です。つまり「1つの相対ジャンプが届く先」は約2GiBに制限されます。

  - CALL命令のオペランドは4バイト（32bit signed）であるために生じる制約です。これは位置独立コードや通常のリンク後の修正（relocation）で表面化します。

- 実例（要点のみ）  
  単純な呼び出しをするCファイルをコンパイルすると、objdumpではCALL命令がe8 00 00 00 00のように生成され、readelfのrelocationセクションに「この地点をリンク時に修正する」と記録されます。  
  リンカスクリプトで呼び出し先シンボルを意図的に0x120000000（= 4.5GiB相当）など遠くに置くと、lldは次のようなエラーを出します（抜粋）：
  - R_X86_64_PC32 out of range: ... is not in [ -2147483648 , 2147483647 ]

- 一つの対処法：-mcmodel=large  
  - これを指定すると相対CALLの代わりに64ビット絶対アドレスをレジスタにロードして間接CALLを行うコードが生成されます（例：MOVABS $addr, %rdx; CALL *%rdx）。  
  - しかし代償があり、CALLが5バイト→12バイトに増え、呼び出しサイトが数百万あるバイナリでは命令肥大（instruction bloat）と汎用レジスタ消費（register pressure）を招きます。

- その他の選択肢（概観）
  - 動的リンク（shared libraries）へ分割して相対範囲の問題を回避する。  
  - 中間的な「thunk」やPLT/GOT経由の呼び出しで範囲外を扱う（リンカの機構による）。  
  - デバッグ情報を分離（split debug info）、不要なセクションを削減、--gc-sectionsやLTOでサイズ削減。  
  - リンカ/コンパイラのcode modelやrelaxation機能を検討（ツール依存）。  

## 実践ポイント
- 問題を再現・診断するコマンド
  - 発生個所の確認:
```bash
objdump -dr simple-relocation.o
readelf -r simple-relocation.o
```
  - リンカエラーの例（lld）を確認する:
```bash
gcc simple-relocation.o far-function.o -T overflow.lds -o simple-relocation-overflow -fuse-ld=lld
```

- すぐ試せる対処
  1. まずはサイズとシンボル配置を可視化する（readelf/objdump/size）。  
  2. debug info分離: split debug info（例: objcopy --only-keep-debug）で配布バイナリを小さくする。  
  3. 可能ならshared library化で静的バイナリサイズを下げる。  
  4. 最終手段で -mcmodel=large を検討。ただし性能/コード肥大の影響を必ずベンチする。  
  5. CIで「巨大なELFが生産されない」チェックを入れる（セクションサイズ閾値や総バイナリサイズの警告）。

- 小さな実験コード（参考）
```c
/* simple-relocation.c */
extern void far_function();
int main() { far_function(); return 0; }

/* far-function.c */
void far_function() {}
```
- COMPILERフラグの例
```bash
gcc -c simple-relocation.c -o simple-relocation.o
gcc -c far-function.c -o far-function.o
# 通常リンク:
gcc simple-relocation.o far-function.o -o simple-relocation
# large code model:
gcc -c simple-relocation.c -mcmodel=large -fno-asynchronous-unwind-tables -o simple-relocation.o
gcc simple-relocation.o far-function.o -o simple-relocation-overflow
```

まとめ：静的リンクは便利だが「相対オフセットの物理的上限」がシステム設計に影響を与える。巨大バイナリを扱うなら、まず可視化とCIでの監視を行い、必要に応じてshared化や場面に合わせたcode modelの切替を検討すること。
