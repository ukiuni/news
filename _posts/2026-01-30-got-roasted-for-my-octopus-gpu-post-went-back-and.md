---
layout: post
title: "Got roasted for my 'octopus GPU' post. Went back and did it right - 「オクトパスGPU」で叩かれた話──やり直して正した"
date: 2026-01-30T05:03:30.418Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://github.com/matthewlam721/octopus-parallel"
source_title: "GitHub - matthewlam721/octopus-parallel: Octopus: Block-Level GPU Scheduling for Variable-Length Batches"
source_id: 413921705
excerpt: "パディング不要で可変画像を高速処理、4090で二分探索とブロックが実運用で有利"
image: "https://opengraph.githubassets.com/332f2a82ec0c445c0c51eba36cfe0d384498780498d89de5bc2bfa66f8cbdbe5/matthewlam721/octopus-parallel"
---

# Got roasted for my 'octopus GPU' post. Went back and did it right - 「オクトパスGPU」で叩かれた話──やり直して正した

魅せる見出し: GPUで可変長バッチをパディングなしで高速処理するための「腕（ブロック）設計」──メモリも遅延も節約する実践テクニック

## 要約
可変サイズの画像群をGPUでパディングせずに処理するために、著者は「ピクセル毎のルックアップ」「オフセットの二分探索」「ブロック単位メタデータ（Octopus）」の3手法を比較。RTX 4090では二分探索とブロック方式が互角で、テーブル方式は準備・メモリコストで負けるという結果。

## この記事を読むべき理由
画像処理やバッチ化をGPUで行う日本の開発者・研究者にとって、メモリ・キャッシュ特性を踏まえた実装選択は実運用の性能差に直結します。特にエッジや医療／衛星画像など大判データでは方針が変わります。

## 詳細解説
問題設定
- 例: 10,000枚、サイズまちまち、合計で数億ピクセルを1つのカーネルで処理したい。
- 選択肢は「全部パディング」「フラット配列＋各ピクセルがどの画像か判定」「CUDAブロックに担当画像情報を持たせる」。

比較した手法（要点）
- A: ピクセル→画像IDのルックアップテーブル  
  - 長所: 参照はO(1)  
  - 短所: 巨大メモリ（数GB）、セットアップ時間が高い
- B: オフセット配列に対する二分探索（各ピクセルでlog M検索）  
  - 長所: 極小メモリ（数十KB）  
  - 短所: 理論上はO(log M)だが、L2キャッシュに収まれば実質高速
- C: CUDAブロック単位のメタデータ（各ブロックが担当画像IDや処理種別を持つ）  
  - 長所: O(1)、極低メモリ、柔軟（優先度・カーネル種別・ストリームなどを持てる）  
  - 短所: ブロック割り当ての設計が必要

代表的なベンチ結果（RTX 4090, 10K画像, 約5億ピクセル）
- A（テーブル）: メモリ ≈ 2475 MB、カーネル 31 ms、合計 1117 ms（準備とH2Dがボトルネック）
- B（二分探索）: メモリ ≈ 0.08 MB、カーネル 36 ms、合計 292 ms
- C（ブロック）: メモリ ≈ 0.27 MB、カーネル 31 ms、合計 288 ms

知見
- テーブル方式は準備・転送コストで現実的でない。  
- 二分探索はL2キャッシュが十分なら高速で、実運用で想像より強い（RTX 4090の大きいL2が効いている）。  
- ブロック方式は同程度の性能で、メモリ効率とスケジューリング柔軟性が大きな利点。  
- 画像数を1Mに増やすとlog2(M)の影響が出始め、Bのカーネルは若干遅くなるが総合では状況次第でBが有利になるケースもある。  
- エッジ（Jetson等の小さなL2）、MIGなどの共有キャッシュ環境、大判画像（ギガピクセル）ではCが有利。

制約
- 著者はRTX 4090のみで評価。D2H転送が時間を支配するパイプラインではカーネル差が目立ちにくい。

## 実践ポイント
- 単に「画像IDが欲しい」だけで、対象GPUが大きなL2を持つならB（二分探索）でOK。  
- スケジューリング柔軟性（優先度、異なるカーネル、ストリーム管理）が必要ならC（ブロックメタデータ）を選ぶ。  
- ルックアップテーブル（A）はメモリ・セットアップコストが許容できない限り避ける。  
- エッジGPUや超大判画像では必ずCを検討する。  
- リポジトリのベンチを自分の環境で回して判断すること（例）:

```bash
# ベーシックテスト
python3 triple_baseline_benchmark.py --images 10000
```

参考: 実装・ベンチコードはリポジトリ（matthewlam721/octopus-parallel）に公開されています。自分のGPU特性（L2サイズ、メモリ帯域、転送コスト）で再現するのが最短の答えです。
