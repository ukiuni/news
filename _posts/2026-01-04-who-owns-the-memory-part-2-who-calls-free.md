---
  layout: post
  title: "Who Owns the Memory? Part 2: Who Calls Free? - メモリの所有権は誰のものか？ パート2：誰が free を呼ぶのか？"
  date: 2026-01-04T14:07:28.840Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://lukefleed.xyz/posts/who-owns-the-memory-pt2/"
  source_title: "Who Owns the Memory? Part 2: Who Calls Free? | Luca Lombardo"
  source_id: 1089563462
  excerpt: "C/C++/Rust比較で学ぶ、メモリ解放ミスと実務向け対策を短時間で解説"
  image: "https://lukefleed.xyz/posts/who-owns-the-memory-pt2/index.png"
---

# Who Owns the Memory? Part 2: Who Calls Free? - メモリの所有権は誰のものか？ パート2：誰が free を呼ぶのか？
Freeを呼ぶのは誰だ？――C/C++/Rustが示す「責任」と「罠」

## 要約
メモリ管理の責任（誰がfree/解放するか）は、バグやセキュリティ脆弱性の温床になる。Cの手作業、C++のRAII、Rustの型システムという三者のアプローチと、それぞれの落とし穴を整理する。

## この記事を読むべき理由
日本の組み込み・サーバー・ゲーム開発など多くの現場で、ヒープの誤管理は致命的なバグと攻撃ベクトルを生む。言語ごとの設計思想と実務で使える対策を短時間で把握できる。

## 詳細解説
- C（手動管理）  
  - malloc/freeだけが提供され、解放責任はコード規約に委ねられる。  
  - 早すぎるfree→use-after-free、二重free→ヒープ破壊、解放忘れ→メモリリーク。大規模コードでは命名規約やレビューで対処するがコンパイラはわからない。

- C++（スコープに束縛するクリーンアップ = RAII）  
  - デストラクタ（~Class()）がスコープ脱出時に自動で呼ばれ、例外や早期returnでも確実にクリーンアップされる。  
  - std::unique_ptr / std::shared_ptr 等で所有権を表現できるが、raw new/delete を混ぜると安全性は壊れる。ムーブやムーブ後の「有効だが未定義」状態など、開発者の運用ルールが重要。

- Rust（型システムで所有権を強制）  
  - 値はちょうど1人の所有者を持ち、スコープ終了で Drop が呼ばれる。ムーブは所有権移転で、ムーブ元は以後使えない（コンパイル時に防止）。  
  - Drop トレイトは &mut self を受け取るため、その中で所有権を取り出して再利用することができない（安全性を保つため）。フィールドの再帰的破棄順序は言語仕様で決まっている。  
  - ただし、細かな制御が必要なとき（例えば destructor 内で手動解放してフィールドの二重破壊を防ぐ）には ManuallyDrop や Option を使うトリックが必要になる。

- 共通のポイントと落とし穴  
  - 所有権が型に明確に表現されるとミスが減る（コンパイラが助ける）。  
  - 所有権を表現できない/曖昧なAPIはバグを招く。  
  - 参照カウントやスマートポインタは共有所有を可能にするが、同期コストや循環参照（リーク）に注意。

## 実践ポイント
- 言語に合わせた責任ルールを徹底する（Cなら命名規約とレビュー、C++ならRAII/unique_ptrを標準に）。  
- raw new/delete を避け、スマートポインタで所有権を明示する。unique_ptr を第一選択、共有が本当に必要なら shared_ptr を使う。  
- Rust を導入できる箇所は検討する（所有権を型で保証することでクラスのバグを大幅に減らせる）。ただしFFIやアンワインド時の振る舞いに注意。  
- デストラクタの挙動（順序、フィールドの再帰破壊）を理解して設計する。Drop 内でフィールドを取り出せない制約を考慮する。  
- 具体的なツールを使う：ASAN/Valgrind/clang-tidy/UBSan、静的解析とランタイム検出を組み合わせる。  
- API設計で「誰が所有権を持つのか」を関数シグネチャや命名で明確に示す（ドキュメント化＋コードレビューで強化）。  
- 既存コードの改善は段階的に：コア部分にRAIIあるいはRustを導入し、テスト・フェーズで安全性を検証する。

短い結論：メモリの「誰が解放するか」は単なる実装細部ではなく設計の中心。言語の持つ保証を活かし、規約とツールで補強することで現実的な安全性が得られる。
