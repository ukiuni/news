---
layout: post
title: "Porting 100k lines from TypeScript to Rust using Claude Code in a month - TypeScriptの10万行をClaude Codeで1か月でRustへ移植"
date: 2026-01-26T14:18:37.989Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://blog.vjeux.com/2026/analysis/porting-100k-lines-from-typescript-to-rust-using-claude-code-in-a-month.html"
source_title: "Vjeux &raquo; Porting 100k lines from TypeScript to Rust using Claude Code in a month"
source_id: 46765694
excerpt: "Claude Codeと自動化でTypeScript10万行を1か月でRustへ移植した実践ノウハウ"
---

# Porting 100k lines from TypeScript to Rust using Claude Code in a month - TypeScriptの10万行をClaude Codeで1か月でRustへ移植
AI＋手動オペで“10万行移植”をやり切った舞台裏：自動化のコツと現実的な落とし穴

## 要約
AI（Claude Code）を主役に据え、補助スクリプトやテストを組み合わせてTypeScriptの大規模コードベース（Pokemon Showdown相当）を約1か月でRustに移植した実録。自動化の工夫と手作業での「掃除」が成功の鍵だった、という話です。

## この記事を読むべき理由
- Rustは性能と安全性で注目されており、日本のゲームAIや推論ループ、サーバー処理の高速化に直結するため。  
- 単にAIに任せるだけでなく「どう運用し、どの問題を人が解くべきか」を知ることで、実務でのAI活用設計に役立ちます。

## 詳細解説
- 背景と目的  
  - 既存のJavaScript実装はトレーニングループで遅く、Rust化で性能向上を狙う。Claude Codeを“移植エンジン”にして速度と開発コストの両立を試みた。

- サンドボックスと実行環境の工夫  
  - AIがそのままローカルで任意コマンドを実行できない制約を、ローカルで動く小さなHTTPサーバーやDocker実行により回避。Dockerを使ってコンパイル→アンチウイルス回避、AppleScriptで定期的にEnterを押す自動承認、Auto Clickerでフォーカスを維持するなどの“泥臭い”工夫で長時間ジョブを継続。

- 自動化と決定論的ワークフロー  
  - 単純に「翻訳して」とお願いすると省略や勝手な抽象化が入りミスが増える。そこで、
    - JSファイル／メソッドごとに対応するRustファイルを作るスクリプトを用意し、JSソースをRust側にコメントとして残す（ソース・オブ・トゥルースを明示）。
    - 大きなファイルは「メソッド単位」で分割（“Little Islands”）してコンテキストウィンドウの問題を減らす。
    - TODOコメントをコード内に残させ、grepで検出→逐次対応するループを回す。

- テストと統合戦略  
  - 早期に部分実装を積み上げるより「一気に全部移してから統合」する方が効率的（既存の実装に積み上がった知見を再現するのは非効率）。  
  - PRNGのシードを固定したエンドツーエンドハーネスを作り、同じ乱数列でJSとRustの進行状態を比較して差分を潰していく。Claudeはこの比較ループで大量のバグを自動修正（数週間で何百件）した。

- 主な技術的障害
  - 言語差分：Rustの借用／所有権（borrow checker）やOptional/型表現の違いで設計のやり直しが必要。JSの「柔軟な戻り値（undefined／数値／オブジェクト）」はRustでは列挙型や明示的な引数設計に変換する必要がある。  
  - Claude特性：簡単な解を好む/大きな横断的変更を避ける傾向。難しいタスクは後回しにしがちで、ハックや簡易版を置くため、人が方針を厳格に指示し続ける必要がある。コンテキストの圧縮（compaction）で記憶が失われる問題も頻出。

- ワークフロー（プロンプト設計）  
  - 明確に「1対1で直訳する」「メソッドをスキップするな」「TODOを全部消化する」といったルールを与え、コミット単位で進めさせる。夜間バッチと日中の共同作業（co-op）の繰り返しが効果的。

## 実践ポイント
- 移植前に必ず「エンドツーエンドの入力/出力仕様（シード固定）」を作る。再現できるテストがあると修正が劇的に早まる。  
- 自動翻訳に頼るなら「決定論的スクリプト」を作る：ファイル／メソッド単位でソースを紐づけ、元のJSをコメントとして残す。  
- 大きすぎるファイルは分割（メソッドごと）してAIのコンテキスト負荷を下げる。  
- Rust特有の問題（借用、所有権、明示的な引数）を事前に設計しておく。複雑な参照はインデックス渡しやコピーに置き換える設計パターンを用意する。  
- AIは「簡単に通る実装」を作りがち：難しい横断的変更は手動で指示／設計し、AIにはその指針に従わせる。  
- 運用面：長時間自動実行する場合はセキュリティとOSの自動更新やアンチウイルス挙動を考慮する（Dockerや権限設計で分離）。  
- 小さく回して早くフィードバック：100→1k→10k→100kと、バトル数を増やして段階的に問題を潰す。

以上を踏まえると、「AIで丸投げ」ではなく「AIを大量反復作業の加速装置として使い、設計と検証は人間がコントロールする」アプローチが現実的です。日本の現場でも、性能改善や安全性向上を目指す移植作業に即実践できる考え方が詰まっています。
