---
layout: post
title: "Inlining – The Ultimate Optimisation - インライン化 — 究極の最適化"
date: 2026-01-13T20:56:26.255Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://xania.org/202512/17-inlining-the-ultimate-optimisation"
source_title: "Inlining - the ultimate optimisation &#8212; Matt Godbolt&#8217;s blog"
source_id: 46555297
excerpt: "インライン化で大幅高速化が狙えるが、コード膨張と命令キャッシュ悪化をLTO/PGOで抑える必要あり"
---

# Inlining – The Ultimate Optimisation - インライン化 — 究極の最適化
「コピー＆ペーストで速くなる？」コンパイラが“関数を貼り付ける”理由と、その落とし穴

## 要約
インライン化は単に関数呼び出しを消すだけでなく、定数伝播や不要分岐の削除など「次の最適化」を可能にする重要技術だ。だが過度なインラインはコード膨張やキャッシュ圧迫の原因にもなる。

## この記事を読むべき理由
日本では組込み・モバイル・ゲーム開発などARM系やサイズ・性能を両立させる場面が多い。インライン化の原理とトレードオフを理解すれば、ビルド設定やソース設計で実働性能を確実に改善できる。

## 詳細解説
- 本質：インライン化は「関数本体を呼び出し箇所へコピーすること」。呼び出しオーバーヘッドの削減に加え、呼び出し元のコンテキスト（定数や条件）を使って更なる最適化が可能になる。
- 例（概念）：文字を大文字に変換する関数があったとき、コンパイラが小さな change_case を make_upper にインラインすると、上位の定数情報（例えば upper が true）を伝播できる。結果的に分岐が消え、CPU命令列が単純化される。条件判定は例えば次のように表せる：
  $((c - 'a') \& 0xff) < 26$
  これで小文字判定ができれば、分岐を避けて条件付き減算で大文字化できる。
- 有利な点：
  - 定数伝播、デッドコード除去、局所的な特化が可能。
  - 分岐を局所化できればブランチ予測が改善する場合がある。
- 欠点と注意点：
  - コードサイズ増→命令キャッシュ／デコード帯域への負荷増。多重にインラインされた同一分岐は逆に予測しづらくなることもある。
  - インライン判断はヒューリスティック（推測）で、コンパイラやビルドオプションで結果が変わる。ちょっとしたソース変更が全体のインライン挙動を変えることもある。
  - コンパイラが関数定義を見ていないとインライン不可（宣言だけでは不可）。そこで LTO（リンク時最適化）が重要になる。
- 実務的な補足：
  - static / inline / __attribute__((always_inline)) などでヒントは出せるが、乱用は禁物。
  - PGO（プロファイル駆動最適化）や LTO を組み合わせると、インラインの恩恵を最大化しつつ悪影響を抑えられる。

## 実践ポイント
- まず「見る」：Compiler Explorer（Godbolt）や objdump で生成コードを確認して、インライン化がどう効いているかを確認する。
- リリース設定：LTO を有効にする（多くのプロジェクトでは -flto を有効化）。さらに PGO を導入すると、実行プロファイルに基づくより良いインライン判断が得られる。
- 小さい関数を明示的にインライン候補にする：static inline やコンパイラ属性を使う。ただしコードサイズを監視する。
- 計測を最優先に：ベンチ／プロファイルで命令キャッシュミスやホットパスの性能を測る。見た目の最適化と実行時効果は一致しないことが多い。
- 過度な最適化回避：large-scale なコピー増加が疑われるなら、inline を解除したビルド（あるいは -fno-inline）と比較して性能とバイナリサイズのバランスを確認する。

短くまとめると、インライン化は「最終的な性能を引き出すための扉」。扉を開けると多くの最適化が一挙に可能になるが、開けすぎると逆効果になる。日本の組込み・モバイル開発では特に LTO と PGO を上手く使い、観測に基づいて調整するのが有効だ。
