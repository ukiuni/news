---
layout: post
title: "Show HN: Similarity = cosine(your_GitHub_stars, Karpathy) Client-side - 類似度 = cos(あなたのGitHubスター, Karpathy)（クライアント側）"
date: 2026-01-09T18:53:07.923Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://puzer.github.io/github_recommender/"
source_title: "GitStars"
source_id: 46511903
excerpt: "ブラウザだけで自分のスターとKarpathyを比較し未取得リポジトリを推薦"
---

# Show HN: Similarity = cosine(your_GitHub_stars, Karpathy) Client-side - 類似度 = cos(あなたのGitHubスター, Karpathy)（クライアント側）
魅力的なタイトル: あなたのGitHubスターで“カーパシティ流”レコメンドを作る — ブラウザだけで完結するオフラインGitHubレコメンダ

## 要約
ブラウザ上で自分のGitHubスターと有名エンジニア（例：Andrej Karpathy）のスターをベクトル化し、コサイン類似度で近いリポジトリを推奨するクライアントサイドツール。サーバ不要でプライバシーにも配慮したシンプルなリコメンド実装例。

## この記事を読むべき理由
日本のエンジニアや学習者にとって、有名エンジニアのスターを手掛かりにしたレコメンドは「学ぶべきプロジェクト発見」に直結します。しかも実装はシンプルで、アルゴリズム理解や自分用ツール作成の良い教材になります。

## 詳細解説
このプロジェクトの核は次の流れです。
- ユーザーと参照者（ここではKarpathy）のスターを「リポジトリごとの二値ベクトル」として表現する。
- 各リポジトリについて、ユーザーがスターを付けていれば1、なければ0というベクトルを作る。
- ベクトル間の類似度をコサイン類似度で計算し、参照者と似た嗜好を持つユーザーにとって未取得のリポジトリを推薦する。

コサイン類似度は次の式で表されます：
$$
\text{cosine}(A, B) = \frac{A \cdot B}{\|A\| \|B\|}
$$
ここで $A$ と $B$ は二値ベクトル（各要素は0または1）。内積は共にスターを付けたリポジトリ数の共通部分、ノルムはそれぞれのスター総数の平方根になります。

実装上のポイント（推定）：
- 完全にクライアントサイドで動作するため、GitHub APIをブラウザから叩いて自分と参照者のスター一覧を取得する。トークンが必要な場合やAPIレート制限に注意。
- 取得したスター一覧をIDやフルネームでマッピングして共通集合を作り、ベクトルを構築して類似度を計算する。
- 推薦は「参照者がスターを付けているが自分がまだスターしていないリポジトリ」をスコア順に提示する形が一般的。

利点：
- サーバ不要で手軽に試せる（学習用に最適）。
- プライバシー保護：自分のスター情報を外部サーバに送らない設計が可能。
制約：
- 単純な二値コサインなので、スターの「重み」や最近性を反映しない。
- 推薦の幅は参照者（Karpathy）の嗜好に依存するため多様性は限定される。

## 実践ポイント
- まずはサイトをブラウザで開いて自分のGitHubアカウントでスター一覧を取得してみる（必要ならPersonal Access Tokenを用意）。
- 結果を見て、提示されたリポジトリをレビューする：学習や採用候補をピックアップしやすい。
- 自分で改良するなら：
  - スターの「日時」を重み付けして最近の行動を反映する。
  - 複数のキュレーター（複数の著名エンジニア）を組み合わせて多様性を出す。
  - コサイン以外にランキング指標（TF-IDF風の重みや埋め込みベースの類似度）を試す。
- 日本のコミュニティ向けには、人気のある日本語リポジトリや国内企業のOSSを参照者リストに加えると実用度が上がる。

短く言えば、このクライアントサイドの実装は「自分の学習・探索を手軽に拡張するための良い出発点」です。まず動かして感触を掴み、必要に応じて重み付けや複数参照者の導入で高度化してみてください。
