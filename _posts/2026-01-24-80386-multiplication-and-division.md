---
layout: post
title: "80386 Multiplication and Division - 80386 の乗算と除算"
date: 2026-01-24T08:22:05.744Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://nand2mario.github.io/posts/2026/80386_multiplication_and_division/"
source_title: "80386 Multiplication and Division - Small Things Retro"
source_id: 46741482
excerpt: "80386の1ビット/サイクル乗除算設計を解説、エミュレータやFPGA実装に直結する実践知"
---

# 80386 Multiplication and Division - 80386 の乗算と除算
レトロCPUが教える「1ビット／サイクル」の妙技 — 80386の乗除算を短く解説

## 要約
80386は32ビット化だけでなく、乗除算性能を劇的に改善した。専用のデータパスで「1ビット／サイクル」の反復処理を行い、加算・シフトベースの乗算と非復元法による除算をマイクロコードで制御する設計が特徴。

## この記事を読むべき理由
x86アーキテクチャの基盤を作った80386の算術設計は、レトロ再現、エミュレータ実装、FPGA化、低コストハード実装やコンパイラ最適化の知見として今でも有用。日本での組込み・レトロPCコミュニティにも直結するテーマです。

## 詳細解説
- 背景  
  1985年登場の80386は32ビットレジスタとフラット4GB空間、仮想メモリを導入しつつ、算術回路も強化。従来の8086で数百サイクルかかっていた乗除算を大幅に短縮した。

- 性能（代表値）  
  80386: MUL (8/16/32-bit) 9–38 cycles, DIV 38 cycles（幅に依存）  
  比較: Pentium ~10/41, Core2 ~3–4/17–41, Zen3 ~3–4/13–19

- 乗算（add-and-shift）  
  80386はBooth法ではなく「加算＋右シフト」の反復アルゴリズムを採用。内部に MULTMP（被乗数）, TMPB（乗数）, SIGMA（上位積）などを使い、  
  $COUNTR = width - 1$ のループで下位ビットを見て条件付きで加算し右シフト。  
  「早期終了（early-out）」を実装し、残りビットがすべて0（符号付きならすべて1）ならループを短縮して残り分をまとめてシフトする。  
  符号付きは算術シフトと最終補正（乗数が負なら被乗数を引く）を追加。

- 除算（非復元法）  
  被被除数は {SIGMA, DIVTMP}、除数は TMPB。各反復で被被除数を左シフトし、SIGMAに除数を加減して商ビットをRESULTに詰める非復元アルゴリズムを採用。除算は早期退出がなく固定回数の反復。  
  IDIV（符号付き）は絶対値化→無符号除算→商・剰余の符号補正を行い、その分だけサイクル数が増える。

- マイクロコードと資源再利用  
  マイクロコードがループ制御（RPT）を行い、メインALUを加減算用に再利用してシリコン量を節約する設計。命令幅共通化のために同じルーチンで $8,16,32$ ビットを扱う工夫がある（例：BITS_V は $width-1$ を表す）。

- 設計の位置付け  
  「1ビット／サイクル」は回路が小さく実装が容易な一方、現代CPUはブース木やウォレスツリー、ラジックス化で桁を一度に多く処理して高速化している。とはいえ、FPGA等で面積を抑えて実装するには80386的アプローチは実用的。

## 実践ポイント
- エミュレータ／FPGA化: add-and-shift と非復元除算は簡潔で面積効率が良く、まずはこの方式で動作する実装を作ると学習コストが低い。  
- 最適化: コンパイラやアセンブラで除算命令を避ける（シフト・乗算・テーブル参照へ置換）と性能改善に直結する。  
- 実装の注意: 符号付きは算術シフトと最終補正が必要、BITS_V は $width-1$ として扱う点に注意。  
- 参考追跡: マイクロコード逆解析や Ken Shirriff らのリバース情報は深掘りに有用。

以上。
