---
layout: post
title: "I built a new type of erasure code using Bloom filters - Bloomフィルタを使って作った新しい種類の消失符号"
date: 2026-01-21T12:14:47.588Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://lumramabaja.com/posts/let-it-bloom-the-seeds-of-information-chaining-part-1/"
source_title: "Let It Bloom: The Seeds of Information Chaining (Part 1) | Lum Ramabaja"
source_id: 421266569
excerpt: "ブルームフィルタで情報を連鎖符号化し低メモリで復元可能にする新消失符号"
---

# I built a new type of erasure code using Bloom filters - Bloomフィルタを使って作った新しい種類の消失符号
Bloomで情報を「編む」──Bloomフィルタを応用した新しい情報チェイニングと消失符号のアイデア

## 要約
Bloomフィルタの「存在判定」という確率的性質を逆手に取り、連鎖的に状態を埋め込むことで順序付きデータを符号化・復元する新手法（Information Chaining）を提案。誤判定率を制御すればデコードは現実的に実行可能になる。

## この記事を読むべき理由
Bloomフィルタは高速で省メモリな存在判定構造として既に広く使われているが、その原理を「単なる集合判定」から「情報を符号化する道具」へ転用する発想は、分散ストレージや軽量デバイス向け冗長化（エラージャーコード）で新たな選択肢を生む可能性がある。実装例や設計上のトレードオフが学べ、すぐにプロトタイプが作れる点も実用的。

## 詳細解説
Bloomフィルタはビット配列 $m$ とハッシュ関数 $k$ を使い、要素の存在を高速にチェックする確率的データ構造。偽陰性は起こらない代わりに偽陽性（実際には存在しないが「ある」と判定される）が起きる。一般的な偽陽性率は次で概算される：
$$
p \approx \left(1 - e^{-\frac{kn}{m}}\right)^k
$$
目標とする偽陽性率 $p$ を与えれば、必要ビット数 $m$ とハッシュ数 $k$ の近似は
$$
m = -\frac{n\ln p}{\ln(2)^2},\qquad k = \frac{m}{n}\ln 2
$$
で決められる。

Information Chaining の核は「チェーンヘッダ」と呼ぶ内部状態を逐次更新し、その状態をBloomフィルタに挿入していくこと。メッセージの各ビット（あるいはシンボル）を取り込む際に、チェーンヘッダをビットに応じて混ぜ（nonce や簡単なビット操作で可）、生成されたヘッダをフィルタにセットする。こうすることで各ステップの存在判定は以前の状態に依存する条件付き確率になり、単独の独立な偽陽性が連鎖して指数的に広がるのを抑えられる。

デコードは左から右へ候補パスを伸ばす探索で、各段で0/1の可能性をBloomに問い合わせる。特徴的なのは「誤ったパスの生存確率が深さとともにほぼ $p^{d}$ と下がる」点で、$p<0.5$ あたりにチューニングすれば誤探索が急増せず有限の候補数に収束する。期待候補数の概念式は例えば
$$
1 + \sum_{i=0}^{n} 2^{i} p^{i+1}
$$
のように表せる（正解パス1つに対し、各深さで誤パスが現れる確率を加算する考え方）。

元論文では Bloom ベースの原型実装（Zig）を提示しており、後続で AMQ を使わないより高速な派生も示唆されている。

## 実践ポイント
- 偽陽性率 $p$ をまず設計目標に設定する。経験的には $p<0.5$、できれば $p\ll 0.5$ が安全。  
- $m,k$ は上の式で概算してから実測（メモリ・CPUトレードオフ）で微調整する。  
- チェーンヘッダの混合関数は高速で均一な分布を作ること。暗号関数は不要だが、衝突や偏りはデコード効率に響く。  
- 小規模なプロトタイプは既存の Bloom ライブラリ（Rust/Python/Go 等）で作れる。まずは短いメッセージ長で復号成功率と候補分岐数を計測する。  
- ユースケース例：分散バックアップの軽量冗長化、IoTセンサの送信冗長、P2P断片伝送の補助など、帯域やメモリが限られる場面で有望。  
- 実装参考：元記事は実装（Zig）と GitHub リポジトリを公開しているため、動作確認してアイデアを自分の環境に合わせて改良すると良い。

元記事はさらなる改良や AMQ を使わないバージョンの紹介を予告しているため、実装→測定→改善のサイクルで研究的に取り組む価値が高い。
