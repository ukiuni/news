---
layout: post
title: "Typechecking is undecidable when 'type' is a type - 「'type' が 'type' の場合、型検査は決定不能である」"
date: 2026-02-01T21:49:59.409Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://dspace.mit.edu/bitstream/handle/1721.1/149366/MIT-LCS-TR-458.pdf?sequence=6"
source_title: "Typechecking is undecidable when 'type' is a type (1989) [pdf]"
source_id: 46820874
excerpt: "type : type」を許すとコンパイラの型検査が決定不能化し実運用で暴走する危険"
---

# Typechecking is undecidable when 'type' is a type - 「'type' が 'type' の場合、型検査は決定不能である」
「型が自分自身の要素になる」罠：型検査が終わらない可能性と、その回避策

## 要約
1989年の論文は、言語において $type : type$（型がそのまま型である）を許すと、型検査（プログラムが型付け可能かどうかを判定する問題）が決定不能になることを示す。つまりコンパイラが「型が正しい」と断定できないケースや、判定が停止しないケースが存在する。

## この記事を読むべき理由
型システムは言語の安全性・最適化・IDE/ツールの基礎です。日本のプロダクト開発や言語実装、検証ツールを作る現場では、型検査の停止性・決定性は工数や信頼性に直結します。設計の誤りがコンパイラや型チェッカーの暴走＝実運用リスクを招きます。

## 詳細解説
- 問題の核：$type : type$ を許すと、型と値の境界が曖昧になり、型レベルで任意の計算（再帰や自己参照）を表現できるようになる。これにより停止性が保証されない計算を型レベルで表現でき、結果として「ある項がある型を持つか」を判定する問題が停止性やチューリング完全性に帰着する（すなわち決定不能になる）。
- 技術的スケッチ：論文は停止性や半決定性の既知の難問（例えばチューリングマシンの停止問題）を型判定の問いに埋め込むことで、型検査が一般にはアルゴリズムで決定不能であることを示す。自己適用や自己参照を型語彙として許す表現が鍵。
- 理論的背景：GirardのパラドックスやMartin-Löfの型論の歴史とも関係する。これらは「自由に自己参照を許すと矛盾や非決定性が出る」ことを別の角度で示す結果群の一部。
- 言語設計での帰結：実用的には $type : type$ をそのまま採用するのは危険。安全側策としては、階層化された宇宙（universes）$$Type_0 : Type_1 : Type_2 : \dots$$や、帰納的な制限、停止性/合計性の要求、型レベルの計算を制約する設計が一般的に採られる。

## 日本市場との関連性
- 組込み／自動車／医療など安全クリティカル分野での検証ツールやDSL設計では、型検査の停止性は必須要件。誤った型設計がツールの不安定化や審査の失敗を招く。
- 国内の言語実装コミュニティ（研究機関やスタートアップ）で新しい依存型機能や型レベル計算を導入する際の設計指針になる。
- GHC拡張やメタプログラミングを多用するプロジェクトでは、型レベルの表現力と判定可能性のトレードオフを理解しておくとデバッグ負荷を下げられる。

## 実践ポイント
- 新言語・拡張を設計するときは $type : type$ を避け、宇宙（universe）を導入する。
- 型レベル計算に強力な演算を入れる場合は、停止性（totality）や階層による制約を明確にする。
- 実装者は型チェッカーにタイムアウトやリソース制限を設け、無限ループ化を検出できるログや診断を整備する。
- 既存言語で高度な型機能を使う際は、コンパイラの警告や非決定的な型推論の可能性を意識し、規約で制限する（プロジェクトのコーディングルールに落とし込む）。
- 理論背景を短く学ぶ：Girardのパラドックス、Martin-Löf型論、依存型言語（Coq/Agda）がなぜ宇宙を採るかを押さえる。

元論文は理論の古典であり、言語設計とツール信頼性の境界を理解するうえで必読です。
