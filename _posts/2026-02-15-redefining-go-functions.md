---
layout: post
title: "Redefining Go Functions - Go関数の再定義"
date: 2026-02-15T16:12:18.516Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://pboyd.io/posts/redefining-go-functions"
source_title: "Redefining Go Functions | pboyd.io"
source_id: 441192759
excerpt: "Goバイナリを上書きしてtime.Nowを強制変更する危険だが面白いランタイムハック"
---

# Redefining Go Functions - Go関数の再定義
Goで関数を書き換えて「常に5時」にする――危険で面白いランタイム改変トリック

## 要約
Goの実行バイナリのメモリを書き換え、関数先頭にジャンプ命令を書き込んで別実装に差し替える話。unsafe/reflectとページ保護変更（mprotect/VirtualProtect）を使えば可能だが、多数の落とし穴と重大なリスクがある。

## この記事を読むべき理由
低レイヤーで「関数の振る舞い」を変える手法はデバッグや実験的ハックで魅力的だが、Go特有の最適化（インライン、ジェネリクス、メソッドのレイアウト）で思わぬバグを招く。日本の開発現場でもテストやホットパッチの誘惑があるため、仕組みと危険性を理解しておく価値がある。

## 詳細解説
- アドレス取得  
  reflect.ValueOf(fn).Pointer() で関数エントリのアドレスが取れる（x86_64の場合）。  
  ```go
  // go
  addr := reflect.ValueOf(time.Now).Pointer()
  fmt.Printf("0x%x\n", addr)
  ```
- バイナリを上書きして差し替える発想  
  置換先の関数へジャンプするjmp命令（x86: 0xE9 + 32bit相対オフセット）を先頭に書けば、呼び出し元は差し替え先の処理を実行する。retは元の呼び出し元へ戻るので呼び出し側は透過的。
- メモリ保護の変更が必要  
  実行領域は保護されているため mprotect（Unix系）や VirtualProtect（Windows）でページをRWXに変更する必要がある。ページ境界の丸めや領域サイズ計算に注意。
  ```go
  // go
  mprotect(addr, len(buf), syscall.PROT_READ|syscall.PROT_WRITE|syscall.PROT_EXEC)
  ```
- アーキテクチャ差分  
  ARM64では命令長やブランチの符号化が異なり、命令キャッシュクリアも必要。WindowsはAPI差し替え。
- 実用上の大きな問題点  
  - インライン最適化：コンパイラが呼び出し箇所に関数を展開していると、関数本体のエントリを書き換えても呼ばれない。  
  - ジェネリクス／内部ラッパー：取得できる関数ポインタと実際に呼ばれるコードが異なる場合がある。  
  - メソッドの置換と構造体レイアウト：置換先のメソッドが期待するレイアウトと受け側の型が違うと、フィールドオフセット誤りで巨大な数値やメモリ破壊を招く（記事中の32ビット/64ビットの例のような致命的な不整合）。
- 結論的な実用性  
  「できるが危険」。ライブラリ作者はLinux/AMD64向けに実装を公開しているが、一般運用や本番環境での使用は強く推奨されない。

## 実践ポイント
- テストで time.Now を差し替えたいだけなら、まずは依存注入（インターフェースやvarでのラップ）を検討する。  
- どうしても実行時パッチを試すなら、限定的にローカルで実験し、アーキテクチャ差・インライン化・構造体互換性を徹底確認する。  
- 本番レベルの代替策：モック／テストヘルパー、ビルドタグ、または公式のAPI設計による注入を優先する。  
- 実験用パッケージは存在するが（Linux/Unix AMD64向けなど）、使用は自己責任。PRや改善で学ぶのは有益。

実験としては面白いが、現場での採用は慎重に。
