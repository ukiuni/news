---
layout: post
title: "This year in LLVM (2025) - LLVMの2025年まとめ"
date: 2026-02-01T09:28:58.288Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.npopov.com/2026/01/31/This-year-in-LLVM-2025.html"
source_title: "This year in LLVM (2025)"
source_id: 1274237907
excerpt: "LLVM2025：ptr表現刷新とABI整備で最適化が劇的向上"
---

# This year in LLVM (2025) - LLVMの2025年まとめ
LLVM 2025年総まとめ：ポインタ表現の再設計と最適化改善でツールチェーンが次の段階へ

## 要約
LLVMは2025年にポインタ処理の表現刷新（ptradd への移行の準備）、ptrtoaddr の導入、lifetime/captureの整備、ABI低レベル化ライブラリのプロトタイプなど、IRと最適化インフラ周りで大きな変更を進めました。これらはコンパイラ最適化の信頼性向上とフロントエンドの実装負荷軽減を狙っています。

## この記事を読むべき理由
LLVMは多くの言語・ツールチェーン（Rust、Clang、各種組み込み／サーバー向けビルド）で基盤になっており、日本の開発現場でもビルド速度、最適化品質、FFIやABIの扱いに直結します。最新の設計方針を知ることで移行準備や最適化の恩恵を受けやすくなります。

## 詳細解説
- ptradd移行  
  - 目的は型ベースのgetelementptr(GEP)から、単純にポインタへ整数オフセットを足すptraddへ移すこと。2025年はGEPを「単一オフセット」へ正規化する作業が進み、複数インデックスを分割・定数オフセット分離・先頭ゼロ除去などが行われました。利点はptraddへの整合性だけでなく、共通GEPプレフィックスのCSEが効く点。残課題はスケール係数をptraddに持たせるか否かと、IR生成側で新形式を強制する工程です。

- ptrtoaddr  
  - ptrtoint と似るが「プロベナンス（由来情報）を暴露しない」「ポインタのアドレス部分のみ取得する」という点でCHERI対応やプロベナンス扱いの議論に対応する命令。最適化側はptrtoint/ptrtoaddr 両方を正しく扱う必要があります。

- lifetime intrinsics の制約強化  
  - lifetime.start/end を allocas に限定し、サイズ引数を廃止。これによりスタックカラーリング（未使用領域の再利用）が正しく動作するようにし、誤用検出や最適化の信頼性を高めました。ただし、ライブ判定やアロケーションの重複判定など根本的な効率化はまだ必要です。

- capture tracking（キャプチャ追跡）改良  
  - アドレスのキャプチャとプロベナンスのキャプチャを区別。多くの最適化はプロベナンスだけを気にすれば良いため、alias analysis やメタデータ（!captures）を活用して最適化余地を拡大。Rustの非可変参照での「read-only capture」を使った最適化が代表例です。

- ABI低レベル化ライブラリ（ABI lowering）  
  - フロントエンド毎に複雑なABIルールを再実装する問題を解決するため、独立したABI型システムと変換ライブラリの提案・プロトタイプが進行。x86-64 SystemV での試作は成功しており、フロントエンド実装負荷とターゲット差分を減らす期待があります。

- ConstantInt アサーション拡張  
  - 任意精度整数生成時の不整合によるミスコンパイル防止のため、ConstantInt::get() まで検査を広げ、過去に見逃したミスを検出・修正しました。

- コンパイル時間と最適化改善  
  - AArch64のコンパイルはx86に比べ10–20%遅め（GlobalISel等が要因）。SCCPのworklist改善、getBaseObjectSize導入、型割当計算の高速化などで小幅改善。ClangのAST表現変更で大幅なビルド時間改善が出た事例もあり、ビルド最適化の地道な改良が継続中です。

- 最適化パスの強化  
  - ストア合併（store merge）、PredicateInfoを非IPA SCCPでも利用、不要なassumeを削除するパス等を追加し、最適化品質を向上させています。

- Rustとの連携  
  - RustはLLVM20/21へのアップデートを適用し、read-only capturesやalloc-variant-zeroedなどRust向けの改善を活用。結果的にRustコードでの最適化信頼性が上がっています。

- パッケージング／ビルド体制  
  - Fedora/RHEL側でモノリシックビルドへの統合、PGO導入などパッケージビルドの改良を継続。ただし互換パッケージのインストール経路や多アーキテクチャ共存に関するRPMの制約で運用上の課題も露呈しています。

## 日本市場との関連性
- 日本でもRust採用が増え、FFI/ABIや最適化品質はプロダクト性能に直結します。  
- AArch64（ARMサーバーやモバイル）向けビルド効率の改善は国内開発のビルド時間短縮に貢献します。  
- 組み込みやセキュリティ用途でのポインタプロベナンス議論（CHERI的関心）は、産業機器やセキュアブート分野で意味を持ちます。  
- ディストリビューションや社内パッケージ運用を行う場合、パッケージングの変更点は互換性運用に影響します。

## 実践ポイント
- 開発環境のLLVMバージョンを追跡し、LLVM20/21の恩恵（特にRust利用時）を検証する。  
- カスタム最適化／パスを書く場合、ptrtoaddr と ptrtoint の違いや lifetime の新制約を確認する。  
- 大きな定数（>64bit）を扱うコードは ConstantInt 関連のチェックを入れる。  
- AArch64でのビルド遅延を観測したら GlobalISel の影響やコード生成段階のalias分析をプロファイルする。  
- ABIの整備（ABI lowering）を注視し、将来のフロントエンド対応を見越した設計に備える。

以上。原著のトピックを押さえつつ、まずは自分のプロジェクトでどの点が直撃するかを確認することをお勧めします。
