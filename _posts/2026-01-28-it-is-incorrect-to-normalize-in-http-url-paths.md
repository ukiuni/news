---
layout: post
title: "It is incorrect to “normalize” // in HTTP URL paths - HTTP URL パス内の「//」を“正規化”するのは誤り"
date: 2026-01-28T03:02:45.956Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://runxiyu.org/comp/doubleslash/"
source_title: "It is incorrect to “normalize” // in HTTP URL paths"
source_id: 1407179079
excerpt: "仕様通りに扱わないと'//'の正規化が重大な不具合を招く事例で解説"
---

# It is incorrect to “normalize” // in HTTP URL paths - HTTP URL パス内の「//」を“正規化”するのは誤り
『「//」を勝手に消すな！URL正規化の落とし穴とHTTPのルール』

## 要約
HTTP/URI仕様（RFC 3986 / RFC 9110）はパス内の空のセグメント（つまり隣接するスラッシュ）を許容しており、任意に`//`を`/`に潰すと識別子が変わるため、一般的な正規化処理として行うべきではない。

## この記事を読むべき理由
CDN、リバースプロキシ、キャッシュキー、ウェブフレームワーク、CLIツール（例：Git）などでURLを扱う日本の開発現場では、勝手なパスの正規化がバグやセキュリティ問題、意図しないリダイレクトを招きやすい。仕様に沿った実装が重要です。

## 詳細解説
- RFC 3986のpath文法は「segment = *pchar」と定義し、空のセグメント（長さ0）も有効とする。したがって`/a//b`は`["a", "", "b"]`という別のセグメント列を表す。
- 「正規化（normalization）」として仕様が許すのは、主に大文字小文字の正規化、パーセントエンコーディングの正規化、ドットセグメント（`.`と`..`）の削除などであり、空セグメントを削除して`//`を`/`に変換するルールは含まれない。
- HTTP（RFC 9110）はRFC 3986のパス文法を採用しており、HTTP側の正規化でも`//`を潰すことは規定されていない。唯一の例外は「空のパスは `/` と等価扱いする」など非常に限定的な処理だけ。
- 実運用の例として、あるGitホスティングが`/repo/`と`/repo//`を別のリソースとして扱い、`//`が付く方にリポジトリが存在するケースが示されている。一般的な正規化でこれを潰すとアクセス不能になる可能性がある。
- 結論：`//`を`/`に自動変換するのは「仕様違反」であり、オリジン（サーバ側）が両者を等価にする明示的ポリシーを持たない限り避けるべき。

## 実践ポイント
- URL正規化ロジックは仕様に従う：大文字小文字、％エンコード、ドットセグメントのみ扱う。`//`潰しは行わない。
- CDN・プロキシ・アプリのルーティング設定でパスをそのまま扱う（必要ならオリジンで正規化またはリダイレクトを明示）。
- ログやキャッシュキー設計時に`/a/`と`/a//`を別キーとして扱うかを明確化する。
- 外部サービスやライブラリを使う際は、勝手に`//`を潰すか確認。問題があればオリジンで恒久的リダイレクト（301）を用意してユーザー体験を統一する。
- テストケースに`//`を含めて挙動を確認する（ブラウザ、curl、クライアントライブラリ）。

仕様を無視した便利さは、あとで大きな手戻りになることがあります。仕様どおりに扱うことが最も安全です。
