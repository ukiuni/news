---
layout: post
title: "c-- (2008) - c--（シーマイナスマイナス）"
date: 2026-02-10T15:28:57.495Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.cs.tufts.edu/%7Enr/c--/"
source_title: "C-- Home"
source_id: 865963072
excerpt: "C--：GCや例外を明示できる、移植性と効率性を両立する低レイヤ中間言語"
---

# c-- (2008) - c--（シーマイナスマイナス）
コンパイラ設計を変える“低レイヤ中間言語”C--──今こそ知っておきたい理由

## 要約
C--は、複数のフロントエンド言語と最適化可能なコード生成器（バックエンド）をつなぐ「機械寄りの中間言語」で、ガベージコレクションや例外処理などのランタイム要求を明示的に扱える点が最大の特徴。

## この記事を読むべき理由
新言語やDSL、JIT、組込み向けコンパイラなどを作る際に、既存の複雑なバックエンドに頼らず「移植しやすく効率的なコード生成」の土台を持てるため、日本の開発者や研究者にも実務・研究で使える知見を提供する。

## 詳細解説
- 目的：フロントエンド（言語固有の解析部）とリターゲタブルな最適化バックエンドの間に共通のアセンブリ的インターフェースを置く。これにより前者・後者の開発を独立に進められる。  
- ランタイムインターフェース：GC、例外、正確なスタック/レジスタ情報などをランタイム側で実装できるよう仕様化している点が最も独創的。言語固有のランタイム要件をC--側で表現できる。  
- 機械レベル型システム：高級言語の型体系を無理に低レイヤへ押し込まず、レジスタやメモリ表現を明示的に扱える。これにより「レジスタに複数戻り値」「正しい末尾呼び出し」「計算されたgoto」などが実用的に扱える。  
- 実装状況：Quick C--というインタプリタ兼ネイティブコンパイラが公開されており、Pentium、Alpha、MIPSなどで動作実績あり。PowerPC/ARMなどへのバックエンド開発も進められた。研究プロジェクトとしてMicrosoft ResearchとNSFの支援を受けている。  
- ライセンスと利用：研究成果は自由に利用可能で、仕様書（PDF等）やソースが公開されているため実験・導入がしやすい。

## 実践ポイント
- Quick C--を落としてインタプリタ／コンパイラを触ってみる。まずはサンプルでGCや例外ハンドラの動作を確認。  
- 小さなフロントエンド（簡易言語）からC--を出力して、既存バックエンドでネイティブコード生成を試す。  
- ランタイム要件（GC方式、例外モデル）を仕様でどう表現するかを設計段階で定義する。  
- 組込み/ARM環境やJIT用途を想定するなら、C--のレジスタ/呼び出し規約が役に立つ。  
- 仕様書とソースを読み、既存のテストスイート（例：lccテスト）で互換性を確認する。
