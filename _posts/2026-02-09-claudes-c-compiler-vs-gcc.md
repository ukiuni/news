---
layout: post
title: "Claude's C Compiler vs. GCC - Claude の C コンパイラ vs. GCC"
date: 2026-02-09T05:54:04.565Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://harshanu.space/en/tech/ccc-vs-gcc/"
source_title: "CCC vs GCC - Harshanu"
source_id: 46941603
excerpt: "AI製コンパイラCCCは動作するがGCC比で数百〜数万倍遅く最適化とリンクで致命的欠陥"
---

# Claude's C Compiler vs. GCC - Claude の C コンパイラ vs. GCC
驚愕のAIコンパイラ実験：Claudeが「コンパイラを自力で書いた」結果、カーネルは通せたが実行速度は桁違いに遅かった理由

## 要約
AnthropicのClaudeだけで書かれたという「CCC」はCソースを一通りコンパイルでき（Linuxの.cファイルは全て通った）が、リンクで大量の参照エラーを出し、生成バイナリは正しく動くものの実行性能とサイズでGCCに大きく劣った。

## この記事を読むべき理由
AIが「コンパイラを自動生成できる」ことの実用的な限界と、実システム（カーネル／SQLite）で何が壊れるかを理解できる。日本のOS開発者、組込み／クラウドの性能エンジニア、AI支援開発の評価者にとって必読の実証例。

## 詳細解説
- 背景：CCCはRustで書かれ、x86-64/i686/AArch64/RISC-V64 をターゲット。フロントエンド、SSA IR、最適化、コード生成、アセンブラ、リンカ処理までAIが生成。  
- 検証対象：Linux 6.9（defconfig）とSQLite 3.46 の単体ベンチ。公平性を保つため同一VM／同一ソースで比較。  
- 主な結果（抜粋）：
  - SQLite 実行時間（-O0 比）：GCC 10.3s、CCC 2h06m → 約737倍遅延。GCC -O2では6.1s（CCCは-O2を事実上無視）。  
  - SQLite バイナリサイズ：GCC 約1.4MB（-O2）に対し CCC 4.27MB（約2.7–3x肥大）。  
  - コンパイラ自身のメモリ：GCC 272MB、CCC 1.6GB（約6x）。  
  - カーネル：CCCは全ての.cファイルをコンパイル（0エラー）したが、リンカで約40,784の未定義参照が発生して最終リンク失敗。  
- なぜ遅いか（主原因まとめ）：
  1. 過度なレジスタスピル：レジスタ割当が弱く、ローカル変数を次々にスタックへ退避。1回の操作がメモリ→レジスタ→メモリの無駄を繰り返す。  
  2. 最適化が事実上無効：-O0/-O2で出力が同一。GCCが行う多数の最適化（レジスタ割当、インライニング、ループ最適化、ベクトル化等）を行っていない。  
  3. コード膨張：命令数が増え命令キャッシュミスが増加、さらに遅延を増幅。  
  4. デバッグ情報／シンボル欠落とフレーム破損：nm/readelfで関数シンボルがほぼ無い、フレームポインタが壊れる痕跡あり。  
  5. リンカ／リロケーションの誤り：カーネル特有のジャンプテーブルやksymtabのリロケーション生成ミスが大量のリンクエラーを誘発。これが「リンカが最も難しい」ことの実例。  
- 性能への帰着：単純な逐次処理は数倍程度の遅延で済むが、ネストされたループやサブクエリ（数億〜数十億反復）ではレジスタスピル＋キャッシュ悪化が累積して数万〜十万倍の遅延に。

## 実践ポイント
- 検証手順：SQLiteや小さなマイクロベンチで正しさと性能を分離してテストする（/usr/bin/time -v、readelf/nm、perf）。  
- リスク評価：AI生成コンパイラは「言語の構文を扱う部分」は既にかなり行けるが、「アセンブラ/リロケーション/リンカスクリプト対応」「高品質なレジスタ割当・最適化」は人間の設計と長年の研究が必要。クリティカルな生産環境では即導入不可。  
- 実務での使い方提案：AIコンパイラはプロトタイピングや教育、非性能クリティカルなビルドで活用し、生成物は必ず既存ツール（GCC/clang）で比較検証する。問題箇所（シンボルテーブル、フレームポインタ、リロケーション）を重点的にチェックすること。  
- 日本市場への示唆：組込み機器やリアルタイム系、Linuxカーネル開発を行う日本の企業は、AIで短期間に「動くもの」を作れる利点を享受しつつ、性能・互換性の壁に注意して採用計画を立てるべき。

簡潔に言えば、CCCは「AIがコンパイラ全体を自動生成できる」ことを示す大きな一歩だが、GCCが数十年で築いた最適化・リンカ互換性・デバッグ性にはまだ遠く及ばない。
