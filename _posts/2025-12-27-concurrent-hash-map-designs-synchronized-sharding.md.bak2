---
layout: post
title: "Concurrent Hash Map Designs: Synchronized, Sharding, and ConcurrentHashMap"
date: 2025-12-27 07:40:28.695000+00:00
categories:
- tech
- world-news
tags:
- tech-news
- japan
source_url: https://bluuewhale.github.io/posts/concurrent-hashmap-designs/
source_title: 'Concurrent Hash Table Designs: Synchronized, Sharding, ConcurrentHashMap,
  and NonBlockingHashMap | Bluue Whale'
source_id: 437149191
excerpt: ConcurrentHashMapとシャーディングで競合を抑える最適設計を解説
---
# Concurrent Hash Map Designs: Synchronized, Sharding, and ConcurrentHashMap
グローバルロックからConcurrentHashMapへ――「競合」を制するハッシュマップ設計の実戦ガイド


## 要約
シンプルな全体ロックからシャーディング（ロック・ストライピング）、そしてJavaのConcurrentHashMapまで、スレッド競合と性能トレードオフの観点で各設計を比較し、どの場面で何を選ぶべきかを整理する。

## この記事を読むべき理由
マルチコア／クラウド環境でJavaを使う日本の開発現場では、スレッド競合が性能ボトルネックになることが多い。適切なハッシュマップ設計の選定はパフォーマンス改善の近道になるため、本記事で実戦的な判断基準を得るべきだ。

## 詳細解説
1) グローバルロック（Collections.synchronizedMap 相当）
- 実装：全ての公開メソッドを単一の mutex（monitor）で保護する。get/put/remove/resize/size すべてが同一ロックを取得。
- 長所：単純で正しさが明確。メモリフェンスや複雑な同期動作を追加する必要がない。
- 短所：全操作が直列化されるため、同時読み取りでも競合が発生しやすくスケールしない。高並列環境では単一スレッド性能に収束する。
- JVM側の注意：HotSpotの synchronized は内部的に thin lock → 競合で inflated lock に遷移するなど最適化を行うが、競合が増えればコストは高くなる。

2) シャーディング / ロック・ストライピング
- 実装：ハッシュ空間を複数のバケット集合（シャード）に分割し、各シャードごとに独立したロックを持つ。キーはハッシュでシャードに振り分ける。
- 長所：局所的な競合に抑えられ、読み書きの同時実行度が向上。比較的実装が分かりやすい。
- 短所：シャード数の選定（多すぎるとメモリ・オーバーヘッド、少なすぎると競合）が必要。リサイズや均衡を取る処理が複雑になりうる。全体操作（全件スキャン・サイズ算出）はコストが高い。
- 実運用のポイント：シャード数はコア数やスレッド数、想定アクセス分布（ホットキーの有無）を踏まえて決める。

3) Javaの ConcurrentHashMap（進化）
- 履歴：初期は Segment ベース（セグメントごとにロック）だったが、Java 8 以降は細粒度化（バケット単位の CAS/同期）に移行。
- 基本戦略：
  - 読み取りはほとんどロック不要で、volatileロードやCASで楽観的に行う（読み取りで大半のコストを回避）。
  - 更新は特定バケットに対して同期／CASで局所的に調整。大規模リサイズは段階的に行い、フォワーダーを使って移動を管理する。
  - 高負荷で衝突が激しいときは、バケットがツリー化（Treeify）され、連続リストの劣化を避ける。
- 長所：読み取り重視のワークロードで非常に高いスループット。内部に多くの最適化（CAS, volatile, 局所ロック, ツリー化）があり、一般用途での最良解となることが多い。
- 短所：内部の複雑さが増すため実装理解は難しい。特殊ケース（極端に多い書き込み、非常に高いホットキー）では設計の限界が露出することがある。size() 等の一貫した全体操作はコストが高いか近似値になることがある。

設計の共通テーマ
- 競合の単位をどこに置くか（グローバル vs シャード vs バケット）でスケーラビリティが決まる。
- 読み取り重視か書き込み重視か、ホットキーの有無、リサイズ頻度、メモリ許容度で最適解が変わる。
- JVMのロック実装やメモリモデル（volatile/CASの意味）を知ることが正しい選択に直結する。

## 実践ポイント
- ほとんどのケースでは ConcurrentHashMap を第一候補にする。特に読メインや混合ワークロードで効果が高い。
- 単純で安全な実装を求めるか、スケーラビリティ重視かで選ぶ：
  - 正しさ最優先・実装簡単 → synchronizedMap
  - 高スループットだが実装管理したい → シャーディング（シャード数をコア数×1〜4程度で試す）
  - 汎用的高性能 → ConcurrentHashMap
- 初期容量と負荷係数を適切に設定してリサイズ回数を減らす（リサイズは競合を引き起こす）。
- サイズ取得や全件操作はコストが高くなるので、頻繁に使うなら別設計（集計キャッシュ等）を検討する。
- ホットキー（特定キーへの集中アクセス）がある場合は、アプリ側でキー分散（ハッシュの増幅や副キー化）やレート制御を検討する。
- 性能検証は必須：JMH や負荷ツールで実際のスレッド数・アクセス分布で計測する。局所的な最適化が逆効果になることがよくある。
- 関連テクニック：高頻度カウンタは AtomicLong より LongAdder、集計はストライピングされたカウンタ等を使うと良い。

