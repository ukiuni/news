---
layout: post
title: "How a single typo led to RCE in Firefox - 単一のタイプミスがFirefoxでRCEを招いた話"
date: 2026-02-17T17:49:46.743Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://kqx.io/post/firefox0day/"
source_title: "How a single typo led to RCE in Firefox &ndash; kqx"
source_id: 1542023197
excerpt: "&と|の1文字ミスでFirefoxのWasmがRCEに至る脆弱性"
image: "https://kqx.io/images/banner.jpg"
---

# How a single typo led to RCE in Firefox - 単一のタイプミスがFirefoxでRCEを招いた話
魅力的タイトル: 「0か1かたった1文字の差が生んだ大事故 — FirefoxのWasmで見つかった“&”と“|”の罠」

## 要約
Wasm実装のリファクタで発生した1文字のタイプミス（& と | の取り違え）が、アウト・オブ・ライン（OOL）配列ヘッダを誤判定させ、Ion最適化されたWasm経路でメモリ破壊→任意コード実行（RCE）につながった。

## この記事を読むべき理由
ブラウザやWasmは日本のサービスでも広く使われており、ちょっとしたビット演算ミスが実運用の重大脆弱性になる例は、セキュリティ担当者・エンジニア双方にとって教訓になります。C++の微妙なビット操作、GC/JIT連携、Wasm最適化の相互作用を学べます。

## 詳細解説
- 問題箇所  
  Wasmの配列メタデータ処理で、フォワーディングポインタ（移動先を示すポインタ）に「LSB=1」を立てるべきところを、誤って「& 1」でマスクしてしまい常に0を保存していた（正しくは "| 1"）。結果、移動済みOOLバッファのヘッダが0になり、isDataInline関数の `(headerWord & 1) == 0` 条件を満たして「インライン配列」と誤判定される。
- なぜ致命的か  
  SpiderMonkeyはヘッダのLSBで「フォワーディングか通常か」を区別する設計になっており、このタグ付けが壊れるとJIT（Ion）が配列データへのポインタを誤って扱う。最適化されたWasmコードはこうした低レベルの前提に依存するため、誤判定→間違ったアドレス参照→メモリ破壊や情報漏洩、最終的にRCEに繋がり得る。
- 攻撃経路のポイント  
  - 脆弱性はGCがオブジェクトを移動した際に発生する「obj_moved」処理のミス。  
  - Baselineコンパイラ経路では発動せず、Ion最適化済みのWasm関数でのみトリガー可能。  
  - 実証（PoC）はWasmで128要素の配列を生成し、ループ中にGCを起こして最適化を誘導、ヒープスプレーで自由領域に制御データ（0x41等）を配置して読み書き／クラッシュを引き起こす手順。これによりアドレス漏洩→任意RW→RCEへと繋げられた。
- 開発側の脆弱性検出の難しさ  
  一見単純なビット演算ミスはコードレビューで見落とされやすく、最悪は最適化経路やGCのタイミング依存でしか再現しないため、通常の単体テストや静的解析だけでは検出が難しい。

## 実践ポイント
- すぐにできる防御策  
  - Firefox（およびSpiderMonkey）を最新版に更新する。公開済みの修正を適用済みのビルドを使う。  
  - 自前のネイティブコードではポインタタグ付けを使う設計なら、明示的なアサーションやユニットテストを追加する（LSBルールなど）。  
  - UBSan/ASan/ValgrindなどのサニタイザをCIに組み込み、GC移動やポインタ操作に対する検査を行う。  
- 開発・監査の習慣  
  - ビット演算やタグ付きポインタ操作はコードレビューで重点チェック。1文字の違いが致命的になるので差分を注意深く確認する。  
  - Wasm・JIT・GCが絡む領域は統合テスト（最適化有効時・GCタイミング変化時）を用意する。  
  - ヒープスプレーや最適化パスを想定したファズとシナリオテストを導入する。  
- 攻撃再現に興味がある技術者向け（簡潔）  
  - Firefoxのjs shellとjit-testのwasm.jsを使い、関数をウォームアップしてIon最適化を誘導。extra_gc_poisoning設定やヒープスプレー（churn）でPoCを作れる。詳細は公開されたリポートの手順を参照のこと。

以上が要点です。脆弱性は「設計×実装×最適化」の相互作用から生まれることが多く、細かなビット操作にも十分な注意とテストを。
