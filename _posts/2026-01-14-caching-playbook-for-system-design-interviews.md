---
layout: post
title: "Caching Playbook for System Design Interviews - システム設計面接のためのキャッシュ・プレイブック"
date: 2026-01-14T16:17:05.805Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://pradyumnachippigiri.substack.com/p/caching-playbook-for-system-design"
source_title: "Caching Playbook for System Design Interviews"
source_id: 426996284
excerpt: "面接で語れる実践的キャッシュ設計と運用テクニックを5分で解説、DB負荷軽減やスタンピード対策まで"
image: "https://substackcdn.com/image/fetch/$s_!_3V2!,w_1200,h_675,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F84f640e5-344a-4784-adde-21bb4fb589b8_3420x1454.png"
---

# Caching Playbook for System Design Interviews - システム設計面接のためのキャッシュ・プレイブック
5分で掴む実戦キャッシュ攻略：面接で語れる設計と本番で使えるテクニック

## 要約
キャッシュは「遅い処理を繰り返さない」ための最も効果的な手段で、レイテンシ削減とDB負荷軽減に直結する。本稿はレイヤー、戦略、縮退（eviction）方針、実運用での落とし穴を分かりやすく整理します。

## この記事を読むべき理由
面接で「キャッシュどう設計する？」と問われたとき、理論だけでなく現場で使える実践的な判断基準を示せれば差がつきます。日本のSaaS／Eコマース／ゲームなど読み取り負荷が高いサービスでは、低遅延化とコスト管理が直接ビジネス価値になるため必須の知識です。

## 詳細解説
- キャッシュとは  
  データや計算結果のコピーを高速な場所に置き、次回の要求を速く返す仕組み。目的はレイテンシ低下とDB/ストレージの負荷軽減。万能でないため「熱いデータ（hot data）」のみを選んで置く。

- キャッシュを置く場所（レイヤー）  
  1. クライアント側（ブラウザ）: 静的資産（画像・CSS・JS）に有効。HTTPヘッダー（Cache-Control, ETag）で制御。  
  2. CDN（エッジ）: 地理的に分散して配信。日本なら東京リージョンのエッジを使えば国内ユーザーの体感速度が改善。  
  3. 外部キャッシュ（Redis/Memcached）: 共有メモリとして複数サーバで利用。TTLやevictionをバックエンドで管理できる。  
  4. プロセス内キャッシュ（ローカルHashMap）: 単一インスタンスで超高速。設定やフラグ、小さな集計向けだが複数インスタンス間の一貫性に注意。

- キャッシュ戦略（代表4種）  
  1. Read-Through: キャッシュがDBを代理して読み書きする。初回はDBに行くが以降高速。ロジックはシンプル。  
  2. Cache-Aside（Lazy Loading）: アプリが先にキャッシュをチェック、ミス時にDBから読み取りキャッシュに入れる。障害時はDBでフォールバックできるため堅牢。  
  3. Write-Through: 書き込みを同時にキャッシュとDBへ行う。整合性が高いが書き込み遅延が増す。  
  4. Write-Behind（Write-Back）: キャッシュに書いてDBへの同期を遅延させる。書き込み高速化だがクラッシュ時のデータ損失リスクあり。

- スケーリングと分散キャッシュ  
  単一ノードはRAM制約で限界。水平スケールではレプリケーション（読み取り向け）かシャーディング（書き込み多め）を採る。シャード割り当てはハッシュ関数で決めることが多く、サーバ数Nに対してキーの配置は例えば $server = hash(key) \bmod N$ で求める。サーバ追加・削除による再配置問題は一貫性ハッシュ（consistent hashing）で緩和する。

- Eviction（縮退）ポリシー  
  キャッシュは容量有限なので方針が重要。典型的なもの：LRU（最も長く使われていないものを削除）、LFU（利用頻度の低いものを削除）、TTL（時間経過で削除）、FIFO（先入れ順に削除）。アプリ特性に応じて選ぶ。

- 実運用でよく遭遇するエッジケース  
  ・キャッシュスタンピード（同時に多数のミスが発生してDBへ殺到）  
  ・整合性問題（DB更新後のキャッシュ無効化漏れ）  
  ・ホットキー（特定キーにアクセス集中で単一ノードがボトルネック）  
  対策例：ロック（mutex）やリクエスト合成、バックグラウンド再計算、ホットキーは分散/レプリケーションで受け止める。

- 効果測定指標  
  ヒット率、ミス時のレイテンシ、バックエンドのQPS低下量、キャッシュのメモリ使用率。TTLは「鮮度」と「ヒット率」のトレードオフなので、データの揮発性を基に決める。

## 実践ポイント
- 面接で語るときは「何を優先するか（低遅延／強整合性／耐障害性）」を最初に宣言する。  
- 一般用途はCache-Asideが無難：故障時はDBが答えるため堅牢。  
- 金銭的コストとスピードのバランスでTTLを決定。動きが速いデータは短め、安定データは長めに。  
- 水平スケールでは一貫性ハッシュを検討し、ホットキーには専用対策（キー分割、レプリケート）を用意。  
- キャッシュスタンピード対策として、ミス時のDBフェールバック／早期再計算（stale-while-revalidate）やリクエスト集中時のバッファリングを導入する。  
- まずはメトリクス（hit rate, p99 latency, backend QPS）を出し、変更のABテストで効果を確認する。

以上を短く整理して説明できれば、面接でも本番設計でも説得力のあるキャッシュ設計が提示できます。
