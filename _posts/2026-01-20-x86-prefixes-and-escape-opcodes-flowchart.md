---
layout: post
title: "x86 prefixes and escape opcodes flowchart - x86 プレフィックスとエスケープオペコードのフローチャート"
date: 2026-01-20T06:30:26.297Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://soc.me/interfaces/x86-prefixes-and-escape-opcodes-flowchart.html"
source_title: "x86 prefixes and escape opcodes flowchart"
source_id: 46687705
excerpt: "x86プレフィックスとエスケープの流れを図解でREX/VEX/EVEX対応まで一発理解"
---

# x86 prefixes and escape opcodes flowchart - x86 プレフィックスとエスケープオペコードのフローチャート
思わず分解したくなる！x86 命令の「接頭辞→エスケープ→拡張」フローを図解で理解する

## 要約
x86 系命令は先頭のバイト列（プレフィックス）で「どの命令表（map）を使うか」「オペランド幅やベクトル長をどう解釈するか」を決める。REX／VEX／EVEX／APX といった拡張プレフィックスが登場することで、追加レジスタやベクトル機能、AVX‑512 の制御が可能になっている。

## この記事を読むべき理由
命令のバイト列を正しく読む力は、コンパイラ最適化、JIT、逆アセンブル、マルウェア解析、低レイヤ高速化のいずれにも不可欠。日本の組込み・金融系やゲーム開発でネイティブ性能を追うなら、プレフィックス→マップ→オペコードの流れを押さえておくと差がつく。

## 詳細解説
- 基本構造  
  1. 先頭に付く「プレフィックス群」でモードを決定（例: 0x66：オペランド幅の変更、0x67：アドレス幅）。  
  2. 次に「エスケープバイト」（典型は 0x0F）。0x0F の後に 0x38 や 0x3A が来れば、それぞれ別の命令マップ（legacy map 2 / 3）へ分岐する。map 0 は 1バイト命令、map 1 は 0x0F ベース、map 2/3 は 0x0F38/0x0F3A。  
  3. VEX/EVEX/C4/C5/62 といったマルチバイトプレフィックスは、従来のプレフィックスを「フィールド化」して、追加レジスタ（v）、拡張ビット（R/X/B）、命令マップ選択（m）、必須プレフィックス（p）、ベクトル長（L）やゼロマスク（z）などをエンコードする。

- 主要プレフィックス（簡潔）
  - 1バイトの REX (0x40–0x4F): AMD64 で導入。W/R/X/B ビットで 64bit & レジスタ拡張を提供。  
  - VEX (C4 / C5): AVX で導入。m（命令マップ）、v（追加ソースレジスタ）、L（長さ 128/256）、p（必須プレフィックス）などを持つ（2/3 バイト版あり）。  
  - EVEX (0x62): AVX‑512 用。VEX の上位互換でさらに z（ゼロマスク）、Ŀ/ L（512/256/128 の長さ／丸め制御）、b（ブロードキャストや例外抑制）等を持つ。m フィールドは map1/2/3 に加え map4/5/6 を扱える（APX/AVX512‑float16 など）。  
  - APX / 新しい REX 相当（最近の拡張）: REX を拡張して将来の命令や APX レジスタ拡張を扱うための新しい形式が検討されている（図では REX 2 バイト版の案を示す）。

- 命令デコードの流れ（実務的に押さえるべき点）
  - バイト列を左から解析：連続した 1 バイトプレフィックス（LOCK / セグメント / 66 / 67 等）を読み、次に REX/VEX/EVEX があればそれを解釈して「内部フィールド」を抽出。  
  - 0x0F 系のエスケープは命令マップを変える合図。0x0F → map1、0x0F 38 → map2、0x0F 3A → map3。VEX/EVEX の m フィールドはこれを直接選ぶ。  
  - p（必須プリフィックス）フィールドが 0/1/2/3 で (none / 66 / F2 / F3) を表し、同じ意味のプレフィックスを MANDATORY として命令に組み込む。W は命令固有で 64bit オペランド拡張やエンコード拡張を意味する。  
  - EVEX ではマスク・ゼロ化や例外抑制など、命令の動作にも直接影響するフィールドが増えている（AVX‑512 固有）。

## 実践ポイント
- まずバイト列を見て 0x0F / 0x38 / 0x3A を見つける習慣をつける。これで「どの命令表か」が一発で分かる。  
- VEX/EVEX を扱うときは「m/p/W/v/L/z/R/X/B の意味表」を手元に置く（Intel SDM Vol.2 と Intel XED は最良の参照）。  
- 解析ツールの活用：objdump/ndisasm/Capstone/Intel XED で出力比較を行い、バイト→フィールドの対応を確認する。例: objdump -d -Mintel、Capstone の Python バインディングで逐次デコード。  
- セキュリティ／逆アセンブル用途では EVEX の z/b/Ŀ フィールドが命令の副作用（ゼロ化やブロードキャスト）に直結するため、正確に扱うことが重要。  
- 実験環境：小さなバイナリを作って各プレフィックスを付け替え、disassembler の出力がどう変わるかを確認すると理解が速く深まる。

短時間で効果的に学ぶには、まず「どのバイトがマップを決めるか（0x0F / 0x38 / 0x3A）」と「VEX/EVEX の主要フィールド（m/p/W/v/L/z/R/X/B）」を覚えて、実際にいくつかの命令バイト列をデコードしてみることを勧める。
