---
layout: post
title: "Shell scripts - シェルスクリプト"
date: 2026-01-09T14:31:20.772Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://f5n.org/blog/2026/shell-scripts/"
source_title: "Shell scripts"
source_id: 905740760
excerpt: "20行超の運用シェルをJanetやPythonで安全・可視化して保守負荷を劇的に下げる実践ガイド"
---

# Shell scripts - シェルスクリプト
シェルスクリプト、20行を超えたらどうする？Janetの sh がくれる現実的な代替

## 要約
長くて複雑になるシェルスクリプトは保守がつらい。著者は Janet の sh ライブラリや Python、Lua の小さな実験を通して「ほどよい」代替を模索している。結論は「用途に応じて使い分ける」のが現実的、という話。

## この記事を読むべき理由
- 日々の運用スクリプトやリポジトリのちょっとした自動化は日本の現場でも多く、可読性・デバッグ性を上げる手段は即戦力になる。
- CI/運用で動くスクリプトの保守コスト低減や、cron やコンテナで起きやすい落とし穴（例: -it を cron で使うミス）を未然に防げる。

## 詳細解説
- 問題設定  
  シェルは小さな「接着（glue）」用途には手早いが、20行を超えるようなロジックや条件分岐・文字列処理が増えると一気にバグや可読性の問題が出る。多数の言語ランタイムで exec/popen 周りを扱う煩雑さも問題。

- Janet + sh パッケージ  
  著者が気に入ったのは Janet の sh パッケージ（janet-sh）。シェル風のコマンド呼び出しをライブラリ的に扱えて、いちいち argv 配列を組み立てる必要が減る。パイプやコマンド出力の利用が自然に書けるため「シェルの便利さ」と「プログラミング言語の表現力」の中間地点を狙えるのが利点。

  例（雰囲気）:
  ```janet
  #!/usr/bin/env janet
  (use sh)
  ($ echo "# Local branches")
  (run git br)
  ($ echo "# Last renovate commits")
  (run git log --oneline --grep Renovate -n 3)
  ```
  - ($ ...) や (run ...) で外部コマンドを呼び、パイプや出力取得が直感的に書ける。
  - シェルの生の構文をそのまま文字列で書くより、安全でデバッグしやすい。

- Python による書き換え  
  単純なデバッグ性や既存ライブラリの豊富さで Python に移す選択肢は現場で現実的。cron で実行するジョブの誤り（例えば対話的オプション -it を付けるなど）を見つけやすいのも利点。外部プロセスの扱いは subprocess.run 等で明示的に stdout を取り扱える。

  例:
  ```python
  # python
  import subprocess
  av = ["docker", "ps", "-f", "name=postgres", "--format", "{{.ID}}"]
  cid = subprocess.run(av, stdout=subprocess.PIPE, check=True).stdout.decode().strip()
  ```

- Lua の harsh 等の実験的アプローチ  
  shell ライクな文をそのまま書ける利点はあるが、ラッパーのボイラープレートやパーサーの堅牢性が課題。結局のところ「動けば良い」のと「保守できる」のは別問題。

- トレードオフと実務的な判断  
  - Janet は便利だがランタイムの普及度は低い。日本企業の現場では Python やシェルはほぼあるが、Janet を常備するのは難しい場合がある。  
  - 小さければシェルで良い。複雑化するなら Python などデバッグしやすい言語へ移行。ランタイム提供が難しい環境では単一バイナリ化やコンテナ運用で対応する選択肢も。

## 実践ポイント
- ルール（目安）  
  - 20行前後を超えて条件分岐や文字列処理が増えるなら、シェルから高級言語へ移行を検討する。  
  - 実行環境にインタプリタがあるかを確認。Janet や特殊言語を使うならランタイム配布方法を決める（コンテナ、パッケージ、バイナリ化）。

- すぐ試せること  
  1. cron で動かすジョブは必ず非対話モードで試す。-it を付けない。出力はファイルにリダイレクトしてログを残す。  
  2. 外部コマンドの出力取得は明示的に行う（Python の subprocess.run や Janet の run を利用）。  
  3. 既存の長いシェルスクリプトを段階的に置き換える：まずログ・エラーハンドリングを追加してから言語移行。  
  4. CI に lint と実行テストを入れる（小さな自動テストで「Patch Day」の負担を下げる）。

- 選択ガイド（簡易）  
  - 単純な列挙・パイプ処理：シェルのまま OK。  
  - 条件分岐やデータ加工が増える：Python（採用率高）または Janet（学習コスト＋ランタイム配布を考慮）を検討。  
  - 環境依存を避ける：コンテナ化してランタイムを固定する。

短くまとめると、「シェルの手軽さを捨てずに可読性・デバッグ性を上げるには、言語的なラッパー（Janet の sh 等）や Python へ段階的に移行するのが現実的」。日本の現場ではインタプリタの普及状況や配布方法を踏まえて、実行可能な選択肢を選ぶのが重要。
