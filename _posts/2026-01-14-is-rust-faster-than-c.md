---
layout: post
title: "Is Rust faster than C? - RustはCより速いか？"
date: 2026-01-14T13:10:41.235Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://steveklabnik.com/writing/is-rust-faster-than-c/"
source_title: "Is Rust faster than C?"
source_id: 46569175
excerpt: "RustがCより速いかは一概に言えず、実装・データ配置・ツールで差が出るため実測で確かめる価値あり"
---

# Is Rust faster than C? - RustはCより速いか？
速さの真実：Rustは本当にCより速いのか？ — 現場で判断するためのポイント

## 要約
言語そのものに「絶対に速い」という差はない。実装、コンパイラ、データレイアウト、開発者の判断、そしてプロジェクト文脈が性能を決める。

## この記事を読むべき理由
日本でも組み込み、サーバ、WebAssembly、ブラウザ周辺などで性能と安全性の両立が話題です。RustとCの“速さ”に関する誤解を解き、実務でどちらを選ぶかの判断材料を得られます。

## 詳細解説
- 言語設計と実行速度の関係  
  Rustはゼロコスト抽象や最適化を前提に設計されており、Cと同等の低レイヤー制御が可能です。理論上はCでできることはRustでも可能で、逆もまた然りです。重要なのは「同じ仕様」をどう実装するか。

- インラインアセンブリ  
  両言語ともインラインアセンブリで同等のコードを埋め込めます。たとえばrdtsc（CPUのタイムスタンプカウンタ）を読む例は、RustとCで同じアセンブリ出力になります（最適化オプション依存）。
  
  ```rust
  // rust
  use std::arch::asm;
  #[no_mangle]
  pub unsafe fn rdtsc() -> u64 {
      let lo: u32;
      let hi: u32;
      asm!("rdtsc", out("eax") lo, out("edx") hi, options(nomem, nostack, preserves_flags));
      ((hi as u64) << 32) | (lo as u64)
  }
  ```

  ```c
  // c
  #include <stdint.h>
  uint64_t rdtsc(void) {
      uint32_t lo, hi;
      __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
      return ((uint64_t)hi << 32) | lo;
  }
  ```

- データレイアウトの違い  
  同じ見た目の構造体でも、Rustはフィールド再配置などでメモリサイズが小さくなることがあります（デフォルトは最適化される）。Cと同じレイアウトを保証したければ `#[repr(C)]` を使います。つまり「同じ構造」をどう定義するかで性能が変わります。

- 安全チェックとランタイム影響  
  多くの安全性チェックはコンパイル時に解決されますが、配列境界チェックなど一部はランタイムで行われます。とはいえ、コンパイラが証明できればチェックは削除されるため、最終生成物はCと同等になることが多いです。一方で「安全性があるからこそ書ける高効率な並列化」がある点は無視できません（MozillaのStyloがその例）。

- 社会的・運用的要因  
  同じチームが同じタスクをCとRustで実装するとは限りません。言語の安全性やツールチェーンが設計判断に影響を与え、結果として違う実装（＝違う性能）になります。つまり性能差は技術だけでなく「人とプロセス」にも依存します。

- 結論（元記事の要旨）  
  根本的には「Rustだから遅い／速い」ということはない。プロジェクトの条件、開発者の選択、コンパイラの振る舞い、そして測定次第で答えが変わる。

## 実践ポイント
- 性能判断は「測定」から始める（プロファイラ／ベンチを用意）。  
- ABIや他言語連携が必要なら `#[repr(C)]` を使ってレイアウトを固定する。  
- 低レイヤ最適化が必要ならインラインアセンブリや最適化フラグを使う。  
- ボトルネックはデータレイアウトやメモリアクセスが多い：構造体の配置やキャッシュフレンドリーな設計を優先。  
- 安全チェックを外すときは `unsafe` / `get_unchecked` を限定して使い、必ず測定とレビューを行う。  
- チームの習熟度を考慮する（並列化や大規模なリファクタが目的ならRustの安全性が効果を発揮することがある）。  

短くまとめると、言語の選択は「理論的な最高速」ではなく「実際に作るもの・作る人・測る方法」によって決まります。まずは小さなプロトタイプで比較して、実測に基づく判断を。
