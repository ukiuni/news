---
layout: post
title: "Two Bits Are Better Than One: making bloom filters 2x more accurate - 2ビットでブルームフィルタの精度を2倍にする"
date: 2026-02-22T04:57:14.157Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://floedb.ai/blog/two-bits-are-better-than-one-making-bloom-filters-2x-more-accurate"
source_title: "Two Bits Are Better Than One: making bloom filters 2x more accurate"
source_id: 47046070
excerpt: "1メモリアクセスで誤検知半減、ブルームフィルタを2倍精度化する実践手法"
image: "https://floedb.ai/hubfs/BlogCover/bloom_filter.png"
---

# Two Bits Are Better Than One: making bloom filters 2x more accurate - 2ビットでブルームフィルタの精度を2倍にする
1メモリアクセスで誤検知を半減する――Terabyte級スキャンを劇的に速くする小さな最適化

## 要約
ブルームフィルタの「1ハッシュ＝1ビット」実装を、1つのuint32内に2つのビットを格納する手法に変えることで、誤検知率（false positive）が約2倍改善され、実運用でデータ解凍やI/Oを大幅に削減できるという話。

## この記事を読むべき理由
大規模データベースやLakehouseでのクエリ速度は、データの不要な解凍やハッシュ検査をいかに避けるかで決まります。日本企業のクラウドコスト削減やBIクエリ応答性改善に直結する実践的な最適化です。

## 詳細解説
- ブルームフィルタの役割：ある要素が「確実に集合に無いか」を高速に判定（偽陽性あり、偽陰性なし）。数サイクルのチェックで大量行を早期に捨てられるため、列ストアのデコードやハッシュジョインのProbe側で威力を発揮する。  
- 課題：挿入要素が増えるとフィルタが飽和し、偽陽性率が増える。標準的な偽陽性率は次式で与えられる：  
  $$
  \text{FP} = \left(1 - e^{-kn/m}\right)^k
  $$  
  ここで $k$ はハッシュ数、$m$ はビット数、$n$ は挿入数。例：$k=1, n=256\text{k}, m=2\text{M}$ では約 $11.5\%$ の偽陽性となる。  
- 提案：従来の「1ハッシュ→1ビット」から、1つのハッシュ値を分解して同じuint32内の2箇所にビットを立てる（＝1メモリアクセスで2ビット操作）。利点は：  
  - メモリアクセスが1回で済む（キャッシュ効率向上）  
  - 原子演算も1回で済む（ロックフリーで並列に強い）  
  - ビット生成はビットシフトと論理和で安価  
  トレードオフはビットが完全独立ではなく若干の相関が生じる点だが、実測では誤検知が約2倍改善される（11.7% → 5.7%）という圧倒的効果が得られた。  
- 実装のコア（概念）：同一uint32インデックスを決め、ハッシュの異なるビットスライスで2つのビット位置を算出してマスクを作り、単一の原子ORで設定／検査する。パフォーマンス差はほぼ無視できる（put:+6%サイクル、contains:+1.2サイクル実増）。  

```c
// 概念コード（C/C++風）
uint32_t idx = index_from_hash(h);                 // どのuint32要素か
uint32_t b1  = (h >> IDX_BITS) & 31;               // 0..31
uint32_t b2  = (h >> (IDX_BITS+5)) & 31;           // 次の5ビット
uint32_t mask = (1u << b1) | (1u << b2);
__sync_fetch_and_or(buf + idx, mask);              // 原子ORで2ビット設定
```

- なぜ「2ビット」が良いか：2ビットは容量対コストの最適点。3〜4ビットにすると容量増分が漸減し、メモリアクセス増や計算増を正当化しにくい。固定サイズ（例：256KB）にしておくことでキャッシュ挙動が予測可能になり、並列性の制約も少ない。

## 実践ポイント
- ハッシュジョインのprobe前に固定サイズブルーム（例256KB）を用意し、probeで先にフィルタ検査を行う。  
- 同一uint32内に2ビットを立てる設計に変更して、1メモリアクセス・1原子操作を維持する。  
- ストレージ層では「アダプティブなプッシュダウン」を採用：フィルタの有効性（スキップ率）を統計で監視し、有効時のみ先行デコードを行う。  
- 運用で見るべき指標：偽陽性率、スキップされたバイト数（解凍回避効果）、フィルタのビット占有率。閾値を超えたらフィルタ無効化を自動化する。  
- 余力があればSIMDで複数要素をまとめてチェックする最適化も検討する（次フェーズの改良）。

以上の施策は、クラウドI/O課金やBI応答性に直結するため、日本のデータプラットフォーム運用でも即効性のある改善になります。
