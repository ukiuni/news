---
  layout: post
  title: "Pre-tenuring in V8 - V8における事前テニュアリング"
  date: 2026-01-06T09:18:59.943Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://wingolog.org/archives/2026/01/05/pre-tenuring-in-v8"
  source_title: "pre-tenuring in v8 — wingolog"
  source_id: 469830753
  excerpt: "V8がAllocationSiteで長寿命割当を旧世代へ直接割当てGCコストを削減"
  ---

# Pre-tenuring in V8 - V8における事前テニュアリング
V8が「若くないオブジェクト」を見抜いて幼年期を飛ばす仕組み — GCの無駄を減らす“AllocationSite”の話

## 要約
V8は実行時に各割当サイトの生存率を観測し、短命でない割当は最初から旧世代（old generation）へ直接割り当てる「事前テニュアリング」を行う。これにより、ニーズの高いケースでコピーや書きバリアのオーバーヘッドを削減する。

## この記事を読むべき理由
JavaScript実装やパフォーマンス改善に関心がある日本の開発者にとって、事前テニュアリングはGCコスト削減の実践的な手段であり、アプリの割当パターン次第で大きな効果差が出る。ブラウザ／サーバーサイドでの最適化方針を判断する材料になる。

## 詳細解説
- 基本戦略  
  - 多くの割当は短命なので「ナーサリー（新世代）」に置き、頻繁に回収するジェネレーショナルGCが有利。ただし割当サイトごとに生存率が高い場合、最初から旧世代に置いた方が無駄が少ない。  
- 実装概要（V8の仕組み）  
  - 割当箇所ごとに AllocationSite オブジェクトを持ち、実際の各割当の直後に置かれる AllocationMemento が対応する AllocationSite を参照する。  
  - 割当時は AllocationSite の created カウントを増やす。軽量なスカベンジ（minor GC）でオブジェクトを訪問すると、直後の AllocationMemento を見て対応する AllocationSite の found カウントを増やし、そのサイトをセットに登録する。  
  - ある AllocationSite が 100 回の割当を観測すると事前テニュアリング判定対象になる。過去の観測で 85% 以上が生き残れば「事前テニュアリングすべき」とマークする。  
  - マークされた割当箇所があると、そのコードは一度 deopt（最適化解除）され、次回の最適化時にコード生成が変わって旧世代へ直接割当を行うようになる。  
  - 逆にメジャーGCで旧世代の 90% 超を回収すると、事前テニュアリングは「早すぎた」と見なしてリセットされる（過剰テニュアリングの撤回）。  
- 適用対象の制約  
  - 常時適用されるケースもある（例：wasm のメモリ、ブートストラッパやパーサ由来のリテラル、C++側からの割当）。  
  - 一般的な適用は限定的で、実装時点では主にオブジェクトリテラル、配列リテラル、new Array といった「生成と同時にフィールド値が作られる」割当に限定されている。  
  - 生成後に連続したストアで初期化するパターンだと、旧世代→新世代の参照（old-to-new edge）を作りやすく、コピーや書きバリアのオーバーヘッドが逆効果になるため適用が慎重になる。  
- 歴史的事情と今後の余地  
  - AllocationSite の仕組みは型付き配列やオブジェクトのボイラープレート最適化に由来し、その延長で事前テニュアリングが実装されたため、当面はリテラル中心の適用に留まっている。クラス的生成や最適化コンパイラ側での拡張余地はありそうだ。

## 実践ポイント
- 割当の「どこ」が長生きしているかを計測する：ヒープスナップショットや割当サイトごとのプロファイリングを確認する。  
- リテラルで大量に作るオブジェクトが生存率高ければ、コード構造を見直して早期テニュアリングの恩恵を受けられる可能性あり。  
- 逆に「生成→後で逐次初期化」するパターンは旧世代化の副作用（書きバリア・コピー）で悪化することがあるので避けるかパターンを変える。  
- ベンチ（例：Splayなど）で事前テニュアリングの効果を評価する。大きなGCが走るとV8側の判断でリセットされる点に注意する。  
- 将来的な最適化の余地を視野に、Hot path の割当パターンを単純化しておくと、JITやGCの恩恵を受けやすくなる。
