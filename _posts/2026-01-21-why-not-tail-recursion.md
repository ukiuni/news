---
layout: post
title: "Why not tail recursion? - なぜ末尾再帰ではダメなのか?"
date: 2026-01-21T08:04:25.051Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://futhark-lang.org/blog/2026-01-20-why-not-tail-recursion.html"
source_title: "Why not tail recursion?"
source_id: 1067574981
excerpt: "Futharkが末尾再帰を排してGPUで確実に高速化する理由"
---

# Why not tail recursion? - なぜ末尾再帰ではダメなのか?
驚くほど速く、でも「再帰は禁止」。GPU時代の関数設計に挑むFuthark流の割り切り

## 要約
Futharkは高性能GPU向けに設計された関数型言語で、再帰関数を禁止し代わりに明示的なループ構文を用いる。これはスタック使用を避け、GPUやCバックエンドで確実に高速化できることを優先した設計判断である。

## この記事を読むべき理由
GPUや並列計算を使う日本の開発者／研究者にとって、言語設計のトレードオフは実装の高速化と移植性に直結する。Futharkの選択は「速さを最優先する現場」で実務にどう影響するかを理解するうえで示唆に富む。

## 詳細解説
- 背景：Futharkは純粋関数型かつデータ並列を重視する言語で、ターゲットは主にGPUなど「スタックが制限される」環境。一般的な再帰は逐次的（シーケンシャル）であり、並列環境では制約が多い。
- 問題点：多くの言語は末尾再帰（tail recursion）を最適化してスタックを使わないようにするが、FutharkはCコードを生成してから下流のコンパイラに任せる設計であり、C上での末尾呼び出し最適化は移植的に保証できない。trampolining等の技法はあるが、GPUドライバやカーネルコンパイラを混乱させるリスクがある。
- 解決策：Futharkは「loop ... do ...」といった専用の逐次ループ構文を導入し、意味的には局所的な末尾再帰関数と等価だが、構文的に末尾呼び出しが明示されるためコンパイラは確実にスタックを使わないコードを出力できる。
- 言語設計の哲学：  
  - 単純で合意可能な規則を優先。tail-call最適化を「いつも行う」と保証するより、言語レベルで使える構文を限定して確実性を担保する。  
  - Haskellの例（$ 別名の中に再帰呼び出しが隠れるため判定が難しい）を挙げ、表面的な構文だけで判定する方法の限界を示している。
- 参照規格：Schemeは明確に末尾呼び出しの規約を持つ言語の好例だが、Futharkはより厳格に「構文でループを表現させる」選択をした。

例（概念的な比較）：
```futhark
-- Futharkの逐次ループ（概念例）
loop acc = 1 for i < n do acc * (i + 1)
```

```haskell
-- Haskellの末尾再帰的階乗
fact acc i = if i == 0 then acc else fact (acc * i) (i - 1)
-- $ を使うと末尾判定が表面的には難しくなることがある
fact acc i = if i == 0 then acc else fact (acc * i) $ i - 1
```

数式的には階乗は
$$
n! = \prod_{i=1}^{n} i
$$
と表せ、逐次ループで累積積を取ることでスタックを使わずに実装できる。

## 実践ポイント
- GPU向けやCバックエンドを目標にする場合、言語／フレームワークの「末尾再帰最適化の保証」を鵜呑みにしない。明示的なループ構文で実装するのが確実。
- Futharkを使うなら、再帰的思考を逐次ループへ書き換える習慣をつけると移植性と性能が安定する。
- HaskellやOCaml等で書いたアルゴリズムをGPU実装に移す際は、$ や中間関数で末尾位置が隠れていないか確認してから変換する。
- 日本のGPU／数値計算コミュニティ（機械学習、数値シミュレーション）では、Futharkのような「高速性最優先」の言語設計は実務上有益。実装時の制約を受け入れ、アルゴリズム設計を調整することが近道。

（注）Futharkの設計は「速さのための割り切り」。言語の美しさや表現力を優先したい場合は別の言語を選ぶのが現実的。
