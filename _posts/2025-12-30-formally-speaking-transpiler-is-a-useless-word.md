---
layout: post
title: "Formally speaking, \"Transpiler\" is a useless word - 形式的に言えば「トランスパイラ」は無意味な言葉"
date: 2025-12-30T15:39:33.225Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://people.csail.mit.edu/rachit/post/transpiler-formal/"
source_title: "Formally speaking, \"Transpiler\" is a useless word"
source_id: 1470852083
excerpt: "トランスパイラの定義差がツール選定とバグを左右する理由を具体例で示す"
---

# Formally speaking, "Transpiler" is a useless word - 形式的に言えば「トランスパイラ」は無意味な言葉
トランスパイラは本当にコンパイラと違うのか？形式手法で切り分ける「JS発」用語の正体

## 要約
「transpiler（トランスパイラ）」という呼び名は曖昧で、文法（syntax）だけの変換を指すのか、意味（semantics）を保つ変換を指すのか、人によって違う。PL（プログラミング言語）研究の道具立てを使うと、少なくとも三つの定義が考えられ、どれを採るかで議論は変わる。

## この記事を読むべき理由
- 日本のフロントエンド／ライブラリ開発やレガシー互換対応で「Babel」「TypeScript」「transpile」という言葉は日常語。用語の違いを理解すると、ツール選定や互換性設計の判断がブレなくなる。
- 微妙な評価順（短絡評価）や副作用の違いでバグが発生する実例があり、現場で役立つ注意点がすぐに使える。

## 詳細解説
PLコミュニティは言語操作を厳密に考えるためのモデルをいくつか持っています。要点を整理します。

- 文法（Concrete syntax）:
  - 言語はBNFのような文法で生成される語（terms）の集合と見なせます。例えば言語$L$が文法$G$により生成されるなら
    $$L=\{t\mid t\in G\}$$
  - この視点からの「transpiler」は「構文変換器（syntax translator）」：ある言語の構文を別の言語の“自然な”構文に置き換えるツール。

- 意味（Operational semantics）:
  - 実行モデル（評価規則）を明確にすると、同じ見た目でも挙動が異なる変換を判別できます。例えば短絡評価（and の左辺が False のとき右辺を評価しない）と全評価は異なる意味を生みます。
  - 形式的な意味保存の定義は次のように表せます。
    $$\forall s\in S:\ s\Downarrow_s v \implies C(s)\Downarrow_t v$$
    これを満たす変換は意味を保存する（つまりコンパイラと同義に扱える）ため、「transpiler」と呼んでも「compiler」と同じクラスに入る。

- 単純さ（Syntactic sugar と局所変換）:
  - 実務で「トランスパイラ = 単純な書き換え」と考える人も多い。これを形式化するには「局所変換（local transformation）」という考えが有効。文脈に依存せず分解して書き換えられる特徴は「糖衣記法（syntactic sugar）」に相当します。
  - 局所変換は周囲の構造を参照せずに置換できるため、実装が容易で安全な場合が多い。一方で this や例外処理、評価順に依存する機能はグローバルな取扱いを要し、単純なトランスパイルでは破綻することがある。

実例（評価順の落とし穴）：
- 元のコード（Python風）では短絡評価により右辺が評価されないためエラーが出ない場合でも、単純に両辺を先に評価して変数に束縛する書き換えを行うと、None と int の比較などで例外が発生する可能性がある。これは「構文だけを書き換えた」変換が意味を壊す典型例です。

結論：
- 「transpiler」を厳密に定義するなら、文脈によって「構文変換器」「意味保存器（=コンパイラ）」「局所変換器（単純な糖衣除去）」のいずれかを指す。用語を使う際は、あなたが想定する“意味の保存”や“局所性”を明示することが重要。

## 実践ポイント
- ツールを選ぶ時は「この変換は意味（評価順・副作用）を保つか？」をチェックする。ドキュメントに「semantics-preserving」や「only syntax-level」など明記があるか確認。
- 短絡評価や副作用のある演算子を含むコードを変換する場合、単純な文字列置換／AST 局所置換だけでは不十分。テストカバレッジ（特に境界ケース）を充実させる。
- 新機能を古いランタイムへ落とす（Babel型）なら「局所変換」で済むことも多いが、this、例外、メタプログラミングなどはグローバルな対応が必要。既存の成熟したトランスパイラ／コンパイラを活用するのが現実的。
- 自作のトランスパイラを作るなら、意味保存を証明するか、少なくとも仕様に基づくテストスイートを必須にする。

