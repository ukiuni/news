---
layout: post
title: "A SOLID Load of Bull - SOLIDの大誤解"
date: 2025-12-31T10:40:14.132Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://loup-vaillant.fr/articles/solid-bull"
source_title: "A SOLID Load of Bull"
source_id: 475782344
excerpt: "SOLIDの過剰適用を暴き、LSPと実務的基準で無駄な抽象化を防ぐ方法"
---

# A SOLID Load of Bull - SOLIDの大誤解
SOLID神話をぶった斬る：本当に守るべき設計原則と現場での落としどころ

## 要約
SOLIDの5原則は広く知られているが、元記事はそのうち有意味なのはごく一部であり、残りは歴史的背景や誤解に基づく“過剰適用”だと指摘する。

## この記事を読むべき理由
SOLIDは日本のプロジェクトでも“お約束”として語られがちです。だが無批判に採用すると過剰な抽象化や保守性低下を招くことがある。実務での適用基準を整理することで、無駄な設計コストを減らし開発速度と品質を両立できます。

## 詳細解説
- リスコフの置換原理（LSP）  
  元記事はLSPを最も有益な原則として評価しています。要点は「派生型が基底型について成り立つ性質を壊さないこと」。型理論や関数型言語での“クラス法則（laws）”の議論にも通じ、振る舞いの不変性を設計で担保するとコンパイラや最適化が効く場合もある。現実的には、言語や型システムがLSPを強制しないため、仕様としての「振る舞い契約（behavioral contract）」を文書化・テストで補強するのが実務的。

- 開放/閉鎖原則（OCP）  
  本来の起源（Bertrand Meyer）は後方互換性の文脈で生まれ、過去の環境（生データ構造やアセンブリ）での互換破損リスクを避けるための考え方でした。一方でRobert C. Martin流の解釈は「ソースコードを触るな／抽象に依存せよ」と極端に受け取られがちで、結果として過度なインターフェイス分離や依存注入の乱用を招くことがあると批判されています。今日の言語・ツールチェイン（型チェック、リファクタリング、CI）を前提にすれば、すべてを触らないで済ますという方針は非現実的。現場では「破壊的変更は注意深く行うが、必要ならソースを変える」という判断が妥当です。

- 単一責任原則（SRP）  
  「クラスは変更理由を一つにすべき」というSRPは高凝集・低結合を目指す有用なヒューリスティックですが、何が“理由”かは文脈依存で曖昧になりやすい。機能を分離しすぎるとAPIが深くなり過ぎ、かえって使いにくくなる場合もあります。設計では「変更頻度」「影響範囲」「実装コスト」を勘案して分割の粒度を決めるべきです。

- 共通の問題点  
  元記事の筆者は、SOLIDを無批判に掲げると「設計の先送り」「過剰な抽象化」「テストが模擬（モック）ばかりになり本物を検証しない」など現場での負の結果を招くと警告しています。

## 実践ポイント
- LSPを守るなら、仕様レベルでの振る舞い契約を文書化し、ユニット／契約テストで検証する。単に型を合わせるだけでは不十分。
- OCPは「後方互換性を壊さないこと」として解釈し、変更はCI＋型チェック＋テストで安全に行う。開発前提が内部向けか外部向けかで方針を分ける。
- DI（依存注入）は「同一プロセス内で複数実装を切り替える必要がある」や「実装差で同時に振る舞いを使い分ける」場合に有効。単に将来の変更に備えて導入するのは過剰設計になりやすい。
- SRPの適用は「変更の観測値（誰がどれくらいの頻度で何を変えているか）」に基づくべき。ログやコミット履歴を見て分割の必要性を判断する。
- テスト戦略はモック中心に偏らない。統合テストやエンドツーエンドで実装同士の相互作用を検証する習慣を持とう。
- 日本の現場（レガシーコード、組み込み、保守強い文化）では「互換性重視」の側面が強いので、OCPの原点は一定の妥当性を持つ。ただし現代のツールを活かして堅実にリファクタする文化も同時に育てる。

## 引用元
- タイトル: A SOLID Load of Bull
- URL: https://loup-vaillant.fr/articles/solid-bull
