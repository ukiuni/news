---
layout: post
title: "How to Code Claude Code in 200 Lines of Code - 200行で作る「Claude Code」の作り方"
date: 2026-01-08T20:46:46.169Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.mihaileric.com/The-Emperor-Has-No-Clothes/"
source_title: "The Emperor Has No Clothes: How to Code Claude Code in 200 Lines of Code - Mihail Eric"
source_id: 46545620
excerpt: "約200行で動くAIコーディング助手の全構造と作り方を実例で解説"
image: "https://cdn.searchenginejournal.com/wp-content/uploads/2021/08/20-awesome-sources-of-free-data-612c26257336f-sej.jpg"
---

# How to Code Claude Code in 200 Lines of Code - 200行で作る「Claude Code」の作り方
驚愕：AIコードアシスタントは本当は「200行の仕組み」で動いている — 自分で作って学ぶ

## 要約
LLM（大規模言語モデル）を「会話＋ツール呼び出し」のループでラップすると、ファイル読み書き・一覧・編集の3つのツールだけで実用的なコーディングエージェントが作れる。元記事はこれを約200行のPythonで実装し、動くプロトタイプの全体像を示している。

## この記事を読むべき理由
- 実務で目にする「AIコード補助」は何をしているのか、内部構造を初心者にも分かりやすく理解できる。  
- 日本の開発現場や個人プロジェクトで、自前の軽量エージェントを試作・検証するためのロードマップが得られる。  
- 黑箱に見えるAIの振る舞いを制御（安全化・承認フローの追加）するための出発点になる。

## 詳細解説
1. メンタルモデル（本質）
- エージェントは「LLMとの会話」と「ローカルで動くツール群」のループ。ユーザーが指示を出すと、LLMが「ツール呼び出し（構造化された命令）」を返す。実際にファイル操作を行うのはローカルのコードで、結果をLLMに戻して続行する。この分離が重要（LLMが直接ファイルに触らない）。

2. 必要なツールはたったの3つ
- read_file：指定ファイルの中身を返す。  
- list_files：ディレクトリの一覧を返す（プロジェクトをナビゲートするため）。  
- edit_file：新規作成または文字列置換でファイルを編集する。  
これだけで「新ファイル作成」「既存編集」「多段の手順」が可能になる。

3. ツールの説明はドキュメント文字列（docstring）で与える
- LLMにどんなツールがあるか、引数や目的を説明して渡す。これによりモデルは自律的に「どのツールをいつ使うか」を判断する。

4. ツール呼び出しの約束事（プロトコル）
- LLMには「tool: TOOL_NAME({...})」の一行だけでツールを呼ぶルールを教える。実装側はその行をパースしてツールを実行し、結果を "tool_result({...})" として会話に戻す。例：
```python
# python
# LLMが出す想定フォーマット
tool: edit_file({"path":"hello.py","old_str":"","new_str":"print('Hello World')"})
```

5. エージェントループ
- 外側ループ：ユーザー入力を会話に追加、内側ループへ。  
- 内側ループ：LLM呼び出し → ツール呼び出し要求の有無を判定 → 要求あれば実行して結果を会話に戻す → ツール呼び出しがなくなるまで繰り返す。  
この構造でLLMは複数ステップ（ファイルを読む→編集する→確認する等）を連鎖的に行える。

6. 実運用との差分
- 元実装はシンプルだが、本番にはエラーハンドリング、破壊的操作の承認ワークフロー、レスポンスのストリーミング、検索・コマンド実行など追加機能が必要。

## 実践ポイント
- まずはローカル環境で小さなリポジトリに対して動かしてみる。APIキーは環境変数で管理し、編集前にバックアップを取る。  
- VS Codeとの親和性：このパターンは拡張機能として組み込みやすい（エディタからの指示で会話を開始し、結果をアクティブドキュメントに反映）。  
- セキュリティ・運用：自動でコードを上書きする前に「差分確認」「ユーザー承認」を入れること。外部コマンド実行ツールを追加する場合はサンドボックス化を検討する。  
- 改良案（短期で試せる）：
  - ファイル長が長いときは要約ツールを追加してコンテキストを節約する。  
  - grep / shell ツールを追加してリポジトリ横断の検索やビルド実行を可能にする。  
  - edit_fileに「位置指定」や「複数候補のマージ」などのフォールバックを実装する。  
- ビジネス視点：社内コードレビューや自動修正のプロトタイプとして試し、承認フローやログを整備すれば実務導入の価値が出る。

元記事は「複雑そうに見える機能のコアは非常に単純だ」と示している。まずはその単純なループを自分の手で動かし、用途に応じて安全性・UX・ツール群を足していくのが現実的な進め方になる。
