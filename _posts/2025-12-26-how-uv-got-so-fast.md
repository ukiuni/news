---
layout: post
title: How uv got so fast
date: 2025-12-26 19:30:15.321000+00:00
categories:
- tech
- world-news
tags:
- tech-news
- japan
source_url: https://nesbitt.io/2025/12/26/how-uv-got-so-fast.html
source_title: How uv got so fast | Andrew Nesbitt
source_id: 1324045140
excerpt: pyprojectやPEP群×メタデータ・HTTPレンジでuvが桁違いに高速化
---
# なぜ uv は pip より桁違いに速いのか — Rust だけでは説明できない設計の勝利

## 要約
uv の高速化は「Rustで書かれているから」だけではなく、Pythonパッケージングの標準整備（pyproject/PEP群）と「やらないことを明確にする」設計、そしてプロトコル上の最適化の組合せによるもの。

## この記事を読むべき理由
日本のエンジニアにとって、ローカル開発やCIの待ち時間短縮、社内パッケージレジストリ運用の効率化は生産性に直結する。uvの設計を理解すれば、自分たちで速く安全にパッケージ供給するための具体的施策が見えてくる。

## 詳細解説
- 背景（標準の変化が鍵）
  - かつては setup.py の実行が依存関係検出に必須で、pip は「ダウンロード→実行→失敗→依存追加→再試行」を繰り返しがちだった。
  - PEP 518（pyproject.toml, 2016）でビルド依存を宣言可能に、PEP 517（ビルドフロントエンド/バックエンド分離, 2017）、PEP 621（[project]表の標準化, 2020）、PEP 658（Simple APIへメタデータ追加, 2022）と段階的に整備され、2023年のPyPI導入で「メタデータだけで依存が分かる」環境が整った。
  - uv（2024年公開）はこのタイミングの恩恵を受けており、同様のツールはPEP群が無かった時代には実現困難だった。

- uv が「やめたこと（削減したコードパス）」
  - .egg をサポートしない（古いバイナリ形式の切捨て）。
  - pip の設定ファイル（pip.conf）や環境変数を無視 → 設定読み取り・継承ロジック削減。
  - デフォルトで .pyc 生成を省略 → インストール時間短縮（任意で有効化可）。
  - システムPythonへの直接インストールを禁止 → 権限確認や安全対処のコード削減。
  - 規格違反のパッケージを厳格に拒否 → 例外処理・フォールバックを減らす。
  - requires-python の上限（例: <4.0）を無視して下限のみ評価 → リゾルバのバックトラック削減。
  - 複数インデクス時は「先頭のインデックスで見つけたものを採用」 → 余分なネットワークリクエストを回避。

  これらの「しない」選択が、余計な処理・待ち時間を消している。

- Rust以外の最適化（実装言語とは独立した改善）
  - PEP 658 のメタデータを最初に使う設計により、ホイール本体をダウンロードせず依存解決できるケースが大半。
  - HTTPレンジリクエストでZIPのセントラルディレクトリ（ファイルリスト）だけ取得する手法：ホイール全体を落とさずに中身を確認できる（プロトコル面の最適化で、言語差は関係ない）。
  - 速いパスを99%カバーするような「段階的フォールバック」設計（メタデータ→レンジ→フルダウン→ソースビルド）により平均レイテンシを大幅削減。

## 実践ポイント
- パッケージ作成者 / メンテナ向け
  - pyproject.toml を正しく整備して [project] に依存を明示する（PEP 621）。これだけでユーザー側のインストールが速くなる。
  - ビルドメタデータをきちんと生成・公開する（PEP 658 に親和的にする）。
  - 不必要な requires-python の上限指定は避ける。実際の互換性に基づく下限だけを書く。

- 運用 / CI / 企業環境向け
  - uv を試験導入して、レイテンシやCIのビルド時間を計測する（キャッシュ運用と併せると効果大）。
  - プライベートインデックスやミラーを「最初のインデックス」に設定し、uvのfirst-index挙動を活かす。Artifactory/Nexus/Devpiなどでメタデータ対応を確認する。
  - サーバ側でHTTPレンジリクエストを正しくサポートし、帯域・遅延の低減を図る（特に大規模ミラー運用時）。
  - レガシーパッケージが多い組織では、uv の厳格な仕様チェックに引っかかるケースを事前に洗い出し、pyproject化や修正計画を立てる。

