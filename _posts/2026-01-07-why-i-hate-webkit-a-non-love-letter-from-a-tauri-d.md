---
  layout: post
  title: "Why I hate WebKit: A (non) love letter - なぜ私はWebKitが嫌いか（非ラブレター）"
  date: 2026-01-07T16:21:43.043Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://gethopp.app/blog/hate-webkit"
  source_title: "Why I hate WebKit, a (non) love letter"
  source_id: 468785033
  excerpt: "**Tauri開発者が明かす、WebKitが低遅延画面共有と音声を壊す理由と回避策**"
  image: "https://dlh49gjxx49i3.cloudfront.net/hate-webkit/featured.jpg"
---

# Why I hate WebKit: A (non) love letter - なぜ私はWebKitが嫌いか（非ラブレター）
Safariに泣かされた開発者の告白：WebKitがリアルタイム画面共有アプリを苦しめる理由と現実的な回避策

## 要約
リアルタイム画面共有アプリを作る中で、WebKit（特にiOS/Safari系）が描画・音声・コーデック・WebRTC周りで頻繁に問題を起こし、結果として一部のウィンドウをRustネイティブへ移行する判断をしたという体験記。

## この記事を読むべき理由
日本でもmacOS/iOS利用者が多く、App StoreルールのためiOSではWebKit派生エンジンが必須になる。ブラウザ依存の不具合はプロダクトのUXを大きく損なうため、特に低遅延な画面共有やWebRTCを使う開発者は知っておいたほうが良い。

## 詳細解説
- SVGフィルタの描画ブレやぼやけ：WebKitはSVGのフィルタやシャドウを正確にレンダリングしないことが多く、デザイナーからFigmaで渡される多層フィルタが崩れる。結果としてデザイン妥協やフィルタ削除が発生。
- iOSでの原因不明クラッシュ：特定のページ構成（例：複数GIF）で数秒後に「A problem repeatedly occurred」と表示され、コンソールに痕跡が出ないケースがある。デバッグが難しいためIntersectionObserverを使った遅延レンダリングで回避した。
- ユーザーエージェントの古いエンジン表記：Tauri上のWebKitが常に古いエンジン番号（例: 605.1.15）を返し、機能判定（Krisp／ノイズキャンセル等）が誤動作する。結果としてライブラリ側にパッチを当てて無理やり動かす必要があった。
- 音声周りのグリッチ：マイク列挙時に音が途切れる、マイクを開くと他のオーディオが小さくなる（オーディオダッキング）など。意図的仕様かバグか不明でUXに影響。
- コーデック対応差：AV1はハードデコーダ有無に依存するWebKitと、ソフトフォールバックを持つChromium系とで扱いが異なる。参加者の環境差でストリームの互換性問題が出る。
- WebKitGTKのWebRTCサポート欠如：Linux向けのWebRTCがデフォルトビルドで無効なため、配布ビルドでLinuxサポートがブロックされる。カスタムビルドで対応可能だが運用コスト増。
- 結論的対応：Tauri（WebKit）→Electronへの全面移行はコスト/設計の問題があり、代替として一部ウィンドウをRustネイティブ（iced）で実装。WebRTCをバックエンド中心にしてブラウザ依存を減らす設計にシフト。これにより参加者を1つにまとめられ、コーデック選択やバッファへのアクセスで機能拡張（例：Apple Neural Engineによるアップスケール）も可能になる。

## 実践ポイント
- 開発・検証
  - Safari／iOSでの挙動を早期にテストして差異を洗い出す。特にSVGフィルタ、GIF、音声フローをチェック。
  - 目に見えないクラッシュや沈黙のエラーに備え、ユーザーフロー単位でのSentry等の監視を強化する。
- 回避策
  - 重いSVGフィルタは可能ならプレレンダ画像やCSS効果へ置き換える。
  - 大きなアニメやGIFはIntersectionObserverなどで遅延ロードする。
  - 機能判定はユーザーエージェント依存だけにせず、実際の機能テスト（feature probe）でフォールバックを用意する（EAFP: try-and-handle）。
- アーキテクチャ的選択
  - 本格的な低遅延WebRTCアプリは、ブラウザ側だけで完結させると制約が厳しい。可能であればWebRTC処理をバックエンド（Rust等）に寄せる設計を検討する。
  - Linuxサポートが必須ならWebKitGTKのカスタムビルドや、CEF/Electron、あるいはネイティブ実装の検討を早めに行う。
- 将来的な見通し
  - AV1等のコーデック対応は端末依存が強いので、ハード/ソフト双方のフォールバック戦略を用意する。

以上を踏まえ、WebKitは「使えない」わけではないが、用途次第で重大なコストになる。特に低遅延画面共有や複雑なメディア処理を伴うアプリでは、早期に実運用での検証とアーキテクチャ上の逃げ道（ネイティブ化やバックエンド移行）を設計しておくことを勧める。
