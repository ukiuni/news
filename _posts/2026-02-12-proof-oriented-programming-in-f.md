---
layout: post
title: "Proof-oriented Programming in F* - F* における証明志向プログラミング"
date: 2026-02-12T10:10:55.836Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://fstar-lang.org/tutorial"
source_title: "F* Tutorial"
source_id: 1331399393
excerpt: "F*で実行コードと機械証明を同一ソースで作り安全性を保証する実践入門"
---

# Proof-oriented Programming in F* - F* における証明志向プログラミング
F*で「コードと証明を同時に書く」――実践で使える形式手法の入口

## 要約
F*は型に仕様を書き込み、SMTソルバを使ってプログラムの性質を自動検証できる関数型言語です。実行可能なコードと機械証明を同じソースで扱えるのが特徴です。

## この記事を読むべき理由
セキュリティや信頼性が求められるソフトウェア（組込、IoT、金融、暗号実装など）で「実際に動くかつ証明された」コードが必要な場面が増えています。F*はそのための実践的な道具になり得るため、日本のエンジニアが知っておく価値があります。

## 詳細解説
- 基本概念：F*は関数型＋依存型／精密化型（refinement types）を持ち、型自体に前提・事後条件や不変量を書けます。型が仕様そのものになり、型チェック時に仕様達成が検証されます。
- 自動証明：F*はZ3などのSMTソルバと連携して多くの性質を自動で証明します。必要なときだけ補助的に補題（手動の証明）を書きます。
- 実行と証明の分離：証明にのみ使うコード（ghost）は実行時に消えるため、証明のためのオーバーヘッドが実行性能に影響しません。同じソースから安全に実行コードを抽出できます。
- 効果と全域性：副作用を持つコードと全関数（total）を区別する効果システムにより、純粋性や終了性（termination）も明示的に扱えます。
- 抽出と実運用：検証済みのF*コードはOCaml/F#へ抽出したり、KreMLin経由で読みやすいCコードに変換して組込や既存のエコシステムへ組み込めます。これにより実運用への移行が実務的に可能です。
- 適用例：暗号ライブラリの検証、プロトコル安全性、低レイヤのメモリ安全保証など、実務での利用実績が増えています。

## 実践ポイント
- まずは公式チュートリアルを動かす：Z3のインストールとF*本体を準備し、チュートリアルの最初の例（単純な関数と仕様）を試してください。
- 小さく始める：小さな関数に対して前条件／後条件を追加して検証フローを理解する。失敗したらSMT出力を読み、補題を追加する練習を繰り返す。
- 実行コードを作る：ghostコードで証明を書き、実行に必要な部分は抽出してパフォーマンスや互換性を確認する（OCaml/KreMLin→C）。
- CIに組み込む：テストだけでなくF*の検証をCIに入れることで仕様違反の早期発見を実現する。
- 日本市場での活用：組込・自動車・金融・暗号に関わるプロジェクトで有効。安全性やコンプライアンスの要件が厳しい案件で導入を検討すると効果が出ます。

まずはチュートリアルを動かして「証明が書ける感触」をつかんでみてください。
