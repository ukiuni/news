---
layout: post
title: "Stackmaxxing for a recursion world record - 再帰の世界記録を狙うスタック最大化"
date: 2026-01-25T05:13:56.405Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.youtube.com/watch?v=WQKSyPYF0-Y"
source_title: "Stackmaxxing for a recursion world record - YouTube"
source_id: 419399573
excerpt: "OS／コンパイラ／コード別手法で再帰深度を数千万に伸ばす極限スタック最適化術"
image: "https://i.ytimg.com/vi/WQKSyPYF0-Y/maxresdefault.jpg"
---

# Stackmaxxing for a recursion world record - 再帰の世界記録を狙うスタック最大化
限界まで浅いスタックフレームを作って、再帰深度の世界記録に挑むテクニック集

## 要約
動画は「再帰で到達可能な最大深度」を伸ばすために、OS／コンパイラ／コードレベルでスタック使用量を極限まで削る手法を紹介しています。実験的な最適化で数百万〜数千万レベルの深さを達成することが狙いです。

## この記事を読むべき理由
再帰の限界理解は、スタックオーバーフロー回避や組み込み／サーバレス環境での信頼性設計に直結します。日本の開発現場でも深い再帰を扱う解析器や再帰的アルゴリズムは存在するため、現実的な回避策や最適化手法を知っておく価値があります。

## 詳細解説
- スタックと再帰の基本：関数呼び出しごとにスタックに戻りアドレスやレジスタ・局所変数が積まれるため、「フレームサイズ × 深さ」が決定因。スタック領域はOSやスレッド属性で制限される（例: Unix の ulimit/setrlimit）。
- フレームを小さくする技術：
  - 局所変数を使わない／大きな配列はヒープへ移す（malloc/new）。
  - コンパイラ最適化：-O2/-O3、tail-call最適化（末尾再帰）を誘発する書き方。
  - フレームポインタ削減：-fomit-frame-pointer（環境依存でデバッグ困難）。
  - スタックプロテクタ無効化：-fno-stack-protector（セキュリティ trade-off）。
  - ネイティブアセンブリでプロローグ/エピローグを最小化（__attribute__((naked)) 等）。
- スタックサイズを増やす方法：
  - プロセス単位：ulimit -s / setrlimit(RLIMIT_STACK) で増やす（OSの上限に注意）。
  - スレッド：pthread_attr_setstacksize でスレッド用スタック確保。
  - メモリマッピング：大きなメモリ領域を確保し、実験的に「別の領域をスタックとして使う」手法（危険、非移植）。
- 代替アプローチ：
  - トランポリン（ループで擬似的に関数を呼び替える）や手動ヒープスタックを使うことで深さ無制限に近づける。
  - 分割統治や反復化でそもそも再帰深度を減らす。
- 実験の意義：規格外の最適化はコンパイラ・OSの実装境界を露呈し、バグや未定義動作も発見しやすい点に注意。

## 実践ポイント
- まずは再帰を使う理由を見直す（反復化で十分なら避ける）。
- 開発環境で試すコマンド（Unix例）：
```bash
# スタックサイズ確認・設定（KB）
ulimit -s
ulimit -s 65536
```
- コンパイル時のチェックポイント：-O2/-O3 を使い、末尾再帰に書き換え可能なら書き換える。大きな局所変数は必ずヒープへ。
- マルチスレッドで深い再帰が必要なら pthread_attr_setstacksize で十分なスタックを割り当てる。
- セキュリティ面に留意：-fno-stack-protector やプロセススタックの人為的操作は脆弱性を招く可能性があるため実験目的以外では避ける。
- 日本の組込み／クラウド環境ではデフォルト制限が厳しい場合が多く、設計段階でスタック利用を把握しておくこと。

動画は「どこまで限界を伸ばせるか」というチャレンジ的側面が強い一方で、実務に直結するスタック管理や安全な代替手法の学びが多いので、実験的知見を安全に持ち帰るのが得策です。
