---
layout: post
title: "How to store a chess position in 26 bytes - チェスの局面を26バイトで保存する方法"
date: 2026-01-09T18:54:49.569Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://ezzeriesa.notion.site/How-to-store-a-chess-position-in-26-bytes-using-bit-level-magic-df1fdb5364eb42fdac11eb23b25e9605"
source_title: "Notion"
source_id: 46554652
excerpt: "チェス局面を26バイトに圧縮する具体手法（組合せ番号とビットパック）と実装例"
image: "https://www.notion.so/images/meta/default.png"
---

# How to store a chess position in 26 bytes - チェスの局面を26バイトで保存する方法
チェス局面をわずか26バイトに詰め込む――ビット単位の工夫で可能にする実践テクニック

## 要約
局面（駒配置＋手番＋キャスリング権＋アンパッサンなど）を、駒集合を組合せの指数化（combination ranking）でエンコードし、残りの情報をビットパックすることで合計26バイト（208ビット）に収める方法を解説します。

## この記事を読むべき理由
FENなどのテキスト形式は可読だが冗長で、データ転送・保存・キャッシュのコストが無視できない場面があります。特にモバイルやネットワークで大量の局面を扱うサービスや、探索やデータベースの軽量化を狙うエンジニアにとって、有益な圧縮手法です。日本のチェス系アプリや棋譜集、あるいは類似のボードゲーム（将棋等）のデータ圧縮設計にも応用できます。

## 詳細解説
基本アイデアは「64マス上の駒の配置を単純に1マスごとに記録する」のではなく、「各駒種が占めるマス集合」を順に記述し、その集合を順序付けた組合せ番号（combination rank）として格納することです。

- 駒種は12種類（白黒各6種）。例えば白ポーン8個がどの64マスにいるかは $\binom{64}{8}$ 通りあり、この中の一つを番号で表せば十分です。
- 重要な点は、駒種ごとに「残っている未割当のマス数」を順に更新していくこと。最初は64マス、白ポーンの次は残り56〜といった具合にnが減っていくため、必要なビット数が小さく抑えられます。
- 必要ビット数は各集合について $$\lceil \log_2 \binom{n}{k} \rceil$$ の総和で表せます。これに手番（1ビット）、キャスリング権（最大4ビット）、アンパッサン（発生可能性は限定的なので最大6ビット程度）、ハーフムーブカウンタなどを足して合計が208ビット以内に収まるように設計されます。
- 実装面では、大きな整数でビット列を扱う（BigInt等）か、バイト配列に対するビット書込処理を行い、エンコード／デコードで組合せのランキングとアンランキング（順序付けられた組合せの数値 ↔ マス集合）を正確に実装します。

利点とトレードオフ：
- 長所：保存サイズが大幅に小さくなる、固定長（26バイト）にできるため索引やネット転送で扱いやすい。
- 短所：エンコード／デコードの実装がやや複雑（組合せ関数の高速計算やビット操作が必要）、実行コストがテキストパースより高い場合がある。

## 実践ポイント
- まずはFENをパースして駒のカウントと位置配列を作る。次に駒種ごとに「残りマス数 n」と「その駒の個数 k」を決め、組合せランキングで番号化する。
- 組合せランキングはライブラリ（Python の math.comb、C++ の boost::multiprecision、JavaScript の BigInt）を使うと実装が楽。大きな組合せ値を扱うので任意精度整数が必要。
- ビットパッキングの順序を定め（例：白P, 白N, 白B, 白R, 白Q, 白K, 黒P, ...）、双方で同じ順序を使うこと。エッジケース（プロモーションで増えた駒など）を要検討。
- テストは必須。FEN→26バイト→FENのラウンドトリップで全て一致するかを多数ケースで検証する。
- 応用例：チェスサーバーの局面キャッシュ、対局ログの圧縮保存、モバイルアプリでの局面ブック（opening book）格納。将棋などマス数や駒種類が違うゲームでは、同様の組合せ指標化が使えるが設計値（バイト数）は再計算が必要。

参考的な擬似コード（流れ）
```javascript
// javascript
// 1) parse FEN -> pieceLists
// 2) for each pieceType in order:
//    rank = combinationRank(availableSquares, squaresOfThisType)
//    writeBits(bitBuffer, rank, bitsNeededForThisCombination)
// 3) write side-to-move, castling, ep, halfmove
// roundtrip by reading bits and unranking combinations back to squares
```

短時間で導入するなら、まずは既存のFENを圧縮して送受信するプロトコルで試し、速度と圧縮率のバランスを確認してください。日本のサービスでもネット帯域やストレージ節約に直結するため、実用的な価値は高い手法です。
