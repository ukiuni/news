---
layout: post
title: "Code injections through Git commit messages - Gitコミットメッセージによるコード注入"
date: 2026-02-09T04:39:28.482Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://mas.to/@zekjur/116022397626943871"
source_title: "Michael Stapelberg 🐧🐹😺: &quot;PSA: Did you know that it’s **unsafe** to put cod…&quot; - mas.to"
source_id: 1276552236
excerpt: "何気ないコミットメッセージがCIやWebで評価され、コマンド実行やXSS被害を招く危険と対策"
---

# Code injections through Git commit messages - Gitコミットメッセージによるコード注入
危険は「コメント」にも潜む — Gitコミットメッセージで起きるコード注入の落とし穴

## 要約
コミットメッセージは単なるテキストに見えて、CI/CDパイプラインやフック、ウェブUIで不適切に扱うとコマンド実行やXSSにつながる危険がある。

## この記事を読むべき理由
日本でもGitHub ActionsやGitLab CI、社内の自動デプロイやチャット連携を使うケースが増えています。何気ないコミットメッセージが攻撃経路になり得ることを知っておけば、自社の開発フローを守れます。

## 詳細解説
- 攻撃パターン
  - シェル注入：コミットメッセージをそのままシェルコマンドに埋め込んで eval したり、無防備に展開すると `$(rm -rf /)` や `` `malicious` `` が実行される可能性がある。
  - CI/デプロイスクリプト：CIのジョブで `git log --pretty=%B` 等で取得した文字列を引数やコマンドとして扱うと危険。
  - ウェブ側（XSS）：リポジトリブラウザやマージリクエストの表示でHTMLやスクリプトがエスケープされていないと、閲覧者のブラウザ上で任意スクリプトが走る。
- なぜ起きるか
  - 「コミットメッセージ＝信頼できる文字列」と誤認している自動化処理が多いため。
  - サニタイズや適切なエスケープを行わずに文字列を評価・レンダリングしているため。
- 具体的な脆弱箇所
  - ローカル/サーバーのGitフック（post-receive, update等）
  - CIスクリプト（run:、script:でそのまま埋めるケース）
  - Web UIやチャット連携のレンダラー

## 実践ポイント
- コード例（危険な例／安全な例）
```bash
# bash - 危険な扱い（コミットメッセージを直接eval）
COMMIT_MSG="$(git log -1 --pretty=%B)"
eval "deploy $COMMIT_MSG"   # 危険！
```

```bash
# bash - 安全な扱い（引数として扱い、エスケープ／サニタイズ）
COMMIT_MSG="$(git log -1 --pretty=%B)"
# 例: 引数に直接渡す、安全ならば明示的にクオートする
deploy --message="$COMMIT_MSG"
# さらに必要ならメッセージを検査・正規化する
```

- 推奨対策（チェックリスト）
  - 絶対に eval や類似の動的評価を使わない。文字列は引数／データとして扱う。
  - CIやスクリプトで外部入力は常にクオート・エスケープする（printf '%q' などを検討）。
  - ウェブ側はコミットメッセージを HTML エスケープして表示、必要ならサニタイズライブラリを導入。
  - フックや自動化は最小権限で実行し、ログや監査を有効にする。
  - 社内に対して「コミットメッセージを含む自動処理は危険性がある」と教育する。
  - 可能なら署名付きコミットや受け入れポリシーで未承認のメッセージを弾く。

日本の企業でも取り入れているCI/CDやチャット連携は攻撃面が広いため、上の実践ポイントを組み込めばリスクを大幅に下げられます。
