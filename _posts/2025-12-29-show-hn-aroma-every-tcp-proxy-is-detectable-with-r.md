---
layout: post
title: Show HN: Aroma: Every TCP Proxy Is Detectable with RTT Fingerprinting - Show HN: Aroma：すべてのTCPプロキシはRTTフィンガープリンティングで検出可能
date: 2025-12-29T20:30:26.496Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://github.com/Sakura-sx/Aroma"
source_title: "GitHub - Sakura-sx/Aroma: Every TCP Proxy Is Detectable With RTT Fingerprinting"
source_id: 46386878
excerpt: "TCPの最小RTT比でL4プロキシを高精度検出する実用手法で隠れ中継を暴く"
---

# Show HN: Aroma: Every TCP Proxy Is Detectable with RTT Fingerprinting - Show HN: Aroma：すべてのTCPプロキシはRTTフィンガープリンティングで検出可能

## 要約
TCPソケットが報告する最小RTTと平滑化されたRTTの比率を使えば、TCPプロキシ（L4プロキシ）を高い確度で検出できる、という実証的なプロトタイプの解説。

## この記事を読むべき理由
企業の不正アクセス対策、オンラインサービスの不正利用対策、あるいはプライバシー観点から「ユーザが本当にどの経路を通っているか」を推定したい日本の技術者やプロダクト担当にとって、ネットワーク時刻情報だけでプロキシの存在を推定する手法は即戦力になるから。

## 詳細解説
- 基本アイデア  
  TCPスタックが持つ統計情報のうち、Linuxの struct tcp_info から得られる tcpi_min_rtt（観測された最小RTT）と tcpi_rtt（平滑化されたRTT）を比較する。プロキシが介在すると、プロキシ・エンドから見たL3/L4のRTTと、アプリケーション層（TLS/HTTP）で観測されるRTTにズレが生じる。これを比率で表すとプロキシの存在を示す指標になる。

- スコアリング式（シンプル）  
  $$\text{score}=\frac{\text{tcpi\_min\_rtt}}{\text{tcpi\_rtt}}$$  
  比率が1に近ければ「プロキシ無しに近い」、小さくなるほどL4プロキシである可能性が高い、という直感。

- 実証環境と制約  
  Fastlyのようなエッジサービスが公開するカスタムVCL経由で tcpi フィールドを取得し、各リクエストに対してスコアを算出するプロトタイプが示されている。重要な制約は次の通り：
  - 現状はTCPプロキシ（Layer 4）に特化。Layer 3のVPN等は検出できない場合が多い。  
  - 閾値は実験的で、誤検出（偽陽性）を避けるため低めに設定されている。  
  - エッジ側でRTTが取得できる環境が必須（すべてのCDNやミドルボックスが対応するわけではない）。

- 物理的な裏付け  
  RTTは伝播遅延の下限を与える。例えば往復遅延が4msなら、情報が光速を超えられないことから片道2光ミリ秒、距離に換算すると概ね600km（光ファイバなら更に遅く、実効的には~400km以下）という上限推定ができる。つまりRTTは地理的な「ありえない遠さ」を排除する根拠にもなる。

- なぜ高層プロトコルのRTTが上がるか  
  TCPプロキシはクライアント--プロキシ間とプロキシ--サーバ間でTCP接続を分割するため、アプリ層の操作（TLSハンドシェイクやHTTPリダイレクトの追跡）で観測される遅延はクライアント側のTCP RTTと乖離する。これが指標として機能する理由である。

## 実践ポイント
- まず小さなPoCを回す  
  CDNやエッジが tcpi 相当の値を露出しているかを確認し、サンプル収集から開始する。scoreの分布を各PoP・各端末種別（モバイル、Wi‑Fi等）で集め、ベースラインを作ることが重要。

- しきい値運用の注意  
  実装例では以下の目安が示されている（あくまで実験値）。
  - $0.7 \sim 1$: 正常な接続  
  - $0.3 \sim 0.7$: 不安定（Wi‑Fiやモバイルなど）  
  - $0.1 \sim 0.3$: プロキシ疑いあり  
  - $<0.1$: TCPプロキシと判定（現在のコードでは検出と扱う）  
  ただし国やネットワーク特性により分布は変わるため、ローカルで再調整すること。

- 実装ヒント（簡易）  
  ・Fastly等でCustom VCLを使えるなら、エッジでtcpiを読み取りスコア化するのが再現性が高い。  
  ・ソースにはVCLテンプレートとビルド用スクリプトがあり、テンプレートを編集してアップロードするワークフローが想定されている（プロダクション運用前にセキュリティ／誤検出対策を施すこと）。  
  簡単な比率計算（例）:

  ```python
  # python
  tcpi_min_rtt = 5.0   # ms
  tcpi_rtt = 50.0      # ms
  score = tcpi_min_rtt / tcpi_rtt
  print(score)  # 0.1 -> 要注意
  ```

- 法務・プライバシー上の配慮  
  ネットワーク指標を使った判定は利用者のプライバシーや地域の規制に関わる可能性がある。運用前に法務と相談し、誤検出時の対応（ソフトブロックからチャレンジにする等）を設計しておくこと。

- 拡張案  
  IPインテリジェンスやTLS指紋、HTTPヘッダ挙動など他の信号と組み合わせることで検出精度を上げられる。さらにこの考え方はTCPに限らず、UDPや他プロトコルのタイミング分析にも応用可能。

関連記事や実装例への直接リンクは本文には載せないが、プロトタイプは「エッジでのTCPソケット統計を使う」シンプルな着想で再現しやすい。まずは自社のエッジ環境でtcpiデータの取得可否を確認し、収集した分布に基づいて閾値を調整するところから始めるとよい。
