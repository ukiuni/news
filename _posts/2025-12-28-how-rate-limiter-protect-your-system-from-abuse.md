---
layout: post
title: How Rate Limiter protect your system from abuse!
date: 2025-12-28 15:15:25.916000+00:00
categories:
- tech
- world-news
tags:
- tech-news
- japan
source_url: https://sushantdhiman.substack.com/p/how-rate-limiter-protect-your-system
source_title: 'How Rate Limiter protect your system from abuse! EP: 3 Behind The Screen'
source_id: 436113700
excerpt: SMS/OTPコストや過負荷を防ぐ、実践的レートリミッタ設計指南
---
# APIを守る最前線：レートリミッタが不正利用とコストを同時に止める理由

## 要約
レートリミッタはサービスへの過剰アクセスやコスト高騰を防ぐための最前線の仕組みで、アルゴリズム選定と適切な設計で「正当な利用を阻害せずに悪用だけを防ぐ」ことができる。

## この記事を読むべき理由
日本ではSMS/OTPコストや大規模なモバイルトラフィックを抱えるサービスが多く、誤ったリミッティングはユーザー体験や運用コストに直結する。基本アルゴリズムと実運用での落とし穴を知っておけば、短時間で実践的な改善が可能になる。

## 詳細解説
- レートリミッタとは  
  クライアント（IP／ユーザー／APIキー等）が一定期間にどれだけリクエストできるかを制御するバックエンドの仕組み。超過時はHTTP 429等で拒否し、サービスの過負荷や課金コストの増大、悪用（ブルートフォースやスクレイピング）を防ぐ。

- 基本的な考え方  
  1) どのスコープで制御するか（グローバル／ユーザー／エンドポイント／IP）  
  2) 許容量（例：60req/分）と期間の定義  
  3) 許容量の監視・保存方法（メモリ、Redisなど外部ストア）  
  4) クライアントへの指示（Retry-Afterヘッダ、明確なエラーメッセージ）

- 代表的なアルゴリズム（特徴と実務上の注意点）
  1) Token Bucket  
     - 概要：バケットにトークンを補充し、リクエストごとにトークンを消費。バーストを許容する設計に向く。  
     - 長所：バーストに寛容で、スムーズなレート制御が可能。  
     - 短所：各キーごとにトークン数・最終補充時刻を管理する必要があり、ユーザ数が多いとストレージ／更新負荷が大きくなる。短時間で大量アクセスされる「補充直後バースト」の緩和が難しい場合がある。  
     - 実運用：RedisのINCR/TTLやLuaスクリプトで原子操作を行うことが多い。

  2) Fixed Window  
     - 概要：時刻を固定幅ウィンドウ（例：1分）に分け、ウィンドウ内のリクエスト数をカウント。  
     - 長所：実装が簡単でストレージ負荷が小さい。スケールしやすい。  
     - 短所：ウィンドウの端境でバーストが発生しやすい（窓の終わり→次の窓の開始で連続して上限分攻撃可能）。  
     - 実運用：単純なAPIや管理工数を抑えたいケース向け。特に低コストで良い。

  3) Sliding Window  
     - 概要：直近T秒間にNリクエストを超えていないかを常時チェックする方式。正確性が高く、窓境バーストを防ぐ。  
     - 長所：滑らかな制御でユーザー体験を崩しにくい。  
     - 短所：正確な実装（ログ保存や時刻ごとのカウント）がコスト高。近似実装（サブウィンドウに分割して合算する等）で妥協することが多い。  
     - 実運用：高精度に制御したい重要APIに適用。Redisのソートセットでタイムスタンプログを保持する実装が一般的だが、ストレージ増大に注意。

- 分散環境での課題  
  - 複数ノードでの一貫性（同期）。Redis等の中央ストアでカウントを集中させるか、ローカルレートリミット＋トークン共有でスケールさせるかを選定。  
  - レイテンシと可用性：中央ストア障害時のフェイルオーバ方針（フォールバックで緩和するか、拒否するか）を決めておく。

## 実践ポイント
- スコーピングを明確化する：OTP送信は「ユーザー単位＋電話番号単位」、公開APIは「IP＋APIキー単位」など。  
- アルゴリズム選びの目安：  
  - 単純な制限で十分 → Fixed Window  
  - バーストを許容したい → Token Bucket  
  - 窓の端での不正バーストを防ぎたい → Sliding Window（近似可）  
- 実装のヒント：RedisでINCR/EXPIREやLua原子処理を使う。高トラフィックではキーのシャーディングやTTLで古いキーを掃除する。  
- クライアントUXを考える：429の際にRetry-Afterを付け、失敗の理由を説明する。クライアント側に指数バックオフを促す。  
- モニタリングとアラート：レート制御ヒット率、拒否率、異常な短時間バーストの検出ルールを設ける。  
- テストする：負荷テストで窓端や補充直後の挙動を検証する。運用中は本番トラフィックの一部でカナリア運用する。

