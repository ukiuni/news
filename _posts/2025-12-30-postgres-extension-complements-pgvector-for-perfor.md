---
layout: post
title: "Postgres extension complements pgvector for performance and scale - Postgres拡張がpgvectorを補完し性能とスケールを実現"
date: 2025-12-30T15:38:06.814Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://github.com/timescale/pgvectorscale"
source_title: "Postgres extension complements pgvector for performance and scale"
source_id: 46379765
excerpt: "pgvectorscaleでPostgres内に低コストかつPinecone並の高速な大規模ベクトル検索を実現"
---

# Postgres extension complements pgvector for performance and scale - Postgres拡張がpgvectorを補完し性能とスケールを実現
pgvectorの「その先」へ――Postgres上で高速・低コストなベクトル検索を実現するTimescaleのpgvectorscale

## 要約
Timescaleのpgvectorscaleは、pgvectorを補完するPostgres拡張で、DiskANN由来のストリーミングディスクインデックス、独自の統計的2値量子化、ラベルベースの高速フィルタなどを導入し、自己ホスティング環境で高スループット・低レイテンシを実現します。

## この記事を読むべき理由
- 日本ではデータ主権やコスト重視で「自社PostgresでAI検索を完結させたい」ケースが増えています。pgvectorscaleはpgvectorベースでこれを現実的にする選択肢です。  
- SaaS（例：Pinecone）と比較したベンチマークで大幅な性能/コスト優位が報告されており、オンプレやクラウド自主管理で検討する価値があります。

## 詳細解説
- コア技術
  - StreamingDiskANN: Microsoft研究に基づくDiskANNアルゴリズムをPostgres向けに実装した新しいインデックス型。ディスク中心の近似近傍探索をストリーミングで扱う設計で、大規模データセットを低メモリで扱える。
  - Statistical Binary Quantization: Timescaleが提案する圧縮手法。従来のBinary Quantizationより効率的に埋め込みを圧縮して保管コストを下げる。
  - Label-based filtered vector search: ラベルをインデックスに組み込むことで、メタデータによる高速フィルタを実現（MicrosoftのFiltered DiskANNに倣う）。頻繁に使うカテゴリフィルタと組み合わせると有効。

- ベンチマーク（抜粋）
  - 50M件、Cohereの768次元埋め込みを対象にした比較で、pgvector+pgvectorscaleはPineconeのs1ストレージ最適化インデックスに対して、p95レイテンシを28倍低く、クエリスループットを16倍高く、さらに自己ホスティング時はコストを75%削減したと報告されています（99%リコール条件）。

- 実装・エコシステム
  - pgvectorはCで書かれているのに対し、pgvectorscaleはRust + pgrxで実装。Postgres拡張をRustで開発するための選択肢が広がります。
  - インストールは主にDockerイメージ利用かソースコンパイル。CREATE EXTENSION ... CASCADE でpgvectorを自動導入できます。
  - サポート距離：cosine（<=>, vector_cosine_ops）、L2（<->, vector_l2_ops）、inner product（<#>, vector_ip_ops）。※inner product系は「plain storage」と互換性がない点に注意。

- フィルタリング方式
  - ラベルベース（推奨）: smallint[] をラベル列としてインデックスに含め、配列の重なり演算子 && を使って高速に絞り込めます（ラベルは小範囲の整数で扱う）。
  - 任意WHERE句（ポストフィルタ）: ベクトル検索後に条件で絞る方式。正確だが遅くなる可能性あり。頻繁に使うフィルタはラベル方式への移行を検討すべき。

- ビルド・チューニング
  - インデックス作成はメモリ負荷が高くなり得るため、maintenance_work_memを増やすと改善します（例: SET maintenance_work_mem = '2GB';）。  
  - ビルド時パラメータ（大幅な挙動変化）とクエリ時パラメータ（精度/速度トレードオフ）を分けて調整可能。一般的にはデフォルトで運用し、必要に応じてクエリ側で調整。

- 注意点
  - macOS x86（Intel）でのビルドは現状制限あり（ARMやLinux、Dockerを代替）。  
  - Timescale Cloudでのプライベートベータ提供や、自己ホスティング向けのDockerイメージが用意されています。

## 実践ポイント
- まずはDockerで動かして簡易ベンチ：自社の埋め込みを少量投入してp95/スループット/コストを比較する。  
- 頻繁に使うカテゴリフィルタがあるなら、smallint[]ラベルを導入してインデックスに含める（パフォーマンス改善が大きい）。  
- 精度（リコール）と速度のトレードオフはクエリ時パラメータで調整可能。SLAに合わせてチューニングする。  
- 自己ホスティングでコスト優位を狙う場合は、I/O・メモリ構成と運用コストを含めた総合比較を実施する（PineconeなどSaaSと比較）。  
- 開発者ならRust＋pgrxでの拡張貢献が可能。Postgres拡張のエコシステムにRustで参加したい場合の入り口としても有望。

## 参考導入例（SQL）
```sql
-- テーブル作成
CREATE TABLE IF NOT EXISTS document_embedding (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  metadata JSONB,
  contents TEXT,
  embedding VECTOR(1536)
);

-- StreamingDiskANNインデックス作成（cosine）
CREATE INDEX document_embedding_idx ON document_embedding USING diskann (embedding vector_cosine_ops);

-- 検索例
SELECT * FROM document_embedding ORDER BY embedding <=> $1 LIMIT 10;
```

ラベルでフィルタする場合:
```sql
CREATE TABLE documents (
  id SERIAL PRIMARY KEY,
  embedding VECTOR(1536),
  labels SMALLINT[], -- ラベルを整数配列で保持
  status TEXT,
  created_at TIMESTAMPTZ
);

CREATE INDEX ON documents USING diskann (embedding vector_cosine_ops, labels);

SELECT * FROM documents
WHERE labels && ARRAY[1,3]
ORDER BY embedding <=> '[...]'
LIMIT 10;
```

## 引用元
- タイトル: Postgres extension complements pgvector for performance and scale
- URL: https://github.com/timescale/pgvectorscale
