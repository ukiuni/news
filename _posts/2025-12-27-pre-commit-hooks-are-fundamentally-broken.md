---
layout: post
title: pre-commit hooks are fundamentally broken - pre-commitフックは根本的に壊れている
date: 2025-12-27 04:38:21.064000+00:00
categories:
- tech
- world-news
tags:
- tech-news
- japan
source_url: https://jyn.dev/pre-commit-hooks-are-fundamentally-broken/
source_title: pre-commit hooks are fundamentally broken
source_id: 986890068
excerpt: pre-commitの自動整形がコミットやリベースを壊す原因と対策を実例で提示
---
# pre-commit hooks are fundamentally broken - pre-commitフックは根本的に壊れている

## 要約
pre-commitフックは便利だが、gitの「作業ツリー」と「インデックス（ステージされた内容）」の差分やリベース等の操作で思わぬ落とし穴を露呈する。自動整形やチェックを安全に運用するための設計と選択肢を整理する。

## この記事を読むべき理由
日本の開発現場でも、スタイル統一やCIコスト削減のためにローカルフックを採用するケースが増えています。だが設計を誤ると「コミットしたつもりが反映されない」「リベースで壊れる」など現場が混乱します。実務で遭遇する典型的な問題と安全な運用方針を短く示します。

## 詳細解説
元記事の流れ（要約）：
- Rustプロジェクトで rustfmt を使う pre-commit フックを作る。
- 最初はワーキングツリー上のファイルをチェックしていたため、フォーマット後に変更をステージし忘れてコミットに反映されない（フックはインデックスではなくワーキングツリーで動いていた）。
- そこで「インデックスの内容を一時ディレクトリにcheckoutしてチェックする」方法にするが、今度はリポジトリ内の未整形ファイルを巻き込んでしまい、既存コードが原因でコミットできなくなる。
- その後「ステージされたファイルだけを対象にする」ように改善するが、リベースや既存PRの操作時に想定外の副作用が出る可能性が残る。

技術的ポイント（核心）
- Gitのコミットは「インデックス（ステージされた内容）」を元に作られる。ワーキングツリーを検査して変更しても、それをインデックスに反映しなければコミットに含まれない。
- フックで「検査だけ」を行うか、「変更（整形）してインデックスを書き換える」かは挙動が大きく異なる。後者は便利だが、リベース・cherry-pickなどの操作中にコミット履歴や作業状態を壊すリスクがある。
- フック内でインデックスの中身を一時ディレクトリにcheckoutして検査する手法は、インデックスにある古い（未整形の）コードを発見して無関係なファイルで失敗することがある。
- 結果として「pre-commitで完全に自動化しようとすると複雑になり、脆弱性が生まれる」 — これが「pre-commit hooks are fundamentally broken」という主張の実務的な背景。

## 実践ポイント
短いチェックリストと、現場で安全に運用するための選択肢。

1) まず方針を決める
- 自動整形をローカルで即時反映させたい → フック内で整形→git addする（ただし副作用を理解する）。
- 単にチェックして失敗させたい → フックはチェックのみ。整形はエディタやCIで行う。

2) ステージされたファイルのみを対象にする（シンプルで安全）
- 例：変更がステージされている .rs ファイルを整形して再ステージするシンプルなフック例

```bash
#!/bin/sh
# bash
set -eu

# ステージされたRustファイルを取得
files=$(git diff --name-only --cached --diff-filter=ACM | grep '\.rs$' || true)
[ -z "$files" ] && exit 0

for f in $files; do
  # ワーキングツリーのファイルを整形してインデックスを更新
  rustfmt "$f"
  git add -- "$f"
done
```

注意点：このアプローチは普段のコミットでは有効だが、リベースや自動適用されるスクリプト中では想定外の変更を生む可能性がある。

3) リベース／CI／サーバー側の制約に配慮する
- リベース中は自動整形が予期せぬ競合を生むことがある。リベースやCI上の自動適用（オートコミット）は慎重に。
- 重要なブランチにはサーバー側（CI）でのチェックを必須にする（例：PRマージ時にformat/lintを通す）。これでローカルの差異を吸収できる。

4) より安全で運用しやすい代替
- pre-commitフレームワーク（pre-commit.com）や Husky のような既存ツールを使う：標準化された挙動、言語ごとのプラグインで安定する。
- エディタの保存時整形（format-on-save）を徹底して、フックは「失敗させる（fail-fast）」だけにする。
- CIで「自動修正→CIコメントでPRに提示」など、サーバー側で非破壊的に対応するワークフロー。

5) 運用ルールを明文化する
- フックがどのタイミングで何をするか（整形する/チェックのみ）をチームの貢献ルールに明記。
- ローカルでの自動整形を許すなら、リベースやcherry-pick時の標準動作もドキュメント化しておく。

