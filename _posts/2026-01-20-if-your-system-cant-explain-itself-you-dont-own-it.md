---
layout: post
title: "If Your System Can’t Explain Itself, You Don’t Own It - システムを説明できなければ、それは自分のものではない"
date: 2026-01-20T16:04:18.081Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://hashrocket.substack.com/p/if-your-system-cant-explain-itself?r=2tdr22"
source_title: "If Your System Can’t Explain Itself, You Don’t Own It"
source_id: 423296808
excerpt: "説明不能な振る舞いは運用で所有できない、決定ログと名前付き遷移で原因まで追える設計を導入せよ"
image: "https://substackcdn.com/image/fetch/$s_!IjCa!,w_1200,h_675,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff11d0aa3-4439-46d0-9d70-e318dd5cac6f_768x512.jpeg"
---

# If Your System Can’t Explain Itself, You Don’t Own It - システムを説明できなければ、それは自分のものではない
クリックしたくなる日本語タイトル：説明できないシステムは“他人のもの”──現場で使える「説明性」リファレンス

## 要約
見た目は正常でも、なぜその振る舞いになったのか説明できないシステムは運用下で「所有」されていない。設計段階で決定過程を可視化する仕組みを組み込むことが長期的な信頼性を生む。

## この記事を読むべき理由
日本のエンジニアリング現場はレガシーと短期対応の積み重ねで「暗黙知」が溜まりやすく、障害時に調査が属人化しやすい。説明可能なシステム設計は、オンコール負荷軽減・コンプライアンス対応・早い復旧につながるため、特に必読です。

## 詳細解説
- 問題の本質：監視が「成功」を示しても、それは何が起きたかの確認に過ぎない。振る舞いの理由（why）が不明だと、エッジケースや振る舞いの変化に対処できない。  
- 暗黙状態（implicit state）：リトライやフォールバック、設定オーバーライド、キャッシュ挙動などが時間とともに積み重なり、挙動の因果関係がモジュール間に分散する。結果、動作は正しくても誰もその根拠を即答できない状態になる。  
- 所有とは説明できること：真の所有は「誰が・いつ・なぜ」その状態になったかを圧力下でも説明できること。説明は単なるドキュメントではなく、ランタイムで辿れる事実（decision log、named transitions、明示的な状態遷移）を指す。  
- 実装手法の例：明示的なステートマシン（全状態・遷移に名前付け）、意思決定ログ（ルールと評価結果を記録）、閾値横断をイベント化して可視化する。これらは初期の開発速度を多少落とすが、将来の調査コストと認知負荷を劇的に下げる。

## 実践ポイント
- まず問いを決める：オンコールで必ず答えたい質問（例：「誰の操作でこの権限が付与されたか？」）を洗い出す。  
- 決定ログを残す：単なるイベントログではなく「どのルールがどのように評価されてその結果になったか」を構造化して記録する。  
- 名前付き遷移を導入：状態遷移に意味のある名前を付け、監視やダッシュボードで直接参照できるようにする。  
- 可視化を標準化：決定IDや相関IDを使い、リクエスト→意思決定→レスポンスの一連をダッシュボードで追えるようにする。  
- 小さく始める：まずは重要なサブシステム1つで実験。ステートマシン化、構造化ログ、短い説明メッセージを導入して効果を測る。  
- レビュー観点に「説明性」を追加：コードレビューや設計レビューで「この挙動を運用者は一目で説明できるか」をチェック項目にする。

短時間の工数増は将来の障害対応時間を何倍も節約します。どこが「説明できない」まま放置されているかを一度洗い出してみてください。
