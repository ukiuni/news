---
layout: post
title: "Parse, Don't Validate (2019) - 解析せよ、検証に留まるな"
date: 2026-02-10T16:45:42.528Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/"
source_title: "Parse, don’t validate"
source_id: 46960392
excerpt: "境界で入力を解析し厳格な型に保持、バグと冗長チェックを防ぐ実践的設計指南"
---

# Parse, Don't Validate (2019) - 解析せよ、検証に留まるな
エラーを型で潰す：検証から「解析」へ踏み込む型設計のコツ

## 要約
静的型を使うなら「validate（検証）して捨てる」より「parse（解析）して型に保存する」ほうが安全で保守的。型に情報を持たせれば冗長チェックや潜在的バグをコンパイル時に防げる、という主張です。

## この記事を読むべき理由
日本のサービスでも外部入力（JSON、環境変数、コマンドライン等）を扱う機会は多く、ミスやセキュリティ欠陥を未然に防ぐための実践的な設計指針を得られます。TypeScript/Rust/Goなど型を活かす言語でも応用可能です。

## 詳細解説
著者は「head :: [a] -> a」が空リストで成り立たない例から話を始めます。動的言語なら実行時に例外で処理するところを、静的型では

- 戻り値を弱めて Maybe を返す（validate 的）：head :: [a] -> Maybe a  
- 引数の型を強化して非空リストを受け取る（parse 的）：head :: NonEmpty a -> a

の二択があると説明します。前者は呼び出し側に常に Nothing 処理を強制し、冗長チェックや将来の不整合（検査コードが消えたときのバグ）を招きます。後者は「非空であること」を型として保持することで、一度だけ入力境界でチェック（＝解析）すれば以降は安全に使えます。

短い Haskell 例：
```haskell
-- validate（冗長な扱い）
head :: [a] -> Maybe a
head (x:_) = Just x
head []    = Nothing

-- parse（型で情報を保持）
head :: NonEmpty a -> a
head (x :| _) = x
```

著者はこれを「parse（より構造化された型を作る）＝情報を保存する行為」と定義し、境界でのパースを徹底することでコンパイル時の保証を活かせると主張します。また、逆にアドホックな検証を内部に散らすと「shotgun parsing（入力処理と検証が混在してしまう）」という脆弱性につながる点も警告します。

## 実践ポイント
- 外部入力はまず境界で「解析（parse）」して、より厳格な型（refined type）に変換する。以降はその型で処理する。  
- 戻り値で情報を捨てる（unit／Maybeで済ます）より、可能なら引数を強化して不変条件を型に表現する。  
- TypeScriptなら io-ts/zod、Rustなら serde＋newtype、Goでも小さな型ラッパーや構造体で同様の考えを適用。  
- 入力チェックを一箇所にまとめ、APIの型シグネチャで「何が保証されているか」を明確にする（テストと型で二重保険）。  

以上を意識すると、冗長なランタイムチェックや取りこぼしによるバグを減らし、ソフトウェアの安全性と可読性が向上します。
