---
layout: post
title: "Font Rendering from First Principles - フォント描画を根本から理解する"
date: 2026-02-13T22:22:08.121Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://mccloskeybr.com/articles/font_rendering.html"
source_title: "mccloskeybr"
source_id: 46930181
excerpt: "TTFを自作で解剖し、ベジェ・ワインディング・ヒンティングで文字を鮮明に描く実装ノウハウを解説。"
image: "https://mccloskeybr.com/images/font_rendering_1.png"
---

# Font Rendering from First Principles - フォント描画を根本から理解する
フォント描画を自作して見えた「文字が鮮明に見える仕組み」 — TrueType を一から解剖する

## 要約
TrueType（TTF）を読み解き、自分でグリフを解析・ラスタライズした体験から、フォントが高品質に表示される仕組み（テーブル構成、ベジェ曲線、ワインディング、フォントヒンティングやアンチエイリアスの限界）を平易に解説する記事の要点。

## この記事を読むべき理由
フォント描画は当たり前に使っている技術だが、実装の難所と最適化ポイントを知るとUI品質とパフォーマンス改善に直結する。日本語を含む縦組みや大文字数フォントの扱いで特有の課題があるため、日本の開発現場で役立つ知見が得られる。

## 詳細解説
- TTF の基本構造  
  主要テーブル: cmap（コードポイント→グリフインデックス）、loca（グリフオフセット）、glyf（輪郭データ）。補助的に head/maxp/hhea/hmtx/kern 等があり、縦組みでは vhea/vmtx が重要。OTF は拡張版だが、TTF パーサを理解しておくと応用が効く。

- グリフと輪郭の表現  
  TTF のグリフは複数の輪郭（contour）で、各輪郭は二次ベジェ（quadratic Bezier）で表される。二次ベジェの評価式は例えば次の通り：  
  $$((1-t)^2)P_{start} + 2(1-t)tP_{control} + t^2P_{end},\quad t\in[0,1]$$  
  オンカーブ（実点）/オフカーブ（制御点）の混在、オフカーブ同士が連続する場合は中点の暗黙オン点を挿入する必要がある。複合グリフ（dot やダイアクリティカル）は別登録されたサブグリフを変換して合成する。

- ラスタライズ手順の概略  
  1) 描画先ビットマップ（またはグリフアトラス）を決める。  
  2) 各スキャンライン（ピクセル中心）に対してグリフ空間の y を対応付け、ベジェと交差する x を求める（0≤t≤1 を解く）。  
  3) 交差ごとに「入る/出る」を判定しワインディング（符号付きカウント）を更新、塗りつぶし判定を得る。輪郭の向き（外殻は時計回り、穴は反時計回り）が手がかりになる。  
  4) 得られた内外情報をターゲットピクセルに写す。  
  注意点：ベジェを解く際の除算ゼロ（線分扱い）、浮動小数点誤差による交差数のズレ、アンチエイリアス処理の欠如による見栄えの悪さ。

- 実装上の学びと妥協点  
  FreeType のような成熟実装はヒンティング（小サイズでのプロポーショナルな補正）や大量の最適化を持つため、基本実装だけでは小さいサイズやサブピクセルで十分に綺麗にならない。代替として SDF（署名距離場）を使うとスケーラビリティは良いが、複雑な筆画（特に日本語）には注意が必要。デバッグには既存パーサ（stb_truetype 等）と比較するのが有効。

## 実践ポイント
- まずは既存実装（FreeType）を使い、拡張ニーズが出たら自前実装を検討する。  
- ラスタライズ時はピクセル中心を基準にすること、線分ケースを特別扱いすること。  
- オフカーブ同士の中点オンカーブ挿入と輪郭向き（CW/CCW）の管理を忘れない。  
- 日本語対応では文字数と複雑さが増すためアトラス設計とメモリ管理を重視、縦組みテーブル（vhea/vmtx）やフォントヒンティングの影響を検証する。  
- 見た目優先なら SDF＋GPU、ピクセル完璧性が要るならヒンティング対応のビットマップ生成を検討する。  
- デバッグには既知のパーサ（stb_truetype）や FreeType と結果を逐次比較する。

以上を押さえれば、フォント描画の「なぜこう見えるか」が実装レベルで理解でき、UI品質とレンダリング性能の両面で改善策を打てます。
