---
layout: post
title: "Doing Binary Search right is harder than you might think - 二分探索を「正しく」書くのは思ったより難しい"
date: 2026-01-09T10:21:21.479Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://raw.org/book/algorithms/binary-search/"
source_title: "Binary Search (done right) &bull; RAW"
source_id: 468549286
excerpt: "境界とオーバーフローを防ぐ正しい二分探索の実装法を明快に解説、面接やライブラリ実装で必須の知識"
---

# Doing Binary Search right is harder than you might think - 二分探索を「正しく」書くのは思ったより難しい
思わず実装を見直したくなる――境界とオーバーフローを確実に防ぐ「正しい」二分探索の作法

## 要約
二分探索は直感的だが、境界の取り扱いや停止条件、整数オーバーフローでバグを生みやすい。半開区間 $[L,R)$、オーバーフロー回避の中点計算、ループ不変式で堅牢に実装するのが正攻法だ。

## この記事を読むべき理由
採用面接、ライブラリ実装、組み込みや大規模データ処理など日本でも頻出の場面で「一見正しそうだがバグる」二分探索に遭遇しがち。正しいパターンを理解すればバグを避け、標準ライブラリの動作（例えば C++ の std::lower_bound/upper_bound）も正しく使える。

## 詳細解説
問題設定：長さ $n$ の非減少配列 $A[0\dots n-1]$ に対してキー $x$ を探し、存在すればそのインデックス、存在しなければ“不在”または挿入位置を返す。

よくある失敗点
- 境界の曖昧さ（上端を含めるか否か） → off-by-one
- 更新が進まない → 無限ループ
- 中点計算で $(L+R)$ が整数オーバーフロー → 無効なインデックス

推奨する表現：候補インデックス集合を半開区間 $[L,R)$ で表す。初期化は $L=0,\;R=n$。区間が空のとき $L=R$ で探索終了。

中点はオーバーフローを避けて
$$
m := L + \left\lfloor\frac{R-L}{2}\right\rfloor
$$
と計算する。これは整数上で $\left\lfloor\frac{L+R}{2}\right\rfloor$ と同値で、安全に $L\le m < R$ を保証する。

ループ不変式（常に成り立つことを保つ）
- $0 \le L \le R \le n$
- 左側の除外：$\forall i < L:\; A[i] < x$
- 右側の除外：$\forall i \ge R:\; A[i] > x$

更新規則（$m$ を決めて比較）
- $A[m] < x$ → $L := m+1$（$m$ まで全て $<x$）
- $A[m] > x$ → $R := m$（$m$ 以降全て $>x$）
- $A[m] = x$ → $m$ を返す

この更新により候補区間長 $d=R-L$ は必ず厳密に減少し、有限回で終了する（進行性）。また、返すインデックスは必ず正しい（部分正確性）し、不在を報告する場合も不在が保証される（全体正確性）。

重複要素がある場合は境界検索が有用：
- lower_bound(x): 最初の $i$ s.t. $A[i] \ge x$
- upper_bound(x): 最初の $i$ s.t. $A[i] > x$
これらも同じ $[L,R)$ の枠組みで実装でき、出現回数や初回／最終出現の計算に使える。

実装上の言語別注意点
- C/C++: 整数型の符号とオーバーフローに注意。一般に $L+(R-L)/2$ を使うか、固定幅で unsigned にキャストして右シフトを使う。
- Java/JS: `(L+R) >>> 1`（論理右シフト）という習慣があるが、$L+(R-L)/2$ が最も移植性が高い。
- 高水準言語（Python等）ではオーバーフローは問題になりにくいが、境界ロジックは同じ。

## 実践ポイント
- 常に半開区間 $[L,R)$ を使う。上端を含める実装はバグ源になりやすい。
- 中点は m = L + (R - L) // 2（整数除算）で。これが最も汎用的で安全。
- 更新は「$A[m] < x$ → L = m+1」「$A[m] > x$ → R = m」「等しければ返す」。これをテンプレ化してテストする。
- 重複がある配列では lower_bound/upper_bound を使えば目的に合った位置が得られる。
- 実運用では標準ライブラリを優先（例：C++ の std::lower_bound/std::upper_bound、Java の Arrays.binarySearch）。自前で実装するときは上記不変式をコメントで明示し、単体テストで境界ケース（空配列、長さ1、全要素同値、最大インデックス）を必ず含める。
- 面接やコードレビューの場では「どの区間表現を使ったか」「中点をどう計算したか」「無限ループをどう防いだか」を簡潔に説明できるようにしておく。

参考となる簡潔な実装（Python）:

```python
def binary_search_any(A, x):
    L, R = 0, len(A)  # [L, R)
    while L < R:
        m = L + (R - L) // 2
        if A[m] < x:
            L = m + 1
        elif A[m] > x:
            R = m
        else:
            return m
    return -1
```

小結：直感に頼ると危険だが、$[L,R)$ と $m=L+(R-L)//2$、明確な不変式を守れば二分探索は堅牢になる。日本の現場でも頻出の基本アルゴリズムなので、まずはこのパターンを自分のテンプレートにしておくと安心。
