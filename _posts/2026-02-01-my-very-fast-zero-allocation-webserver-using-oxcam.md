---
layout: post
title: "My (very) fast zero-allocation webserver using OxCaml - OxCamlで作る超高速ゼロ割当てWebサーバ"
date: 2026-02-01T23:04:52.103Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://anil.recoil.org/notes/oxcaml-httpz"
source_title: "My (very) fast zero-allocation webserver using OxCaml"
source_id: 833252589
excerpt: "OxCamlの拡張でヒープ割当ほぼゼロ、GCノイズを消した超高速HTTP/1.1サーバ実装法"
---

# My (very) fast zero-allocation webserver using OxCaml - OxCamlで作る超高速ゼロ割当てWebサーバ
驚くほど速い「ゼロ割当て」HTTPパーサで、WebサーバのレイテンシとGCノイズを消す方法

## 要約
OxCamlの新拡張（アンボックス型／ローカル割当て等）を使い、HTTP/1.1パーサ httpz を「ほぼヒープ割当てゼロ」で実装。接続のライフサイクルをコールスタックだけで完結させ、GC活動を極小化して高速化するアプローチを解説します。

## この記事を読むべき理由
高トラフィック・低レイテンシなサーバ設計や、大量データ処理（埋め込みやインデックス保持）を行う日本のバックエンド開発者にとって、GCによるパフォーマンス変動を抑えつつ安全な型付き言語で高速化する実践的選択肢を示します。Pythonや普通のOCamlとのトレードオフも分かります。

## 詳細解説
- 何を目指すか：HTTP接続処理を関数コールとレジスタ／スタック上の値だけで完結させ、ヒープ割当て・GCをほぼ発生させない「ゼロ割当て」HTTP/1.1パーサ（httpz）。
- 中核技術：
  - アンボックス型とアンボックス記録（OxCamlの #{ ... } 構文）により、16ビット幅などの小型整数やタプルをスタック／レジスタに直接保持できる。例：  
    ```ocaml
    type Httpz.t = #{ off : int16# ; len : int16# }
    ```
  - アンボックス整数／文字／浮動小数点で、タグ付け/ボクシングを回避し、ネイティブ命令で直接演算。
  - ローカル割当て(local_)とexclave_で「スタック借用」を明示し、値が外部に逃げないことを保証してスタック上に確保。
  - let mutable によるスタック上可変変数でループ処理をヒープ割当てなしに書ける。
  - これらを組み合わせると、HTTPヘッダ解析などは32KBバッファ1つと関数呼び出しだけで完了し、GC発生が稀になる。
- 性能証拠：記事著者は中間表現（lambda）やネイティブアセンブリを確認し、アンボックス版はレジスタ操作のみ、従来の箱付きOCamlは新オブジェクト割当てやGCチェック命令を含むことを示している。
- 制約と注意点：
  - ツール周り（odocやocamlformatのjanе fork等）は発展途上で、OxCaml拡張を通常のOCamlへ戻す作業は手間。
  - unboxed レコードの可変化や or_null といった機能は成熟途上で、型推論エラーや制限に遭遇しやすい。
  - とはいえ、HTTP/1.1のヘッダ中心のパスは現時点でも非常に実用的。

## 実践ポイント
- 小さく始める：まずはパフォーマンスクリティカルな箇所（HTTPパーサやバイナリプロトコルのパース）だけをOxCamlで書き換えて比較する。
- バッファ設計：固定上限（例：32KB）を想定し、int16#など狭い幅のアンボックス型を使うと効率的。
- ローカル／exclave を活用して「借用」的な設計にし、データが外に逃げないことを明示する。
- 可変ループには let mutable を使い、refや小さなオブジェクトの割当てを避ける。
- ベンチと逆コンパイル確認：ocamlopt の -dlambda / -S を使い、実際に割当てが消えているかアセンブリで確認する。
- ツール互換性に注意：既存のCIやドキュメント生成に組み込む前に、odoc/ocamlformat周りの対応状況を確認する。

OxCamlは「型安全でGCの恩恵も受けつつ、システム寄りの速度を得たい」場合の有力な選択肢です。まずは解析やプロトコル処理のホットパスから試してみてください。
