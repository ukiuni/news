---
layout: post
title: "Building a Coding Agent (provider-agnostic) - コードエージェントを構築する（プロバイダ非依存）"
date: 2026-01-17T16:43:15.449Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://cefboud.com/posts/provider-agnostic-coding-agent/"
source_title: "Building A Coding Agent (Provider-agnostic) | Moncef Abboud"
source_id: 424470625
excerpt: "オンプレで安全に動く、プロバイダ非依存のコードエージェントを実例で作る方法"
image: "https://cefboud.com/assets/img/favicons/og.png"
---

# Building a Coding Agent (provider-agnostic) - コードエージェントを構築する（プロバイダ非依存）
あなたのローカルで動く「賢いコード秘書」をゼロから作る方法

## 要約
LLM（大規模言語モデル）に「ツール」を与え、モデルの出力をプログラム側で実行することで、ファイル操作やコマンド実行ができる“コーディングエージェント”をプロバイダ非依存（LiteLLMを例）で実装する手法を解説します。

## この記事を読むべき理由
ツール呼び出しの仕組みは、LLMが単にテキストを生成するだけの存在であることを理解し、実際に安全に自動化できる実装パターンを学べます。日本の企業で「社内データを外に出さずに自動化したい」「VS Codeで補助ツールを組み込みたい」といったニーズに直結します。

## 詳細解説
- コアアイデア：LLMは実行環境を持たないため、「どのツールを呼ぶか＋引数」をJSONなどで出力させ、プログラム側でそのツールを実行して結果を会話コンテキストに戻す。これをループさせることで逐次的にタスクを完遂する。
- ツール定義：APIリクエストにあらかじめ渡す「関数定義（name, description, parameters）」により、LLMはread_file, list_files, edit_fileのような操作を呼び出せる。edit_fileは「old_strをnew_strに置換、old_strが空なら新規作成」というシンプルな設計。
- 実行フロー：ユーザー→会話を含めたリクエスト→LLM応答（ツール呼び出し）→プログラムがツール実行→結果を会話に追加→LLMに再入力、を繰り返す。エラーはツール出力として返し、LLMに軌道修正させるのが重要。
- プロバイダ非依存：LiteLLMのようなラッパーを使い、MODELやAPI_BASEを環境変数で差し替えれば、オンプレや別プロバイダへ切り替え可能。つまり実装はAPI仕様に依存せず移植性が高い。
- セキュリティと現実運用：本質は「外部実行権」を与えることなので、権限分離・ログ・サンドボックス化・秘密情報の管理（環境変数やVault利用）が必須。MCPのようなリモートツール実行プロトコルを使えば、実行場所を分離できる。

## 実践ポイント
- 最小構成で始める：まずは read_file / list_files / edit_file の3つを定義して動作確認する。
- 明確なエラーメッセージを返す：ツール実行で「Old string not found」など具体的に返すとLLMが修正しやすい。
- 環境変数で切り替え可能に：MODEL, API_KEY, API_BASEは.envで管理し、プロバイダ切替を容易にする。
- 低リスクで運用する：最初は読み取り専用モードで試し、編集権限は段階的に付与する。CIやレビューを組み合わせる。
- VS Code連携案：エージェントをVS Code拡張やタスクパネルに差し込み、開いたファイルを対象に動かせば日本の開発現場でも受け入れやすい。
- 発展案：LSP連携、ユニットテスト自動生成、複数セッション管理、より粒度の高いツール（ビルド・テスト実行・依存解析）を追加する。

元記事は実例コードとデモを公開しており、手を動かして学ぶのが理解を深める近道です。内製化・オンプレ導入を検討する日本のチームには特に有用なアプローチです。
