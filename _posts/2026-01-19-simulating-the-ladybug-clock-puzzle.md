---
layout: post
title: "Simulating the ladybug clock puzzle - てんとう虫の時計パズルをシミュレートする"
date: 2026-01-19T16:50:31.430Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://austinhenley.com/blog/ladybugclock.html"
source_title: "Simulating the ladybug clock puzzle - Austin Z. Henley"
source_id: 1483442448
excerpt: "てんとう虫の時計移動で直感を覆す均等性が現れ、最後の時刻は全て同確率になる"
image: "https://austinhenley.com/blog/images/ladybugclock.png"
---

# Simulating the ladybug clock puzzle - てんとう虫の時計パズルをシミュレートする
最後に止まる数字はどこ？てんとう虫が教える「意外な均等性」

## 要約
てんとう虫が12時から隣の時刻へランダムに移動して、すべての時刻を一度は踏むまで続けるとき、最後に訪れる時刻はどこが一番多いか――シミュレータでは「どの時刻も等確率」で、確率は $$\frac{1}{11}$$ になる。

## この記事を読むべき理由
直感だと「遠い6時が最後になりやすい」など偏りを予想しがちです。単純なルールから出る確率の直感的な裏切りは、ランダムウォークやマルコフ過程の理解を深め、アルゴリズムやシミュレーションを学ぶ良い題材になります。Visual Studio Codeで手軽に試せるので、初心者にも実践的です。

## 詳細解説
問題の設定は次の通りです。12個のマーカー（0＝12時, 1＝1時, …, 11＝11時）にてんとう虫が0から始まり、毎ステップで隣のマーカーに左右どちらかに等確率で移動します。すでに訪れたマーカーは再訪可。全12箇所を少なくとも1度訪れるまで続けたとき、最後に訪れるマーカーがどれになるかの確率分布を求めます。

直観では「6が遠いから最後になりやすい」ように思えますが、シミュレーションを多く回すと各マーカー（スタートの0を除く）はほぼ同じ頻度で最後になり、確率は $$\frac{1}{11}$$ になると示唆されます。

なぜ均等になるか（直感的説明）
- 重要な観察：訪れた集合は常に「連続した弧（区間）」になります。スタートが中心でなくとも、訪問が広がるときは常に弧の両端のどちらかが拡張される形になります（サイクルを切って線に直すと分かりやすい）。
- これを線上の11個の要素（スタート以外）と考えると、「毎回、残りの要素の左端か右端が次に“消される（訪れられる）”」という操作になります。左右どちらが選ばれるかは確率に依存しても、ラベル（位置）は一律に配置されているため、どの位置が最後に残るかは対称性により等しい確率になります。
- 言い換えると、ラベルの順序を固定したまま「端から取り除く」操作をする過程で、最終的に残る要素が特定の位置に偏る理由はなく、11個のどれも同じ確率で最後になります。

数学的には、サイクル上の単純ランダムウォークが「弧を拡張する過程」になるという性質と、ラベル順序に対する対称性（端取り操作での置換に対する不変性）を組み合わせれば、任意の非始点頂点が最後になる確率は同じ、すなわち $$\frac{1}{11}$$ になります。

## 実践ポイント
- まずは手を動かして理解する：下記の簡単な JavaScript シミュレータを VS Code で実行してみてください（Node.js が必要です）。

```javascript
// javascript
function runOnce() {
  let pos = 0;
  const visited = new Set([0]);
  while (visited.size < 12) {
    const dir = Math.random() < 0.5 ? -1 : 1;
    pos = (pos + dir + 12) % 12;
    visited.add(pos);
  }
  return pos;
}

function estimate(trials=10000) {
  const counts = Array(12).fill(0);
  for (let i = 0; i < trials; i++) counts[runOnce()]++;
  return counts.map((c, i) => ({i, p: c / trials}));
}

console.log(estimate(50000));
```

- VS Code での実行ヒント：アクティブファイルに保存して、統合ターミナルで `node ファイル名.js` を実行。拡張機能のデバッグやテストランナーで複数回回すと平均や分布が見やすいです。
- 応用課題：サイクルの頂点数を変えてみる（$n$に対して最後の確率は $$\frac{1}{n-1}$$ になるはずです）、あるいは重み付きランダムウォークや格子グラフで同様の振る舞いが成り立つか試すと理解が深まります。
- さらに知りたい人へ：「全訪問に要する平均ステップ数（カバータイム）」は $O(n^2)$ のオーダーになります。n=12 の場合はシミュレーションで平均値を出してみてください。

短くまとめると、「見た目の直感を裏切る均等性」はランダムウォークの内部対称性と“端を順に拡張する”構造から来ます。実際にコードを動かして確かめるのが一番の学びです。
