---
  layout: post
  title: "Go 1.26 interactive tour - Go 1.26 インタラクティブツアー"
  date: 2026-01-05T20:40:17.678Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://antonz.org/go-1-26/"
  source_title: "Go 1.26 interactive tour"
  source_id: 1668660045
  excerpt: "Go1.26でGC・cgo・SIMDなどが数〜数十％高速化を解説"
  image: "https://antonz.org/go-1-26/cover.png"
---

# Go 1.26 interactive tour - Go 1.26 インタラクティブツアー
Go 1.26で「速さ」と「安全性」を同時に手に入れる — 実務で嬉しい新機能を短く分かりやすく解説

## 要約
Go 1.26はGCや小オブジェクト割当、cgo/syscall経路、型安全なエラー判定、SIMD利用などで実行効率を大きく改善します。日常のサービス運用やパフォーマンスチューニングに直結する変更が多いのが特徴です。

## この記事を読むべき理由
日本のクラウド・マイクロサービス、社内バッチ、組込みやネットワーク処理など実務でGoを使う開発者にとって、低レイヤの改善は「そのまま運用コスト低減」や「レスポンス改善」に繋がります。変更点の意図と採用時の注意点を理解して現場で賢く移行できるようにします。

## 詳細解説
- new(expr)
  - これまで型のみ受け取っていた new が任意の式を受け取れるようになりました。式の値で初期化された変数のポインタを返します。JSON/Protobufでオプショナルなポインタフィールドを作るとき便利です。
  - 例:
```go
// go
p := new(42)        // *int, 値42で初期化されたポインタ
fmt.Println(*p)     // 42
```
- 型安全なエラー判定: errors.AsType
  - ジェネリクスを使った errors.As の型安全版。reflection を使わずコンパイル時に型チェックされるため安全かつ速く、エラーごとの分岐が簡潔になります。
```go
// go
if target, ok := errors.AsType[*MyErr](err); ok {
    // target は *MyErr 型
}
```
- Green Tea GC（デフォルト有効）
  - 小さなオブジェクト中心にメモリを連続する 8KiB スパン単位で処理し、同一スパンの複数オブジェクトをまとめて走査することでキャッシュ効率を改善。多コア環境でのGCオーバーヘッドを下げる設計です。問題がある場合は GOEXPERIMENT=nogreenteagc で戻せます（1.27で削除予定）。
- cgo/syscall の軽量化
  - プロセッサ（P）状態管理を簡素化して cgo/syscall 経路のオーバーヘッドを削減。cgo多用や頻繁なsyscallを行うコードで数〜数十％の改善が期待できます。
- 小オブジェクト向けの割当最適化
  - 1〜512バイトの割当でサイズ特化ルーチンにディスパッチし、少ないコストで高速割当を実現。大きな効果は割当多発パスで出ます。無効化は GOEXPERIMENT=nosizespecializedmalloc。
- SIMD（実験的: simd/archsimd）
  - amd64向けにアーキ固有のベクター命令を直接利用する低レベルAPIを導入。サーバ側の数値演算や信号処理で高速化できますが、移植性に注意（現状はamd64限定）。フォールバック実装を用意しておくのが現実的。

その他にも、io/ fmt 最適化やゴルーチンメトリクスなど実用的な改善多数。公式のリリースノートやコミット参照が推奨です。

## 実践ポイント
- まずはテスト環境でGo 1.26にアップデートしてパフォーマンス/メモリプロファイルを比較する（簡単なベンチ/負荷試験を推奨）。
- new(expr) はJSON/Protobufのポインタ初期化に便利。既存コードの可読性向上に使える。
- errors.AsType を新規コードでは積極採用。既存の errors.As からの置換は慎重に（型の振る舞いを確認）。
- SIMDを使うコードはベンチを用意し、ターゲットCPUでの実行時を確認。クラウドのインスタンスCPUによって効果が変わる。
- 問題が出たら環境変数で実験的変更を無効化できる（nogreenteagc / nosizespecializedmalloc）。ただしこれらは将来的に削除予定なので根本原因の把握が望ましい。

短くまとめると、Go 1.26は「そのまま速くなる」改善が多く、特にサーバサイドやcgo多用環境で恩恵が大きい。まずは安全なテスト導入から。
