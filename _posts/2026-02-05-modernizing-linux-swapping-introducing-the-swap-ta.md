---
layout: post
title: "Modernizing Linux swapping: introducing the swap table - Linuxのスワップを近代化：スワップテーブルの導入"
date: 2026-02-05T09:28:16.812Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://lwn.net/SubscriberLink/1056405/e728d95dd16f5e1b/"
source_title: "Modernizing swapping: introducing the swap table [LWN.net]"
source_id: 46896586
excerpt: "6.18で導入されたスワップテーブルが競合を減らし性能を5〜20%向上"
---

# Modernizing Linux swapping: introducing the swap table - Linuxのスワップを近代化：スワップテーブルの導入

スワップの複雑さをそぎ落として速度とスケーラビリティを取り戻す──Linux 6.18で始まった「スワップテーブル」改修の全体像。

## 要約
Linuxカーネルのスワップ管理が、従来のXArray／address_space中心の構造から、スワップクラスタに密着した「スワップテーブル」へと移行し、競合低減と局所性向上でベンチマーク上は5〜20%の性能改善を達成しています。

## この記事を読むべき理由
スワップはメモリ枯渇時の最後の砦であり、サーバやビルドマシン、低メモリ環境での応答性に直結します。設計変更はOSの基本性能に効くため、システム管理者・カーネル開発者・パフォーマンスに敏感なエンジニアは知っておくべき変化です。

## 詳細解説
- 以前の仕組み（6.17まで）
  - スワップ領域は複数のスワップファイル／パーティションで構成され、ページ単位のスロットをswp_entry_tで表現。
  - スワップ管理はaddress_spaceとそのXArrayに依存し、ファイルを64MBチャンクに分けてそれぞれにaddress_spaceを割り当てていた。
  - さらに2MB程度のスワップクラスタを使い、各CPUがクラスタキャッシュを持つことでスケーラビリティを確保していたが、XArrayルックアップや複層のクラスタリングで競合が残っていた。
- 6.18での変更点（スワップテーブル導入）
  - struct swap_cluster_info にページサイズの配列（atomic_long_t __rcu *table）を持たせ、各スロットの状態を直接格納する「スワップテーブル」を導入。
  - XArrayと多数のaddress_spaceチャンクを廃止し、操作APIを単一のswap_spaceで扱えるようにして内部複雑度を削減。
  - 結果として、XArrayルックアップの削減とクラスタ単位の局所化により競合が減り、ベンチマークでスループットやビルド時間が改善。
- 実装上の注意
  - テーブルは必要時に動的割当てされ、スワップ領域が小さいときはメモリ消費が抑えられる。
  - 動的割当てに関する懸念（極端なメモリ不足でページが確保できない場面）は、カーネルのウォーターマークと予約メモリ機構で緩和される設計になっている。
  - この作業は段階的で、6.18は第1段階。以降のリファクタや追加最適化が継続中。

## 実践ポイント
- カーネル利用者・管理者
  - 重いコンパイルや高負荷のサーバでは、6.18以降でスワップ関連の性能改善が見込めるため、検証を行ってアップグレードを検討する。
  - スワップが多用される環境では vmstat / free / iostat などで挙動を観察し、swappiness等のチューニングを見直す。
- カーネル開発者・貢献者
  - スワップテーブルのパッチ群とfollow-upの差分（6.18以降）を追い、将来のパッチで追加される設計変更に備える。
  - 大規模並列ワークロードでの競合低減効果を自分のワークロードでベンチマークしてフィードバックを送ると効果的。
- 組み込み／低メモリ環境
  - テーブルの動的割当てはメモリ使用を抑える利点あり。Raspberry Piや小型サーバ等での実測を推奨。

この記事で扱った変更は「シンプル化による性能向上」の良い例です。続報（後続パッチや7.0に向けた改善）にも注目してください。
