---
layout: post
title: "CROW: CROBOTS robotic combat for training World Model AIs - CROW：ワールドモデル学習向けCROBOTS改良版"
date: 2026-01-18T20:21:42.586Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://github.com/dcgrigsby/crow"
source_title: "GitHub - dcgrigsby/crow: CROBOTs fork for training World Models"
source_id: 737716192
excerpt: "ロボ戦闘シミュで物理的に正確な学習データを高速大量生成し世界モデル学習に最適"
image: "https://opengraph.githubassets.com/1fd62ed909f02ff611816743e9a28d8a65c918e88b2f3d1f2ab592997d552e52/dcgrigsby/crow"
---

# CROW: CROBOTS robotic combat for training World Model AIs - CROW：ワールドモデル学習向けCROBOTS改良版
レトロなロボ戦闘シミュで「物理的に正確」な学習データを大量生成──現場で使えるシンプルなデータパイプライン

## 要約
CROWは1985年のCROBOTSを拡張し、ロボット戦闘シミュレーションから決定論的かつ物理的に正確なスナップショットを出力するツールです。Transformer系モデルや世界モデル（World Models）向けに扱いやすいテキスト形式の学習データを大量生成できます。

## この記事を読むべき理由
日本の研究者・エンジニアやゲーム開発者にとって、安価で再現可能な物理シミュレーションデータは強力な資産です。CROWはローカル環境で簡単に大量データを作り、モデルの一般化（アリーナサイズの変化など）を検証する際に役立ちます。

## 詳細解説
- 何ができるか  
  CROWはバトル演算ごとに「ASCIIフィールド表示」＋「構造化ロボット／ミサイルデータ」をスナップショットとして出力します。出力は人間可読でトークン化しやすく、Transformer に直接使える形式です。

- 出力内容（主なフィールド）  
  - ASCIIの戦場ビジュアライゼーション（グリッドサイズは設定可能、デフォルト128×128）  
  - 各ロボットの位置(x,y)、向き(度)、速度、ダメージ、状態（ACTIVE/DEAD）  
  - ミサイルの位置、向き、最大射程、現在の飛行距離、寿命など  
  - サンプリング間隔はCPUサイクル単位で指定可能（デフォルト30）

- 設定・コマンド（主要オプション）  
  - -b SIZE：戦場サイズ（SIZE×SIZE m、2のべき乗、64〜16384、デフォルト1024）  
  - -g SIZE：スナップショットのグリッド（16〜1024、デフォルト128）  
  - -o FILE：出力ファイル  
  - -m NUM：複数試合をヘッドレスで実行  
  - -u CYCLES：スナップショット間隔（1〜1000、デフォルト30）  
  - -k SIZE：ロボットあたりの命令上限（256〜8000）  
  - -l NUM：1試合あたりの最大サイクル数（デフォルト500000）

- 新機能（ランタイム関数）  
  - batsiz()：現在の戦場サイズ（m）を返す  
  - canrng()：砲の最大射程（m）を返す（約戦場の70%目安）  
  これによりロボットプログラムはアリーナの大きさを動的に取得して戦略を調整できます。

- 実行例（ヘッドレス、デフォルト設定で100試合出力）
```bash
./src/crobots -o training_data.txt -m 100 examples/counter.r examples/jedi12.r
```

- サンプリング密度の目安  
  1試合を最大 $500{,}000$ サイクルで回す設定の場合、スナップショット数はサンプリング間隔 $u$ により次のように概算できます：
$$
N = \frac{500000}{u}
$$
デフォルト $u=30$ だと $N \approx 16{,}666$ スナップショット／試合になります。

- v2.0での破壊的変更  
  - デフォルト戦場が $1000\ \mathrm{m}$ から $1024\ \mathrm{m}$ に（$2^n$ に合わせる）  
  - デフォルトグリッドが非正方形設定から $128\times128$ に変更  
  これらはMLでの整合性（$2^n$ のサイズ）を保つための変更です。

## 実践ポイント
- まずは小さめグリッドで反復：開発中は `-b 512 -g 64` のように小さくして高速生成→モデル学習時に大きくする。例：
```bash
./src/crobots -b 512 -g 64 -o small.txt -m 100 examples/counter.r examples/jedi12.r
```
- サンプリング間隔で品質とサイズを調整：高密度データが欲しければ `-u 10`、ファイルサイズを抑えるなら `-u 60` を試す。
- ロボット設計に batsiz() / canrng() を使う：アリーナ固定に依存しない戦略を作れば、データ多様化が容易にできます。例：
```c
int arena = batsiz();
int max_range = canrng();
int center = arena / 2;
```
- トークナイズしやすい出力形式を活かす：行ベースでサイクル境界（===）や試合区切り（---）が明確なので、前処理パイプライン（行分割→フィールド抽出）を作ればTransformerの入力整形が楽になります。
- 日本の用途例：大学・企業のロボティクス研究、ゲームAIの行動データ生成、自動運転や群ロボットの世界モデル事前学習の低コスト代替データソースとして有効。

CROWは古典的な「ロボットプログラミングゲーム」を現代の機械学習向けに再発明したツールです。再現性の高い物理的データを素早く大量に作れるため、まずは小さいアリーナ・高頻度サンプリングで試し、徐々にスケールアップして学習データの多様性を確保することをおすすめします。
