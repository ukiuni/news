---
layout: post
title: "I learned about 8 versions of UUIDs and decided to make a video about it - UUIDの8種類を学んで動画にした話"
date: 2026-01-22T09:50:17.422Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://youtu.be/UMR_EmBcYE8"
source_title: "UUIDs for Developers: The Definitive 25‑Minute Masterclass - YouTube"
source_id: 420507258
excerpt: "UUIDの8種を徹底比較、DB性能やプライバシー別に最適な選択を解説"
image: "https://i.ytimg.com/vi/UMR_EmBcYE8/maxresdefault.jpg"
---

# I learned about 8 versions of UUIDs and decided to make a video about it - UUIDの8種類を学んで動画にした話
クリックせずにはいられない！UUIDの“どれを使うべきか”が一目でわかるガイド

## 要約
UUIDには歴史的経緯や用途ごとに特徴の違う8つのバージョンがあり、用途（一意性・性能・ソート性・プライバシー）に応じて使い分けるのが重要です。

## この記事を読むべき理由
日本のプロダクト開発やデータベース運用では、ID設計がパフォーマンス・監査・個人情報保護に直結します。どのUUIDを選ぶかでインデックス効率や個人情報漏洩リスクが変わるため、知っておいて損はありません。

## 詳細解説
- バージョン1（v1） — 時間ベース＋ノード（MAC）  
  タイムスタンプと生成元ノード（通常はNICのMAC）を含む。分散環境での衝突回避に有利だが、MAC露出による追跡・プライバシー問題がある。

- バージョン2（v2） — DCEセキュリティ（ほぼ死蔵）  
  POSIX UID/GID を組み込む用途向けの古い規格。現実的にはほとんど使われない。

- バージョン3（v3） — 名前ベース（MD5）  
  名前空間＋文字列から決定的に生成。再現可能。ハッシュはMD5なので衝突耐性はv5より弱い。

- バージョン4（v4） — ランダム（最も普及）  
  完全ランダム。シンプルでプライバシーにも優れるが、時間順にならないためDBのインデックスフラグメンテーションを招くことがある。

- バージョン5（v5） — 名前ベース（SHA‑1）  
  v3と同様だがSHA‑1でより強固。サービス間で「同じ入力なら同じID」を保証したいときに便利。

- バージョン6（v6） — 改良された時間ベース（ソート向け）  
  v1と同等の情報を持ちつつ、タイムスタンプを先頭に置いて「辞書順＝時間順」になるよう改善。DBのクラスタリング性能向上を狙う提案。

- バージョン7（v7） — Unix epochベース＋ランダム（新世代）  
  明示的なUnix時間成分＋ランダムを組み合わせ、時系列ソート性とランダム性を両立。分散システムやログID、プライマリキーに向く。

- バージョン8（v8） — カスタム拡張  
  アプリ独自のアルゴリズムやデータを埋め込める拡張枠。用途次第だが互換性・安全設計に注意が必要。

背景規格はRFC 4122（古いバージョン群）と、v6/v7/v8を扱うIETFの新しいドラフト群です。共通のトレードオフは「予測可能性（順序付け） vs 完全ランダム（プライバシー／衝突耐性）」、およびストレージ側のインデックス効率です。

## 実践ポイント
- 汎用的には v4：実装が簡単でプライバシー面でも安心。  
- データベースの主キーや挿入順で性能を気にするなら v7（またはv6）：時系列ソートに強い。  
- 再現可能なIDが欲しいなら v5（名前ベース）。  
- MAC露出や追跡が問題になる場面では v1 を避ける。  
- v8 は拡張ニーズが明確なときのみ検討。互換性とセキュリティ確認を忘れずに。  
- 実装は言語の標準ライブラリや信頼できるライブラリを使い、UUIDの仕様（バージョン・variant）を明確に管理する。  
- 日本の現場では、個人情報保護（APPI）やログ設計を意識して、生成場所（クライアント vs サーバ）や保管方法を決める。

参考に、まずはライブラリでv4とv7を生成してパフォーマンス・索引効果を比較してみてください。
