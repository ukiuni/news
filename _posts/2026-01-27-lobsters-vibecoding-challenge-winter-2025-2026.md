---
layout: post
title: "Lobsters Vibecoding Challenge (Winter 2025-2026) - Lobsters ヴァイブコーディング・チャレンジ（2025–2026年冬）"
date: 2026-01-27T19:47:58.518Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://gist.github.com/MostAwesomeDude/bb8cbfd005a33f5dd262d1f20a63a693"
source_title: "Lobsters Vibecoding Challenge (Winter 2025-2026) · GitHub"
source_id: 1190346351
excerpt: "NixベースでAIに設計・実装させ競う、再現性重視の高速化・静的化チャレンジ"
image: "https://github.githubassets.com/assets/gist-og-image-54fd7dc0713e.png"
---

# Lobsters Vibecoding Challenge (Winter 2025-2026) - Lobsters ヴァイブコーディング・チャレンジ（2025–2026年冬）
AIに「考えさせる」コード勝負——Lobstersの限定チャレンジをわかりやすく解説

## 要約
Lobstersが「vibecoding（チャットエージェントに設計＋実装させる）」で競う技術コンテストを公開。ルールは厳格で、Nixベースのビルド、動作・コンパイル必須、チャットログと参照URLの提出が求められる。課題は主に3つ（Brainfuck高速化、Rakuコンパイラの静的化移植、謎の「高速化」タスク）。

## この記事を読むべき理由
ローカル開発や組み込み向けに「再現可能で安全な」AI支援開発の実務的な課題と評価基準が示されており、日本のOSS開発者やSRE、組み込みエンジニアに直結する示唆が多いから。

## 詳細解説
- 全体ルール
  - 「vibecoded」であること：解答は主にチャットエージェントのプロンプト設計とそのやり取りで生成されたものである必要がある（＝人間の手直しを最小に）。
  - 動作・コンパイル必須：筆者は nix build / nix flake check を基準にするため、Nix flakesに組み込んでビルド可能であることが求められる。
  - 証跡必須：チャットログ、参考にしたURL、所要時間の記録などを提出し、どのドキュメントを参照させたかが採点対象。
  - 可読性とセキュリティも採点される（手抜き不可）。

- 課題1：Brainfuckインタプリタの高速化（Pointer propagation）
  - 現状：rpypkgsのbf.py。目標は抽象表現からポインタ伝播（pointer propagation）へ移してコード生成／実行を速くすること。
  - 技術ポイント：メモリインデックス操作を減らすために「ポインタを直接伝播」させることでループ脱出や境界チェックを減らす。ベンチは bench.b（コード生成）と mandel.b（ランタイム）で計測。
  - 評価指標：ソース行数と速度比較でtier付け（S〜D）。

- 課題2：Rakuプロトコンパイラを静的に（initramfs用途）
  - 現状：Vixen環境用にRakuで書かれた式コンパイラがあるが、静的にリンクしたRaku実行環境が作れない。
  - 技術ポイント：静的リンク可能な言語（例：Rust/Go/Zig/Nim/Crystal等）を選び、パーサー／ASTトランスフォームを移植。重要なのはコンパイル時にVixenを呼ぶ仕組みを保持すること。
  - 難所：静的バイナリ生成、NQP/Raku固有のランタイム依存、既存ツールチェーンとの整合。

- 課題3：未定義の「Pythonで激速に」
  - 概要：作者が意図的に問題を放置した「速くする」課題。RPython（PyPy向けサブセット）などで大幅な高速化を狙うことが想定される。
  - 技術ポイント：アルゴリズム設計＋RPythonコンパイル経路、プロファイリングとホットパスのJIT化が鍵。成果は倍率で評価（例：200,000xがS）。

## 実践ポイント
- まずやること
  - 元Gistを複製してローカルに落とす（Gist URL を保存）。
  - Nix環境を用意し、nix build / nix flake check が通るように最小セットを作る。
  - ベンチ用スクリプト（bench.b, mandel.b）を先に実行して基準値を取得。

- vibecoding運用のコツ
  - プロンプトに参照ドキュメントと自分のNixフレーク構成を全部与える（URLsをログに残す）。
  - チャットエージェントに対するテストスイートを用意して、失敗時にエージェントが原因調査できるようにする。
  - 生成コードは必ず静的解析・簡易監査し、脆弱性や危険なOS操作を除去する。

- 言語選び（課題2の参考）
  - Rust/Zig：静的リンクと低レイヤ制御に向く。パーサーはlalrpop/pest等。
  - Go：静的化は可能だがC依存に注意。パーサーはgoyacc等。
  - Nim/Crystal：Ruby系の表現力を保ちつつネイティブ化可能。
  - 日本の組込みやinitramfs向けなら「静的リンク可能でクロスコンパイルが容易」かを最優先に選ぶ。

- 提出時の必須事項
  - コンパイル済みバイナリのビルド手順、実行ベンチ結果（壁時計時間）、チャットログ、参照URL一覧、使用したNix flake とそのコミット／差分。

短期間で成果を出すなら、まずNixで再現可能なビルドパイプラインを作り、エージェントに与える文脈（コード＋ドキュメント）を厳密に揃えてからプロンプト実験を重ねてください。
