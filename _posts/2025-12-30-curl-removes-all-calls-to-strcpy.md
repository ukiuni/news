---
layout: post
title: "Curl removes all calls to strcpy - strcpyもついに撤去"
date: 2025-12-30T04:14:15.798Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://daniel.haxx.se/blog/2025/12/29/no-strcpy-either/"
source_title: "Curl removes all calls to strcpy"
source_id: 889637932
excerpt: "curlがstrcpyを完全撤去し、サイズ明示の安全な文字列コピーで長期運用の脆弱性を防ぐ実装を導入"
---

# Curl removes all calls to strcpy - strcpyもついに撤去
「strcpy はやめよう」だけでは終わらない――curlが選んだ、安全で長持ちする文字列扱いの設計

## 要約
curl プロジェクトが strncpy に続き strcpy の呼び出しもコードベースから完全に除去し、バッファ境界を明示する新しいコピー関数を導入しました。これにより長期間運用されるソフトウェアで起きがちな「事前チェック」と「コピー処理」の分離による脆弱性リスクを低減します。

## この記事を読むべき理由
- 日本の組み込み系／ネットワーク系開発では C による文字列処理が多く、古い API によるバグが現場で頻出します。  
- 長寿命なソフト（ライブラリ・ファームウェア）を維持する際、将来のメンテでチェックがずれるリスクを避けたい開発者にとって示唆に富む実装方針です。

## 詳細解説
- 問題点の整理  
  - strncpy は「null 終端しない」「余りをゼロパディングする」など挙動が混乱を招きやすく、誤用の温床です。  
  - strcpy は API 自体は単純ですが、コピー前にバッファサイズのチェックを「呼び出し側」に依存するため、後の改変でチェックと実際のコピー処理が離れてしまうと危険です（長くメンテされるコードほどこのリスクが増す）。
- curl の対応策  
  - コピー時にターゲットサイズとソース長を必ず渡す新関数を導入し、コピー処理とサイズチェックを一体化しました。実装は memcpy を使い、必要ならヌル終端を追加します。失敗時はターゲットを空文字にするなど明確な動作を定義しています。  
- 実装例（curl の関数）  
  ```c
  // C
  void curlx_strcopy(char *dest, size_t dsize, const char *src, size_t slen) {
      DEBUGASSERT(slen < dsize);
      if(slen < dsize) {
          memcpy(dest, src, slen);
          dest[slen] = 0;
      } else if(dsize) {
          dest[0] = 0;
      }
  }
  ```
  - ポイントは「サイズ情報を明示する」ことと、「コピー時にヌル終端を保証する」ことです。これによりチェックとコピーが分離される事故を根本的に防げます。
- 副次効果  
  - AI ベースの誤検知（「strcpy があるから危険」的な誤判定）を減らせる一方で、静的に見えない設計の誤りや別の問題に置き換わる可能性は残ります。根本は設計とレビュー体制の改善です。

## 実践ポイント
- 既存コードの置換方針  
  - strcpy/strncpy を見つけたら、ターゲットサイズとソース長を明示してコピーするラッパーに置き換える。  
  - 単純に strlcpy を入れるのではなく、プロジェクトの方針に合わせて失敗時の挙動を定義する（例：空文字化、エラー返却）。  
- 開発ワークフロー改善  
  - コピーに関するチェックはコピー直前で行う（関数化して強制する）。  
  - CI に静的解析とユニットテストを組み込み、サイズ境界の回帰を防ぐ。  
- 日本市場での適用例  
  - 組み込みファームウェア、ルーター、IoT デバイスなど、長期運用される C コードが多い領域で即効性が高い。安全性重視の製品では標準実装に採用する価値あり。

