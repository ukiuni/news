---
layout: post
title: "Communication Protocols"
date: 2025-12-29T15:29:55.211Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.systemdesignbutsimple.com/p/communication-protocols?utm_campaign=email-half-post&amp;r=dfmav&amp;utm_source=substack&amp;utm_medium=email"
source_title: "Communication Protocols - by Stephane Moreau"
source_id: 435413327
excerpt: "現場で使える通信プロトコルの最適選定を短時間で示す実践ガイド"
---

# Communication Protocols
HTTPだけじゃない！現場で差がつく通信プロトコルの選び方 — WebSocket・SSE・gRPC・REST/GraphQLの“勝ち筋”


## 要約
通信要件（双方向性、リアルタイム性、ブラウザ対応、サービス間性能）に応じて、HTTP/REST、WebSocket、SSE、gRPC、GraphQLそれぞれが最適な場面を持つ。設計判断のための実務的な基準を短く整理。

## この記事を読むべき理由
プロダクト要件で「遅延」「接続数」「開発コスト」「運用のしやすさ」が相反する場面は多い。特に日本の企業では既存のHTTPインフラやモバイル中心のユーザーが多く、誤ったプロトコル選定が運用コストやUX悪化につながる。本稿は現場で即使える判断基準と落とし穴を示します。

## 詳細解説
- HTTP（Request/Response）
  - 特徴: 完全にステートレス。リクエスト→レスポンスの単純モデルで人間にも機械にも扱いやすい。
  - 長所: 広い互換性、キャッシュやCDN、既存インフラ活用が容易。
  - 短所: 頻発する小さな更新や双方向通信ではハンドシェイクオーバーヘッドが問題になる。

- WebSocket
  - 特徴: 一度接続を張ると双方向で自由にメッセージを送受信できる。接続は「状態を持つ」。
  - 長所: チャット、共同編集、マルチプレイヤーなど真のリアルタイム双方向に最適。メッセージごとのハンドシェイク不要で低遅延。
  - 短所: 接続管理（接続数、切断／再接続、スケール時のセッション固定）が必要。ロードバランサやPaaSでの制約に注意。

- Server-Sent Events (SSE)
  - 特徴: サーバ→クライアントの一方向ストリーム。HTTP上で動作。
  - 長所: 実装が単純でHTTPインフラに馴染みやすい。通知系やライブフィードに最適。
  - 短所: ブラウザ間の過去の互換性や制限を考慮（現在は主要ブラウザで大半サポート）。双方向が必要な場合は不十分。

- gRPC
  - 特徴: HTTP/2上でProtocol Buffersを使う高速なRPC。厳密な契約（IDL）に基づく。
  - 長所: レイテンシと帯域効率が重要なサービス間通信に最適。自動生成された型安全クライアントが得られる。
  - 短所: ブラウザでのネイティブ対応が乏しく、フロントエンドとの直接通信には工夫（プロキシやgRPC-web）が必要。

- REST vs GraphQL（HTTP上の設計スタイル）
  - REST: シンプルでキャッシュ適合な単純なデータニーズ向け。
  - GraphQL: クライアント毎に取得データが異なる、複数ソースを集約して返すAPIに有効。オーバーフェッチ／アンダーフェッチを解消する一方、キャッシュ設計と複雑度が増す。

- 選定の短い目安
  - サービス間で制御可能なら gRPC。
  - 双方向・低遅延が必須なら WebSocket。
  - サーバ→クライアントの単方向更新なら SSE を先に検討。
  - ブラウザ向け汎用APIは REST（単純）か GraphQL（複雑）で判断。

（日本市場との関連）
- 日本の多くのプロダクトは既存のHTTP/RESTエコシステムやモバイル中心の顧客基盤を持つため、まずはシンプルなHTTPベースで始め、拡張要件が出た段階でWebSocket/SSE/gRPCを導入するハイブリッド運用が現実的。ゲームやチャット、証券系トレーディングなど低遅延が重要な領域ではgRPCやWebSocketの採用が増えている点に注目。

## 実践ポイント
- 要件を明確にする: 「誰が通信を開始するか」「双方向か一方向か」「必要なレイテンシ」「ブラウザ対応の有無」を最初に書き出す。
- ステップ導入: まずはREST/HTTPで MVP → リアルタイム要件が出たら SSE（受信のみ）→ 双方向が必要なら WebSocket に段階移行。
- gRPC採用の前提: 内部マイクロサービスで高速性が必須かつ両端を制御できる場合に限定。ブラウザ向けは gRPC-web / プロキシを検討。
- 運用対策:
  - WebSocketは接続数上限と再接続バックオフ、セッション同期（sticky/session store）を設計。
  - SSEは自動再接続とイベントID管理を実装して欠落を防ぐ。
  - TLSを必須にし、認証は短命トークンやJWTを使ってセッション乗っ取りを防ぐ。
- フォーマット選択: 人間可読性が重要ならJSON、性能重視でサービス間ならProtocol Buffersを検討。
- テストと観測: 負荷テストで同時接続数・メッセージレートを検証し、メトリクス（接続数、再接続率、遅延）を必ず収集する。

以上を踏まえ、まずは要件の可視化（一覧化）→ 小さなPoCで接続管理とスケール挙動を確かめることを推奨します。
