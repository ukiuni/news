---
layout: post
title: "TIL: serde's borrowing can be treacherous"
date: 2025-12-26T18:23:01.797Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://yossarian.net/til/post/serde-s-borrowing-can-be-treacherous/"
source_title: "TIL: serde's borrowing can be treacherous"
source_id: 987195092
excerpt: "serdeのゼロコピー借用はJSONのエスケープで実行時に破綻し、CowやStringで回避せよ"
---

# TIL: serde's borrowing can be treacherous
Serdeの借用は罠になる — JSONで&strを狙うときの致命的な落とし穴


## 要約
serdeで`&'a str`や`&'a [u8]`を使った「ゼロコピー」デシリアライズは、一見安全でも逃れられないケースがあり、コンパイル時でなく実行時にエラーになることがある。

## この記事を読むべき理由
Rustで性能やメモリコピー削減を目的にserdeの借用（zero-copy）を使おうとすると、意図せずランタイムエラーを踏む可能性があります。日本のプロダクトでJSONやYAMLを扱うエンジニアは、実運用データでの罠を事前に知っておくべきです。

## 詳細解説
- 背景: serdeはRustで標準的な（de）シリアライザで、可能な場合は入力バッファを直接参照する「借用」を返してコピーを避けられる機能がある。これが「ゼロコピー」の魅力。
- 問題点: 文字列にエスケープ（例: "\n"）が含まれている場合、デシリアライザはそのエスケープを実際の改行文字にデコードする必要がある。デコードは入力バッファを書き換える（あるいは別バッファにコピーして変換する）処理なので、元の入力をそのまま指す`&str`は返せない。
- なぜコンパイル時に判らないか: serdeは入力の中身を事前に静的に判断できないため、「借用可能かどうか」を型システムで保証できない。結果として、借用を期待する型でコンパイルは通り、実行時にエラー（"expected a borrowed string" 等）が発生する。
- フォーマット依存: JSONではエスケープが一般的なので起きやすい。yaml等のデシリアライザでは借用サポートが限定的な実装もある。

短いコード例（失敗し得るパターン）:
```rust
// rust
use serde::Deserialize;

#[derive(Deserialize)]
struct Example<'a> {
    foo: &'a str,
}
```

対処法として公式に挙げられているのは次の2つ:
1. 完全所有型を使う（`String` 等）。確実で単純。
2. `Cow<'a, str>` と `#[serde(borrow)]` を組み合わせる。借用できれば借用を使い、できなければ所有にフォールバックする。

対処例:
```rust
// rust
use serde::Deserialize;
use std::borrow::Cow;

#[derive(Deserialize)]
struct Example<'a> {
    #[serde(borrow)]
    foo: Cow<'a, str>,
}
```

注意点: `Cow`だけではデフォルトでOwnedが選ばれる実装があるため、`#[serde(borrow)]`が必要になるケースがある（関連: issue #1852）。

## 実践ポイント
- まずは安全優先で`String`を使う。問題があると分かってから最適化する。
- ゼロコピーを狙うなら、入力データの性質（エスケープの有無、使用するデシリアライザの借用サポート）を事前に確認する。
- `Cow<'a, T>`+`#[serde(borrow)]`は、借用可能なケースで性能を取りつつ安全にフォールバックさせる現実的な折衷案。
- 単体テストやフェイルケース（エスケープを含む文字列など）で実行時エラーを確かめる。コンパイルが通っても実行時に壊れる点を忘れない。
- YAMLやその他のフォーマットは借用サポートが限定的な実装が多いので、フォーマット別に挙動を確認する。

