---
layout: post
title: "Evolving Git for the next decade - 次の10年に向けたGitの進化"
date: 2026-02-13T20:21:56.188Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://lwn.net/SubscriberLink/1057561/bddc1e61152fadf6/"
source_title: "Evolving Git for the next decade [LWN.net]"
source_id: 1165612329
excerpt: "GitがSHA-256・reftables・大容量バイナリ対応で次の10年に備える移行戦略とは?"
---

# Evolving Git for the next decade - 次の10年に向けたGitの進化
破産寸前じゃない、でも放置できない──Gitが「SHA‑1卒業」「reftables採用」「大容量バイナリ対応」で大きく変わる理由

## 要約
FOSDEMでの発表をもとに、Gitは20年を経てSHA‑1からの移行、参照管理のreftables導入、大容量バイナリ対応（promisors＋プラガブルDB）などで次の10年に備えることが示された。

## この記事を読むべき理由
日本企業・OSS現場でも大規模リポジトリや組織ポリシー（SHA‑1廃止期限など）が現実問題になっているため、今から対応方針を押さえておくことが運用負荷やセキュリティリスク回避に直結します。

## 詳細解説
- SHA‑256移行: GitはオブジェクトIDにSHA‑1を使ってきたが、衝突攻撃の現実化と政府・企業の廃止要件によりSHA‑256対応が進行中。Git本体は2020年にSHA‑256対応を入れたが、フォージや周辺ツールの対応が遅く「鶏と卵」状態。Git 3.0で新規リポジトリのデフォルトをSHA‑256にする方針で、フォージ側の対応が促される見込み。
- reftables（参照テーブル）: 現状の「refsをファイルで管理→packed‑refsで対処」はスケールやファイルシステム制約（大文字小文字問題、IO/容量、同時性）で限界。reftablesはバイナリ化された参照テーブルで原子更新や名前制限緩和、大規模な参照数を効率的に扱える。これも3.0でデフォルト化予定。
- 大容量バイナリ対策: バイナリや巨大履歴は圧縮効率が悪く、クローン全体取得や再開不能な転送で運用コストが高い。対策として（1）large‑object promisors：大きなblobを別リモート（S3/CDN等）に置ける仕組み（プロトコル実装は2.50/2.52で進展）と（2）pluggable object databases：バイナリ向けの格納形式を差し替えられる仕組み（2.53で統一DBインターフェース、2.54でPoC予定）の並行開発が進む。
- UI改善の必要性: コマンドやワークフローの混乱に対し、Jujutsuのような競合が示す設計見直し圧力がある。操作性改善は導入障壁低下につながる。

## 実践ポイント
- すぐやること:
  - 自分の主要フォージ（GitHub/GitLab/社内Forge）にSHA‑256対応状況を問い合わせ、優先度を上げるよう声をあげる。
  - スクリプトやサーバー側でrefsファイルを直接参照しているなら、必ずgitコマンド経由に切り替える（reftablesで破壊的な挙動が出る可能性あり）。
- 中期対応:
  - 新規プロジェクトでSHA‑256を試す（ローカル／テスト用リポジトリで導入検証）。
  - 大きなバイナリを扱うプロジェクトはpartial cloneやGit LFSに加え、promisorの導入計画やS3等外部配信の検討を始める。
  - 運用チームはGitのバージョン（2.50〜2.54以降）のリリースノートを追い、移行スケジュールを作る。
- 貢献の呼びかけ:
  - ツール／ライブラリ保守者はlibgit2/go‑git等のSHA‑256・promisor対応を優先的に実装・テストすることで、エコシステム移行を促進できる。

短くまとめると、Gitは「互換性を壊さずに進化」する段階に入りました。運用側は今から準備し、フォージ運営者やツールチェーンに対応を促すことが重要です。
