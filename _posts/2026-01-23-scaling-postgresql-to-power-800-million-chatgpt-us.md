---
layout: post
title: "Scaling PostgreSQL to power 800 million ChatGPT users - PostgreSQLをスケールして8億ユーザーのChatGPTを支える"
date: 2026-01-23T18:14:50.435Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://openai.com/index/scaling-postgresql/"
source_title: "Scaling PostgreSQL to power 800 million ChatGPT users - OpenAI Engineering Blog"
source_id: 419400918
excerpt: "単一プライマリ＋50レプリカで8億ユーザー負荷を支えたPostgres運用の実践知"
---

# Scaling PostgreSQL to power 800 million ChatGPT users - PostgreSQLをスケールして8億ユーザーのChatGPTを支える
ChatGPT規模を支えた「Postgres1台＋50レプリカ」の舞台裏：単一プライマリ設計を限界まで伸ばした技術と実運用の工夫

## 要約
OpenAIは単一プライマリのAzure PostgreSQLに約50のリードレプリカを組み合わせ、徹底したチューニングとアーキテクチャ変更で数百万QPS級の読み取り負荷をさばけるようにした。書き込み負荷は段階的にシャーディングへ移行し、障害やスパイクに耐える仕組みを整備している。

## この記事を読むべき理由
日本のプロダクト／SaaS運用者やクラウドエンジニアにとって、AIや大規模トラフィック時代のDB運用知見（プライマリ集中設計の限界とそれを回避する実践）はすぐに参考になる。特にAzureやマネージドPostgresを使う現場では直接応用できるノウハウが多い。

## 詳細解説
- 単一プライマリ設計と課題  
  - OpenAIは書き込みを1台に集約したまま、読み取りを大規模なレプリカ群へオフロードする設計を選択。利点はアプリ側の大幅な改修を避けられることだが、プライマリがボトルネックや単一障害点になりやすい。  
  - PostgreSQLのMVCCは読み取り効率に優れるが、更新が多いと行コピーによる書込増幅・インデックス肥大・VACUUM調整の複雑化を招く。

- 書き込み対策と移行方針  
  - シャーディング可能な書き込み負荷はAzure Cosmos DBなどのシャーディング向けストアへ段階的に移行。新規ワークロードはデフォルトでシャード先に振る運用に変更。  
  - アプリ側の無駄な書き込み修正、遅延書き込み（lazy write）、バックフィル時のレート制限などでプライマリへの瞬間負荷を平滑化。

- クエリ最適化とORM運用  
  - 多テーブル結合（例：12テーブル結合）のような高コストクエリがCPUを枯渇させるため、可能な限り結合を避け、必要ならアプリ側で集約処理へ移す。ORMが自動生成するSQLは常にレビューする。  
  - 長時間放置トランザクション対策にidle_in_transaction_session_timeout等のタイムアウト設定を有効化。

- 可用性とフェイルオーバー  
  - プライマリはHAモード＋ホットスタンバイで即時昇格可能に。リードレプリカは各リージョンへ複数配置して冗長性を確保。  
  - 読み専用リクエストをレプリカに集約することで、プライマリ障害時でも読み取りサービスは維持可能にする運用。

- レプリカとレプリケーション設計  
  - プライマリはWALを全レプリカに送る必要があるため、レプリカ数が増えるとプライマリのネットワーク／CPU負荷が増大。これを解決するためにカスケードレプリケーション（中継レプリカによる下流配布）を導入検証中。

- コネクションプーリングとレイテンシ最適化  
  - PgBouncerでstatement/transaction poolingを運用、接続確立コストを大幅削減。リージョン単位でプロキシ・クライアント・レプリカを共置しネットワーク時間を削る。アイドルタイムアウト等の細かい調整が重要。

- キャッシュ設計とキャッシュミス対策  
  - キャッシュミスの同時多発がDBを直撃するため、キャッシュロック／リース機構を導入。1キーにつき1リクエスタだけがDBを叩き、他は待機してキャッシュ復帰を待つ。

- ワークロード分離とレート制御  
  - 「ノイジーネイバー」を避けるため高優先度／低優先度でインスタンスを分離。アプリ／接続プーラ／プロキシ／クエリレベルで多層レートリミットを実装し、リトライ爆発を防ぐ。ORM層で特定クエリのブロックも可能に。

- スキーマ変更運用  
  - 列型変更などが全テーブル書き換えを引き起こすため、軽量なスキーマ変更のみ許可し厳格なタイムアウトと手順を設定。

## 実践ポイント
- まず読み取りをレプリカにオフロード：読み専用パスを明確に分けるだけで主DB負荷が劇的に下がる。  
- PgBouncerを導入し、ステートメント/トランザクションプーリングで接続数を抑える。  
- 高コストクエリ（大規模JOIN）はログで検出して分割／アプリ移譲を検討。ORM生成SQLは必ず監査。  
- キャッシュミス対策にキャッシュロックを実装し、同時ミスによるDBスパイクを防ぐ。  
- 書き込みの多い機能は最初からシャーディング／別ストアへ設計する（後付けシャード化は高コスト）。  
- リードレプリカの拡張を考えるならカスケードレプリケーションやフェイルオーバー運用を事前に検証する。  
- 日本の現場ではAzureのリージョン配置、データ主権、コスト試算を含めて設計判断を行うこと。

以上はOpenAIの設計哲学と具体的運用から抽出した要点で、日本のサービス運用にも直接応用しやすい実践知です。
