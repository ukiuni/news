---
  layout: post
  title: "Enterprise Integration Patterns: The Routing Slip - ルーティングスリップ（メッセージが経路を携行するパターン）"
  date: 2026-01-03T23:16:15.206Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://james-carr.org/posts/2025-01-02-advent-of-eip-day-9-routing-slip/"
  source_title: "🎄 Advent of EIP Day 9: Routing Slip"
  source_id: 897696305
  excerpt: "メッセージが経路と処理履歴を携行し可変ルートを実現する実務向けパターン"
  image: "https://cdn.zappy.app/aa0a9a6972191581ff134f3922cc5bfd.png"
---

# Enterprise Integration Patterns: The Routing Slip - ルーティングスリップ（メッセージが経路を携行するパターン）
メッセージ自体が「どこへ何をするか」を持つ――Routing Slipで可変ルートを直感的に実現する方法

## 要約
Routing Slipはメッセージが自身の処理経路（イテナラリ）を持ち、各ノードが自分を消化して次へ送ることで、可変なワークフローを実現するパターンです。運用可視化と疎結合を両立しつつ、実装はメッセージフォーマットと小さな送受信ロジックで済みます。

## この記事を読むべき理由
日本でもマイクロサービス、イベント駆動設計、クラウドサービス（RabbitMQ／Kafka／SQS等）を使った分散処理が増えています。受注処理や与信、物流連携など「条件で処理経路が変わる」「監査／トレーサビリティが必要」なユースケースが多い日本市場で、Routing Slipは実務的に有効な選択肢になります。

## 詳細解説
- 概念  
  - ルーティングスリップはメッセージに routing_slip（＝処理ノード名のリスト）と visited（処理履歴）を含める。受け取ったノードは自身を visited に追加し、routing_slip から自分をポップして、次の宛先へ送信する。  
  - これにより、どのメッセージがどの順で何を通ったかがメッセージ自身に残り、後追い調査や監査が容易になる。

- 実装パターン（記事のデモが示す2系統）  
  1. アプリ内プロセス（例：Elixir の GenServer）  
     - 各ノードを動的に生成（DynamicSupervisor + Registry）して名前で発見。PubSub を使って UI にリアルタイム通知。メッセージはプロセス間で直接転送。軽量でローカル開発／デバッグがしやすい。  
  2. メッセージブローカー経由（例：RabbitMQ）  
     - ノードごとにキューを用意し、トピック交換でバインド。メッセージは routing_slip の次のキーに従って送られる。イベント用のファンアウト交換を別に設け、処理状況を UI に通知する（メッセージとイベントを切り分ける設計）。

- オーケストレーション vs コレオグラフィー  
  - コレオグラフィー：各サービスが自律的に次を発行 → 独立性は高いが、経路変更時に複数サービスを修正する必要がある。  
  - オーケストレーション：中央がフローを管理 → 見通し良しだが単一障害点や強結合の懸念。  
  - Routing Slip は「起点（プロデューサ）が経路を定義するオーケストレーション的発想」を持ちつつ、実行は各ノードの分散処理で行うため、両者の中間点として有効。

- 適用に向く場面と限界  
  - 向く場面：可変経路、監査ログが必要、プロデューサーがワークフローを知れる場合。  
  - 限界：長時間待ちや複雑な分岐・補償が必要な場合は Saga やフル機能の Process Manager の方が適切。失敗時の補償や永続化設計も別途必要。

## 実践ポイント
- まずは小さなPoCを構築する：RabbitMQ/Kafkaの簡単なトピックと1〜3ノードで動作を確認する。  
- メッセージ設計（最低構造）：
  - id（相関ID）、payload、routing_slip: [nodeA, nodeB, ...]、visited: []  
- 各プロセッサは必ず冪等（idempotent）に設計する。再配信やリトライで二重処理を避けるため。  
- UI/監査用に「イベント」チャネルを用意する：処理結果をイベント（fanout）として投げ、ダッシュボードやログ集約に流す。  
- ルーティングスリップは発行元で検証する（悪意ある経路指定や過度に長い経路を防ぐ）。  
- 長期ワークフローや補償が必要なら Saga／Process Manager の導入を検討する。Routing Slipは短〜中期の直列ワークフローに特に有効。  
- インフラ抽象化（Messenger層）を作る：RabbitMQ/Kafka/SQS を差し替えられるようにしておくと運用で楽になる。  
- 日本の現場では「トレーサビリティ」「監査ログ」「外部システム連携」が重要になるので、visited の内容やタイムスタンプを詳細に残す設計が有益。

Routing Slipは「メッセージが自分の行程を持つ」という単純な発想ながら、運用性と拡張性のバランスが良い実践的パターンです。まずは小さな実験から導入を検討してみてください。
