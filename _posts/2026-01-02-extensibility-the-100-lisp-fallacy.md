---
  layout: post
  title: "Extensibility: The \"100% Lisp\" Fallacy - 「100% Lisp」の誤謬"
  date: 2026-01-02T03:12:36.302Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://kyo.iroiro.party/en/posts/100-percent-lisp/"
  source_title: "Extensibility: The \"100% Lisp\" Fallacy | Kyou is kyou is kyou is kyou"
  source_id: 46460394
  excerpt: "Lisp万能論を撃破、IMEやフォントなど日本語特有の拡張課題を具体的に示す"
---

# Extensibility: The "100% Lisp" Fallacy - 「100% Lisp」の誤謬
「Lispで書けば何でも拡張できる」は本当か？――エディタ拡張の現実と、日本で気をつけるべきポイント

## 要約
「エディタが“100% Lisp”なら全てが拡張可能」という主張は単純化しすぎ。OSやGUI、入力メソッド、アクセシビリティなどの非可搬な部分が必ず残り、真の拡張性は設計力と努力で決まる。

## この記事を読むべき理由
日本では日本語入力（IME）やフォント、文字エンコーディング、アクセシビリティ要件が強く影響するため、「純粋言語で書かれている＝伸ばし放題」だと信じると痛い目を見る。エディタやツールを選ぶ・作る際の現実的な判断材料が得られる。

## 詳細解説
- 100%純粋という幻想  
  多くの「Lispで全部書いた」主張も、スレッド処理やOS連携、低レイヤのI/O、プラットフォーム固有APIはCやアセンブリ、ネイティブライブラリに頼る。GUI周り（フォントフォールバック、入力メソッド、スクリーンリーダー）はプラットフォーム依存で、Lispだけで完全にカバーするのは現実的でない。

- FFIとワークアラウンドの役割  
  外部ライブラリやプロセスをつなぐFFIやIPCで多くの拡張は可能になる。たとえばネオビムのスクロール表示を仮想テキストで実装するように、いったん別レイヤで機能を実現して「見せる」方法がある。EmacsではPython＋PyQtでウィンドウを重ねてアニメーションを実現する例もある。

- 拡張性のコストと副作用（“spacebar heating”）  
  全てを公開して自由に書けると、内部APIに寄生するパッチが増え、互換性が壊れやすくなる。Emacsの内部関数名にある「--」（ダブルダッシュ）は内部実装の示唆で、そこを弄ると将来の更新で壊れるリスクが高い。el-patch のように深いパッチを当てる手段はあるが、メンテナンス負荷は大きい。

- 拡張性は設計の賜物  
  真の拡張性は言語よりもAPI設計、プラグイン・フックの用意、ドキュメント、互換保証に依存する。言語がLispでも、拡張用のインターフェースを用意していなければユーザーは苦労する。

## 日本市場との関連
- 日本語特有の課題：IME（Mozc/Anthy/ATOKなど）との連携、縦書きや合字、CJKフォントのフォールバック、改行やファイルエンコーディングの扱いは日本語ユーザーにとって致命的なUX要因。エディタ設計時に最初から考慮しないと「拡張でなんとかなる」問題では済まない。
- アクセシビリティ：スクリーンリーダーや音声入力のサポートも地域ごとの実装差が大きく、プラットフォームAPI依存が強い点は日本の企業や省庁案件で重要。
- コミュニティとメンテナンス：RacketやEmacsの例が示す通り、低レイヤを移行すると貢献者の裾野が変わる。日本での採用・貢献を狙うなら、手を入れやすいインターフェースが重要。

## 実践ポイント
- まず境界を決める：どこまでを言語側（例：Lisp）で賄い、どこをネイティブAPIへ委ねるかを明確にする。
- 拡張ポイントを設計する：公開API、フック、イベント、安定したIPCプロトコルを先に用意する。
- 日本語入力・表示を優先課題に：IME連携やフォント処理は早期に評価・実装し、拡張で後付けしない。
- ドキュメントと互換性ポリシーを用意する：内部関数を弄らせないガイドラインや、el-patch型のパッチ管理手法を提供する。
- テストと自動検証：パッチや外部拡張が壊れないようにCIで互換性テストを回す。
- 代替手段を受け入れる：どうしてもネイティブにアクセスできない機能は外部プロセスやウィンドウ重ね合わせで実現するワークアラウンドを設計に組み込む。

（参考になる簡単なElisp拡張の例）
```elisp
;; elisp
;; 関数にアドバイスを追加して振る舞いを変える（単純例）
(advice-add #'target-function :around
            (lambda (orig &rest args)
              ;; 前処理
              (apply orig args)
              ;; 後処理
              ))
```

