---
layout: post
title: "Unix \"find\" expressions compiled to bytecode"
date: 2025-12-26T15:28:12.981Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://nullprogram.com/blog/2025/12/23/"
source_title: "Unix \"find\" expressions compiled to bytecode"
source_id: 46391448
excerpt: "find式をバイトコード化して大規模ファイル走査を劇的に高速化する方法"
---

# Unix \"find\" expressions compiled to bytecode
[Unix findを“バイトコード化”して高速化する技法 — nullprogram流コンパイラ設計]


## 要約
Unixのfindの式を事前にバイトコードへコンパイルし、ファイルごとの評価コストを極小化する手法を解説する。実装の要点と実用上の注意（短絡評価・正規表現の遅延コンパイルなど）を実例ベースでまとめた。

## この記事を読むべき理由
大量のファイルツリーを走査する処理は日本の開発現場（CI、ビルドサーバ、組み込み機器、巨大リポジトリ）でも頻出。毎ファイルの評価コストを下げる設計は実用的で、独自ツールや既存ツール改善に直結する知見が得られる。

## 詳細解説
- 問題意識  
  findは式言語（-name, -type, -print, -exec, 論理演算子 -a/-o/! 等）で大量ファイルへ同一式を適用する。各ファイルで高コストなパースや評価が繰り返されるのを避けるため、式を事前にコンパイルして評価コストを最小化するのが狙い。

- バイトコード設計（要点）  
  nullprogramの提案は「1ビットレジスタ」を持つ単一レジスタ機械。主要な命令は次の5つ：
  - halt：終了
  - not：レジスタを反転
  - braf LABEL：レジスタが偽ならラベルへ分岐（branch if false）
  - brat LABEL：レジスタが真ならラベルへ分岐（branch if true）
  - action NAME [ARGS...]：各findアクション（-name, -print, -type…）を実行してレジスタを設定

  これにより、-a（AND）や -o（OR）の短絡評価は分岐命令で表現され、評価は単純な前向きジャンプのみでループが不要（findはチューリング完全ではない）となる。

- 実装上の工夫と落とし穴  
  - アクションは可能な限り事前に解決（例えば定数パターンやタイプチェックなど）しておき、実ファイルの処理は最小限の関数呼び出しで済ませる。  
  - 正規表現のコンパイルは高コスト。GNU/BSD/BusyBox実装では式の構築時に正規表現を即座にコンパイルしてしまい、実行時に評価されない枝でもエラーを出す例がある。これに対し「遅延コンパイル（lazy compile）」にすれば、正規表現が実際に使われたときのみコンパイルするため、誤ったパターンが無駄に失敗を引き起こすのを避けられる。  
  - 実世界では各アクションごとに専用opcodeを割り当てる設計が現実的。パーサが全アクションの処理を理解して初めて正しいバイトコードを生成できる。

- パフォーマンス面の効果  
  事前コンパイルにより「1ファイルあたりのオーバーヘッド＝バイトコードの1歩分の評価＋アクション呼び出し」に削減でき、大量ファイルでの総コストが大きく改善される。加えて、単純な命令列はpeephole最適化が効きやすく、さらに高速化可能。

- 実装例とデモ  
  著者は findc（find compiler）を作成し、Wasmで動くオンラインデモや、後に追加したpeephole最適化を公開している（実装は最新のCコンパイラが必要な部分あり）。

## 実践ポイント
- 自分のユースケースで「式の再利用」が多いなら、式をパースしてバイトコード化する設計を検討する（CIや大規模リポジトリ検索で有効）。  
- 正規表現や重いリテラルは遅延コンパイルを採用する：実際に右辺が評価される時点で初回コンパイルする。  
- アクションごとに明確なAPI（opcode）を用意し、ファイル評価ループを極力シンプルに保つ。これが性能と保守性の両立に効く。  
- 実装のテスト：短絡評価が正しく働くか（-o/-aの優先度、!の動作）、ラベルジャンプが安全に前方のみかをユニットテストで検証する。  
- ツール連携案：fd や ripgrep 的な高速ファイルツールに「式コンパイル」層を入れることで、複雑なフィルタを高速に適用できる可能性が高い。

