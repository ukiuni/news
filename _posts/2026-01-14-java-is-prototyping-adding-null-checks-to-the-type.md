---
layout: post
title: "Java is prototyping adding null checks to the type system! - Javaが型システムにnullチェックをプロトタイピングで追加中！"
date: 2026-01-14T02:27:56.927Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://mail.openjdk.org/pipermail/valhalla-spec-experts/2026-January/002554.html"
source_title: "Prototyping null checks"
source_id: 427497055
excerpt: "Javaが型に「!」を導入、実行時null保証でバグ激減を狙う新プロトタイプ"
---

# Java is prototyping adding null checks to the type system! - Javaが型システムにnullチェックをプロトタイピングで追加中！
Javaに「!」が来る――実行時でnullを型に紐づけて安全にする新プロトタイプ

## 要約
Javaの開発チームが、型に「!」マーカーを付けて実行時に非nullを保証するプロトタイプ（bworldブランチ）を公開しました。コンパイラとJVMが協調して、キャスト・代入・配列・フィールド・メソッドの入出力でnullチェックを挿入します。

## この記事を読むべき理由
- Javaは依然として日本のサーバーサイドや企業システムで圧倒的に使われており、null周りのバグは依然として大きな障害です。  
- 型に「非null」を明示する仕組みが実行時まで持ち込まれれば、バグ検出と最適化の両面で恩恵が見込めます。ライブラリ設計や既存コードの互換性対応を考える必要があるため、早めに動向を把握しておきましょう。

## 詳細解説
- 「!」マーカーの目的  
  型に「!」を付けると、その場所では非nullであることを保証するためのランタイム・バリア（チェック）が入ります。これはまだコンパイル時だけの厳密チェックを目指す段階ではなく、まずは実行時の振る舞いをプロトタイプで確かめるための機構です。

- 適用可能な箇所（例）  
  フィールド（recordコンポーネント含む）、ローカル変数宣言、メソッド引数・戻り値、catchの例外パラメータ、cast/instanceofのターゲット、配列生成の要素型（配列型そのものの要素型は別扱い）など。var宣言は自動的に「!」とは扱われません。

- コンパイラの挙動（javac）  
  特定の箇所で java.lang.runtime.Checks API を呼び出す形でnullアサーションを挿入します。コンパイラが値が非nullであることを証明できればチェックは省略可能です。キャスト時はクラスチェックに加えてnullチェックも入ります。

- フィールドと初期化ポリシー  
  「!」付きフィールドはクラスファイルで ACC_NULL_CHECKED 相当のフラグが付与され、JVM側で書き込み時のnull検査を行います（現状は値クラス（Valhalla系）のフィールドのみ実行時サポート）。静的フィールドは必ず初期化が必要、インスタンスフィールドは super() の前までにセットする必要がある、など既存のコンストラクタ設計に影響します。

- メソッド入出力と配列  
  メソッドエントリで引数に対するチェック、戻り値が「!」ならreturn時にチェック。要素型に「!」が付いた配列はnull書き込みを拒否するnull-checked配列として生成されます（現状は値クラス配列のみ実装）。配列初期化の使い勝手向上も今後検討されています。

- 実験的オプション（lintや挙動選択）  
  nullリテラルを「!」に代入したときの警告、オーバーライドでスーパーメソッドの「!」を外すときの警告、バイナリ互換性の問題に対する「使用側チェック（use-site checks）」の挿入など、複数の動作を切り替えて試す設計になっています。配列生成は静的ファクトリかindyブートストラップかなど複数案を検証中です。

- 現状はスナップショット  
  bworldブランチはプロトタイプであり、仕様草案や最終形とは異なる点が多数あります。ジェネリクスや「?」（nullable）マーカーに関するコンパイル時解析は今回のプロトタイプでは後回しにされています。

## 実践ポイント
- 小さな実験から始める：bworldブランチをチェックアウトして、ローカルでビルド／簡単なコードで挙動を確かめる（IDEやビルドツールの対応状況も同時に確認する）。  
- ライブラリ/フレームワークの互換性を確認：公開APIに「!」を導入すると、サブクラスや既存のバイナリ互換性に影響する可能性がある。オーバーライドやリフレクション、シリアライズ周りは特に注意。  
- コンストラクタと初期化パターンの見直し：インスタンスフィールドの早期初期化が要求されるため、継承ツリーや初期化ロジックを整理しておくと移行が楽になる。  
- テストで「失敗するべきnull」を作る：単体テストでnullを書き込んだ時の動作を明示的に検証し、警告や挙動の違いを把握しておく。  
- 業務影響の評価：大規模コードベースでは、静的解析・リファクタリング計画と合わせて段階的に導入検討する。SpringやJakarta系フレームワークへの影響も事前評価を。  
- パフォーマンスを計測する：実行時チェックのオーバーヘッドと、チェックが省略される最適化の効果を実測して判断する。

結論：今回のプロトタイプは「型に非nullを明示して実行時に強く守る」ための第一歩です。日本の現場でも早めに挙動を試し、ライブラリ設計や初期化パターンの整備を進めることで、将来的な移行コストを下げられます。興味がある方はbwoldブランチの動向を追い、身近なコードで小規模な実験を始めてください。
