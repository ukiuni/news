---
layout: post
title: "What Functional Programmers Get Wrong About Systems - 関数型プログラマがシステムについて見落としていること"
date: 2026-02-10T01:21:21.684Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.iankduncan.com/engineering/2026-02-09-what-functional-programmers-get-wrong-about-systems/"
source_title: "What Functional Programmers Get Wrong About Systems - Ian Duncan"
source_id: 46953491
excerpt: "静的型だけで安心できない実運用課題と、分散システムで必須の互換・マイグレーション手順を具体的に示す"
image: "https://iankduncan.com/portrait.jpg"
---

# What Functional Programmers Get Wrong About Systems - 関数型プログラマがシステムについて見落としていること
タイプや不変性で安心してない？実運用では「プログラムの正しさ」と「システムの正しさ」は別物です

## 要約
静的型や代数的データ型はプログラム単体の正しさを強力に保証するが、実運用で起きる不具合の多くは「複数バージョンが混在する分散システム」の相互作用に由来するため、型だけでは防げない。

## この記事を読むべき理由
日本の多くのプロダクト（クラウドサービス、マイクロサービス、KafkaやSQSを使うシステム）は、開発者が想像するより早く「分散化」し、型で解決できない運用課題に直面する。現場でのデプロイ、スキーマ変更、メッセージ永続化で実際に必要な対策を知るために読む価値がある。

## 詳細解説
- プログラム vs システム：関数型のツールは「単一アーティファクト（ひとつのバイナリ／バージョン）」の整合性を厳密にするが、実運用は複数のデプロイや古いワーカー、外部サービス、キュー内の古いメッセージなどが同時に存在する集合体（システム）として動く。バグの多くは要素間の相互作用に現れる。
- 複数バージョンの共存：ローリングデプロイやカナリアで旧版と新版が同時稼働する時間窓があり、その間の互換性を設計しないと、あるバージョンが未知の列挙子やフィールドを受け取って落ちる（ex. 新しい列挙値を旧コードが解析できない）。
- スキーマとマイグレーションの非対称性：コードはロールバックできてもデータ（ALTER TABLEや公開したイベント）は後戻りできない。安全な手順（expand-and-contract：nullable追加 → 両方書く → backfill → 新カラム読む → 旧カラム削除）を複数デプロイに分けて進める必要がある。
- BEAM/Erlangの教訓：Erlangはランタイムで最大2バージョンを扱う設計（state migration hook）で、互換性検討領域を有限に保つ。多くの設計は「隣接バージョンのみ互換であればよい」という制約に帰着する。
- メッセージ永続化（Kafka等）：Kafkaは長期保持により過去の多くのシリアライズ形式を現行コードが扱う必要が出る。トピックの保持期間＝互換性ウィンドウであり、無限保持は過去すべてに互換であることを要求する。対策はスキーマレジストリ、後方互換を保証するフォーマット（Protobuf等）、保持期間の意図的な設定。
- 理論的限界と現実的道具：動的ソフトウェア更新の一般的有効性は決定不能だが、実務ではドメイン固有ルール・リント・マイグレーションツール（gh-ost、アルタナティブのマイグレーションリンター等）で十分に対処できるケースが多い。

## 実践ポイント
- デプロイは「セット」で考える：ローリング／カナリア中の混在状態をテストする（混在環境でのSLA/ログ監視）。
- スキーマ変更は expand → backfill → contract の手順で複数デプロイに分ける。DROPは最後まで待つ。
- メッセージ保持は互換性政策：Kafkaの保持日数は「互換性負担」を意味する。スキーマレジストリを導入し互換性チェックを自動化する。
- シリアライズ設計は後方互換（numeric tags、optional fields）を優先する（ProtobufやAvro等）。
- 古いイベント／メッセージを解釈できるようにプロジェクションやリーダーを堅牢化する（フォールバックロジック、バージョン付きデシリアライズ）。
- 混在バージョンを意図的に「2バージョン以内」に束ねる運用ルール（デプロイ時間短縮、hot-upgrade制約）を検討する。

短く言えば、型や不変性は強力だが「運用中のシステム全体」を見る視点と手順を持たないと現場の障害は防げない。
