---
layout: post
title: "The largest number representable in 64 bits - 64ビットで表現可能な最大の数"
date: 2026-02-02T20:25:33.862Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://tromp.github.io/blog/2026/01/28/largest-number-revised"
source_title: "The largest number representable in 64 bits"
source_id: 46859443
excerpt: "64ビットのコードでGraham数をはるかに超える天文学的数が記述可能だと示す解説"
---

# The largest number representable in 64 bits - 64ビットで表現可能な最大の数
64ビットで「データ型の限界」を超える――わずか数バイトのプログラムで作れる“天文学的”な数の話

## 要約
普通は最大値を $2^{64}-1$ と答えるが、表現方法を「64ビット以内のプログラム」に拡張すると、チューリングマシンの Busy Beaver やラムダ計算の巧妙な短い項によって Graham数をはるかに超える数がわずか数十ビットで記述できる。

## この記事を読むべき理由
データ型の「最大値」概念を超えて、言語や表現形式が情報量当たりに生み出せる「巨大さ」をどのように変えるかが分かる。理論計算機科学や圧縮／表現力の直感を深めたいエンジニアに有益。

## 詳細解説
- 常識的な最大値：整数型なら無符号64ビットの最大は $2^{64}-1$、倍精度浮動小数点の有限最大はおおむね $2^{1024}(1-2^{-53})\approx1.8\times10^{308}$。  
- プログラムを表現手段とする発想：表現対象を「64ビット以内に収まるプログラム」とすれば、出力される数はデータ型に依存しない桁外れの大きさになり得る。例えば bc のような任意精度電卓なら短い入力で巨大なべき乗を表せる。  
- Busy Beaver（BB）：n状態のチューリングマシンが停止するまでに踏む最大ステップ数を BB(n) とする。TM の状態数をビット数にエンコードすると、有限ビットで記述可能な TM が生成する最大値は BB によって爆発的に大きくなる。特に BB(6) は既知の下限が天文学的で、完全確定は難しい（未解決の「暗黒領域」が残る）。  
- ラムダ計算の威力：ラムダ計算は表現力に優れ、短い項で極めて巨大な Church 数（関数反復を数として扱う表現）を生成できる。実際、49ビットのバイナリラムダ計算項（Melo と名付けられた項）は Graham 数を超えることが証明されている。さらに 61 ビット級の改良項（w218 など）は Melo を遥かに上回るサイズを生む。  
- 表現効率の比較：ビット単位で見ると、ラムダ項（BBλ と呼ばれる関数的 Busy Beaver）は同じビット数で Turing マシンよりずっと大きな関数値を達成しやすい。BBλ(n) はサイズ n の閉ラムダ項が生成できる最大出力（正規形の大きさ）を表し、ビット単位での「最強表現力」を評価する指標になる。  
- 理論的道具：これらの比較には Knuth の上矢印、Fast-growing hierarchy（急成長階層）、Church 数表現などが用いられ、短いプログラムがどのように巨視的な反復を組み立てるかが数学的に示される。

## 実践ポイント
- 「最大値＝2^{64}-1」の常識は実装上は正しいが、表現の自由度を考えると別の“最大”が存在することを理解する。  
- Busy Beaver やラムダ計算は計算可能性・証明論の直観を鍛える良い教材。入門は簡単な TM シミュレータ、Binary Lambda Calculus、Church 数の実装から。  
- 実務で数を扱う際は「表現形式」と「計算可能性（時間・メモリ）」を区別すること。理論的に表現可能でも実際に評価できない（非停止や天文学的時間）場合が多い。
