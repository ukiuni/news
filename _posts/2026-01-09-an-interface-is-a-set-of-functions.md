---
layout: post
title: "An Interface Is a Set of Functions - インターフェースは関数の集合である"
date: 2026-01-09T17:54:41.232Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://codestyleandtaste.com/interface-is-a-set.html"
source_title: "An Interface Is a Set of Functions"
source_id: 467037190
excerpt: "インターフェースを置換性でなく仕事をさせる関数群として最小限に設計する実践ガイド"
---

# An Interface Is a Set of Functions - インターフェースは関数の集合である
使い道は「抽象化」じゃない。インターフェースを「仕事をさせるための関数群」として設計する発想

## 要約
インターフェースは「何かの振る舞いを抽象化するための約束」ではなく、異なる実装に対して共通の操作（関数群）で仕事を進めるための道具だ、という視点を紹介する記事です。

## この記事を読むべき理由
多くの日本の開発現場（組み込み、サーバ、デスクトップツールや業務アプリ）で「インターフェース＝置き換え可能な抽象」と考えられがちですが、実際には「知らない型に対して仕事をさせる」ために最小限の関数だけを約束する設計が有効な場面が多いです。初心者でも理解しやすい実例（入出力、スレッド間メッセージ、データ駆動コマンド）でその考え方を学べます。

## 詳細解説
この記事の主張は単純です：インターフェースは「関数の集合」であり、それ以上でも以下でもない。ここでは3種類の実例を使って説明します。

- IOインターフェース（IOSource / IOSink）  
  IOSinkは write と flush のような基本的な関数を提供しますが、実装は多様です。何もしない NullSink、メモリ上で加工する Compress、ファイルに書く FileWriter、ソケットに送る TCPSocket――見かけ上同じ write/flush を持っていても、目的や副作用は全く異なります。重要なのは「write と flush が呼べる」ことだけで、置き換えられることを約束するわけではありません。実務では MemoryBuffer（バッファポリシーで改行時フラッシュやページ超過でフラッシュなどを選べる）を差し込んで、デバッグ時に標準出力へ途中結果を流すテクニックが便利です。

- メッセージインターフェース（スレッド間通信）  
  メッセージは WorkResult work(ContextVariant context) のような単純な関数だけで表現され、戻り値でキュー内の扱い（More, Finished, Destroy）を決めます。各スレッドは独自の context 型を持ち、メッセージ自体は型や中身を知られずにキューで運ばれます。これによりIO→ワーカー→メインとメッセージが渡り歩きながら処理されるアーキテクチャが作れます。テストしやすさの観点からコンテキストを引数に渡す設計は有利です（TLS より明示的）。

- コマンドインターフェース（データ駆動）  
  コマンドは設定ファイルなど外部データから作られる不変オブジェクトで、run(Context) を実装します。実装は「キーに対する make 関数」を登録→設定をパースしてコマンドオブジェクトを生成→入力に応じて run を呼ぶ、という3段階です。テキストエディタのキー割り当てやツールのユーザ設定でよく使われ、実行時に何をするかがデータで決まるため柔軟ですが、コマンド同士の互換性は必要ありません。

共通点：どのケースも「インターフェースは振る舞いを一時的に約束して仕事を進めるための最小限の関数群」であり、実装同士を相互に置換できるとは限らない、という点です。

## 実践ポイント
- インターフェースは最小の関数集合に絞る：必要以上の契約を与えない。  
- 置き換え可能性を期待するならテストと設計でそれを保証する（契約・副作用・性能を明示）。  
- IO周りはバッファポリシー（newline/page/manual）を用意するとデバッグと運用が楽になる。  
- スレッド間は context を明示的に渡してテスト容易性を高める。  
- コマンドはデータ駆動にするとカスタマイズ性が高まり、設定ファイルで拡張可能になる。  
- 実装の副作用（メモリ増加、遅延、データ損失）をドキュメントに明記しておくこと。

日本の現場では、運用チームや組込み機器、カスタマイズ性の高い業務ツールでこの「インターフェース＝関数群」アプローチが有効です。抽象化が目的化してしまう前に、「このインターフェースは何の仕事をさせるためにあるのか」を考えて設計してみてください。
