---
layout: post
title: "Are arrays functions? - 配列は関数なのか"
date: 2026-01-19T11:54:12.364Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://futhark-lang.org/blog/2026-01-16-are-arrays-functions.html"
source_title: "Are arrays functions?"
source_id: 1321174892
excerpt: "配列を関数と見る発想が性能と抽象をどう両立するかをFuthark例で解説。"
---

# Are arrays functions? - 配列は関数なのか
配列と関数の境界を壊す？言語設計が教える「同型」の魅力と落とし穴

## 要約
配列を「定義済みの関数」と見なす発想は、多くの有用な対応関係（カリー化⇄平坦化、転置⇄引数反転など）を導くが、型・実行効率・スライス表現の点で実用言語にそのまま持ち込むのは難しい、というFutharkプロジェクトの考察。

## この記事を読むべき理由
配列中心の数値計算や並列処理が重要な現代において、「配列＝関数」の見方はアルゴリズム設計やDSL（ドメイン特化言語）設計に新しい思考法を与える。日本のHPC／機械学習／科学技術計算コミュニティにとって、性能と抽象性の両立を考えるヒントになる。

## 詳細解説
- 発端と直感  
  古典的な説明では配列は「整数の連続部分に同型な領域を持つ関数」と表現される。これは一見形式的だが、配列と関数の間に成り立つ数学的対応を浮かび上がらせる。

- 具体例（言語比較）  
  - Dex: 関数は $a \to b$、配列は $a \Rightarrow b$ と書き、配列は連続整数同型のインデックスを持つ「事前計算された関数」のように扱う。無名関数 $\backslash x \to e$ に対し、配列は `for x.e` と記述し、カリー化や部分適用が配列操作（平坦化や次元固定）に対応するという直感的対応がある。  
  - K（APL系）: 構文的に配列アクセスと関数適用を `f[x]` で共用するが、型システムやバルク演算の観点で対応は限定的。

- Futhark が統一を採らない理由（運用上の現実）  
  - 型レベルの違い: Futharkは効率的な実行のために関数利用に制約を設け（例：ブランチから関数を返さない等）、配列には適用しない。  
  - サイズ情報と依存性: 配列型は $[n]\text{f64}$ のようにサイズ情報を持ち、実行時に取り出せる。関数にはこうしたサイズ注釈がなく、これを混ぜるには依存型に近づく必要がある。  
  - スライスと効率性: Futharkではスライスはメタデータ操作として事実上コストゼロにできるが、任意のインデックス配列でのアクセスはフィルタや拡張を一般化してしまい、効率保証が失われる。コンパイラが暗黙の意図を「逆推定」して最適化する設計はFutharkの哲学に反する。

- 抽象化の可能性と実務的提案  
  完全な単一型にするのではなく、共通の抽象（例えばファンクター的な $fmap$、スキャンやリダクションが意味を持つドメイン）を定義して、配列と「配列的な関数」の両方で使えるAPIを設ける方が現実的。AUTOMAP の発想を拡張して "AUTOFMAP" のような仕組みで関数同士の演算を自然に書けると面白い。

## 実践ポイント
- 思考ツールとして有用に使う: アルゴリズム設計では「配列を関数と見なす」ことで、転置⇄引数反転やカリー化⇄平坦化といった対応を見つけやすくなる。  
- 言語・DSL設計では表現と実行コストを分離する: 抽象APIは共有しつつ、内部表現（メモリ実装／遅延評価など）は明示的に選べる設計が現実的。  
- Futhark/高性能系に触れる人へ: スライスやインデックス配列のコストモデルを意識してコードを書くとパフォーマンス落ちを避けられる。  
- Python/NumPy/JAXユーザーは発想を移植可能: ベクトル化（配列操作）と関数適用の対応関係を意識すると、より効率的な実装やDSL的発想が得られる。

さらに知りたい場合は、DexやFutharkのドキュメントを読み、配列と関数の具体的な対応（カリー化⇄平坦化など）を小さな例で手を動かして確かめるのがおすすめ。
