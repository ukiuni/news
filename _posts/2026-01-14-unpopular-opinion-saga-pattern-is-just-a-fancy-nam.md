---
layout: post
title: "Unpopular Opinion: SAGA Pattern is just a fancy name for Manual Transaction Management - SAGAパターンは単なる手動トランザクション管理？"
date: 2026-01-14T07:42:53.409Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://microservices.io/patterns/data/saga.html"
source_title: "Pattern: Saga"
source_id: 427287653
excerpt: "SAGAは補償トランザクションで分散整合性を手作業で担い、落とし穴と対策を示す"
image: "http://microservices.io/i/data/saga.jpg"
---

# Unpopular Opinion: SAGA Pattern is just a fancy name for Manual Transaction Management - SAGAパターンは単なる手動トランザクション管理？

魅力的なタイトル案：さよならACID？SAGAで分散トランザクションを"手作業"で安全に扱う方法

## 要約
SAGAパターンは、サービスごとに独立したデータベースを維持する環境で「トランザクション」を実現するための設計手法で、複数のローカルトランザクションを順に実行し、失敗したら補償処理で巻き戻す仕組みです。自動ロールバックや完全な隔離（ACIDのI）は期待できないため、設計と運用で欠点を補う必要があります。

## この記事を読むべき理由
日本でもマイクロサービスに移行する企業が増えています。銀行・EC・決済など整合性が重要な領域でSAGAを正しく理解しないと、思わぬデータ不整合や運用コストを招きます。本記事は初心者にも分かるようにSAGAの本質と、現場で使える実践ポイントを整理します。

## 詳細解説
- 背景（なぜ必要か）  
  マイクロサービスでよく採用される「Database per Service」では、複数サービスにまたがる業務を単一のACIDトランザクションで保てません。2PCは多くの環境で現実的でないため、別の手法が必要です。

- SAGAの定義（本質）  
  SAGAは「複数のローカルトランザクションの連続」として業務を表現します。各ローカルトランザクションは自サービスのDBを更新し、次のステップを促すメッセージ／イベントを出します。どこかで失敗したら、それまでの変更を取り消す補償トランザクションを実行します。

- コーディネーション方式  
  1) コレオグラフィ（Choreography）: 各サービスがイベントを発行して次のサービスが反応する。疎結合で単純なフローに向く。  
  2) オーケストレーション（Orchestration）: 専用のオーケストレータが各参加サービスにコマンドを出す。複雑なビジネスロジックや全体制御に適す。

- 典型例（EC）  
  注文作成 → 顧客の与信予約 → 在庫引当… のステップを順に実行し、与信が取れなければ補償処理で注文をキャンセルする、という流れ。

- 長所と短所  
  長所: 分散環境でデータ整合性をある程度保てる（分散トランザクション不要）。  
  短所: 自動的なロールバック無し、隔離性が弱い（同時実行による不整合リスク）。補償処理や隔離の「対処」を設計でカバーする必要あり。

- 実装上の注意点  
  - 「DB更新」と「イベント発行」を原子化するためにTransactional Outboxやイベントソーシングなどの手法を用いる。  
  - クライアント向けの同期APIと非同期SAGAの橋渡し（完了まで待つ、ポーリング、Webhook/WSで通知など）を設計する。  
  - ステートの永続化、オーケストレータの再実行・再開、冪等性（idempotency）を確保する。  
  - 隔離性のカウンターメジャー（楽観ロック、バージョン管理、補償トランザクションの設計）を用意する。

- ツール／参考  
  例としてEventuateやTransactional Outboxパターン、メッセージ基盤（Kafkaなど）を使った実装が知られています。用途に応じてコレオグラフィ／オーケストレーションを選ぶのが定石です。

## 実践ポイント
- 補償処理を最初に設計する：各ステップの「失敗したらどう戻すか」を早期に決める。  
- Transactional Outboxを導入して「更新＋発行」を原子化する（ミッションクリティカルなら必須）。  
- オーケストレーションは複雑なフロー向き、コレオグラフィは単純でスケーラブルなフロー向きと割り切る。  
- 各操作は冪等にし、再試行で副作用が出ないようにする。  
- クライアント向けAPIは非同期ワークフローを明示（202 Accepted + Location、もしくは通知設計）する。  
- フェイルシナリオを含めた障害注入テストと監視（Sagaの状態、遅延・失敗率）を常設する。  
- 日本の金融規制や運用要件を考慮し、整合性を厳密に求められる部分は設計で補強する（例えば決済の最終確定は独立した整合性モデルにする等）。

SAGAは「自動で全部やってくれる魔法」ではなく、設計と運用で手間をかけて安全に使うためのパターンです。導入前に期待と欠点を整理し、上の実践ポイントを踏まえてプロトタイプで検証することをおすすめします。
