---
layout: post
title: "Fixing a Buffer Overflow in UNIX v4 Like It's 1973 - UNIX v4 のバッファオーバーフローを1973流に直す"
date: 2025-12-31T10:38:45.263Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://sigma-star.at/blog/2025/12/unix-v4-buffer-overflow/"
source_title: "Fixing a Buffer Overflow in UNIX v4 Like It's 1973"
source_id: 752056016
excerpt: "磁気テープ復元UNIX v4のsuバッファ溢れをed/ccで1973式に現地修復"
---

# Fixing a Buffer Overflow in UNIX v4 Like It's 1973 - UNIX v4 のバッファオーバーフローを1973流に直す
磁気テープから復活した「UNIX v4」で発見された、古典的バッファオーバーフローを現地修正する物語

## 要約
UNIX v4 の su(1) 実装に入力長の上限チェックがなく、100バイト固定バッファでオーバーフローが発生する脆弱性が見つかった。1973当時のツール（ed／cc）だけでソースを修正・再コンパイルし、セットUIDバイナリとして復旧する手順が紹介されている。

## この記事を読むべき理由
歴史的アーティファクトの解析から学べるのは「古いコードに今でもある〜そして今なら簡単に防げるミス」。日本の組込みやレガシーUNIX環境を扱うエンジニアにとって、単純な境界チェック不足がどれほど危険か、最小手順でどう直すかを示す良い教材です。

## 詳細解説
元記事は、2025年に磁気テープから復元された唯一のUNIX v4イメージ上で su(1) のソースを調査した記録です。su は setuid-root 実行ファイルで、root のパスワードを照合して root シェルを起動します。問題の核心は、パスワード読み取りループに境界チェックがないこと：

```c
// C (脆弱な部分の代表例)
q = password;
while ((*q = getchar()) != '\n')
    if (*q++ == '\0') return;
*q = '\0';
```

password 配列は 100 バイトに固定されていますが、ループは 100 バイトを超える入力を拒まないため、隣接メモリが上書きされクラッシュや不定動作を引き起こします。著者は当時のツール群（ed、cc）だけで修正を行い、境界チェックを追加しました。シンプルな修正例：

```c
// C (修正例：カウンタで境界をチェック)
register int i;
q = password;
i = 0;
while ((*q = getchar()) != '\n') {
    if (++i >= sizeof(password)) goto error;
    if (*q++ == '\0') return;
}
*q = '\0';
```

また、1973年当時は ed のような行指向エディタで編集し、cc でコンパイル、生成された a.out を /bin/su に置き、chmod 4755 で setuid を設定する手順でデプロイしています。重要な点は「ソースが同梱されていることで、その場で修正→コンパイル→配置が可能」だったことと、「当時はセキュリティ意識が現在ほど高くなかった」ためこうした欠陥が見落とされやすかった点です。

## 実践ポイント
- レガシーコードを扱う際は「固定長バッファ + ループ読み取り」がないかまず確認する。簡単な境界チェックで致命的脆弱性を防げる。  
- 実運用で修正するなら、単純なカウンタチェック以外に入力長を制限する、安全な読み取り関数（fgets や getline, readn 等）やライブラリを使う。  
- エラー経路でも TTY の状態（エコー）を必ず復帰させる。端末が見えなくなると復旧が面倒。  
- レガシー環境の修正は、必ずテスト（長大入力、境界値、異常終了）を行い、setuid バイナリの権限設定と署名／監査を併用する。  
- 歴史的資料としての意味も大きい：ソースとツールが揃っていれば「その場で直して動かして学べる」環境は教育資産になる。

