---
  layout: post
  title: "Who Owns the Memory? Part 3: How Big Is your Type? - メモリは誰のもの？パート3: 型の大きさとは"
  date: 2026-01-05T17:10:59.717Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://lukefleed.xyz/posts/who-owns-the-memory-pt3/"
  source_title: "Who Owns the Memory? Part 3: How Big Is your Type? | Luca Lombardo"
  source_id: 470376432
  excerpt: "型のサイズと配置が性能・互換性を左右する理由とRust/Cの実務対策を解説"
  image: "https://lukefleed.xyz/posts/who-owns-the-memory-pt3/index.png"
---

# Who Owns the Memory? Part 3: How Big Is your Type? - メモリは誰のもの？パート3: 型の大きさとは
知らないと損する型レイアウト入門 — RustとC/C++で「数バイト」が性能と互換性を左右する理由

## 要約
型の「サイズ」と「アラインメント」、およびコンパイラがフィールドをどう並べるか（レイアウト）は、性能・ABI互換性・安全性に直結する。Rustは省メモリ化のために既定でフィールド順を入れ替えるが、FFIやハードウェア/プロトコルでは明示的な表現指定が必須。

## この記事を読むべき理由
日本の組込み、ゲーム、金融系、サーバー開発ではメモリレイアウトの差がバグや性能劣化に直結する。C/C++との連携やARMプラットフォームでの安全なアクセス、マルチコアでのキャッシュ効率化など、実務で必ず直面するテーマを整理できる。

## 詳細解説
- Cのレイアウト（宣言順・決定論的）  
  Cはフィールド宣言順で確定的にオフセットを決める。これはバイナリ互換やメモリマップ、ネットワークプロトコルに必須の性質で、FFIの基準となる。C++も標準レイアウト型では同様。

- Rustの既定repr(Rust)（コンパイラ裁量）  
  Rustはデフォルトでフィールドを再配置してパディングを最小化する。このため同じ構造体でも型パラメータやビルドでレイアウトが変わり得る。利点はメモリ節約だが、オフセットに依存する unsafe コードやバイナリプロトコルでは使えない。

- #[repr(C)]（FFI向けの解決策）  
  RustでC互換を要求するには #[repr(C)] を付ける。これでCのアルゴリズムに従った固定レイアウトになり、外部と安全にデータを共有できる。

- repr(packed) の落とし穴  
  #[repr(packed)] はパディングを排して最小サイズにするが、フィールドがミスアラインドされる可能性がある。プラットフォームによっては読み書きで例外や性能悪化を招くため、参照を直接取れない・read_unaligned 等の扱いが必要。

- repr(align) とキャッシュラインパディング  
  #[repr(align(N))] で型全体のアラインメントを大きくすると、false sharing を防ぎ並列性能が劇的に改善する場合がある。代償はメモリ浪費。用途に応じたトレードオフが重要。

- repr(transparent) と newtype のABI一致  
  単一フィールドのラッパーをCの型と同じABIで扱うには #[repr(transparent)] を使う。FFI境界での安全・最適化（例えば関数呼び出し規約の一致）に有効。

- 列挙型の表現（タグサイズの制御とニッチ最適化）  
  #[repr(u8)] 等でディスクリミナント（タグ）サイズを固定できる。フィールド付きenumに対しては、指定することでニッチ最適化を抑制したり、プロトコル幅に合わせることができる。

- 動的サイズ型（DST）・ファットポインタ・トレイトオブジェクト  
  可変長末尾やトレイトオブジェクトはポインタとメタデータ（長さやvtableポインタ）を同時に持つ「ファットポインタ」になる。動的ディスパッチ（vtable）とモノモーフィゼーション（ジェネリクス展開）の選択は、コードサイズと実行時コストのトレードオフ。

- 実行時ディスパッチと性能  
  仮想関数／トレイトオブジェクトは柔軟だが追加の間接呼び出しが発生する。ホットパスではジェネリクス（静的展開）が性能面で有利なことが多い。

参考となるコード例（要点のみ）:
```rust
// Rust: FFI互換を保証する例
#[repr(C)]
struct ThreeInts {
    first: i16,
    second: i8,
    third: i32,
}
```

```c
// C側の同等定義
struct ThreeInts { int16_t first; int8_t second; int32_t third; };
```

```rust
// キャッシュライン分離
#[repr(align(64))]
struct CacheAligned(u64);
struct Counters {
    a: CacheAligned,
    b: CacheAligned,
}
```

## 実践ポイント
- バイナリフォーマットやFFIには必ず #[repr(C)] を使う。repr(Rust)は内部実装向け。
- サイズ/オフセットを前提にした unsafe コードはコンパイルごとに壊れ得るので避けるかテスト/ドキュメントで厳密に管理する。
- packed は最終手段。プラットフォームのアラインメント制約とアクセス方法（read_unaligned 等）を確認する。
- 並列カウンタ等のホットデータは #[repr(align(64))] などでキャッシュライン分離を検討するが、配列で大量に使う場合はコストを試算する。
- プロトコルのタグ幅は repr(u8) などで明示的に決める。ニッチ最適化の副作用を理解する。
- パフォーマンスホットスポットでは「トレイトオブジェクト（動的）」と「ジェネリクス（静的）」のどちらが適切かをベンチで判断する。

短時間で効果を出すチェックリスト
- std::mem::size_of / align_of で実際のサイズを確認
- bindgen/cbindgen を併用して FFI の型整合を自動化
- packed を使う場合は必ずプラットフォームで動作確認
- マルチスレッドで一部の変数だけ激しく書き込まれるなら align で対処

このテーマは「数バイト」の違いが大きな影響を生む領域。特に日本の組込み・モバイル・高周波取引など、低レイテンシ・メモリ効率が求められる領域で役立つ知識なので、実プロジェクトで一度型レイアウトを見直してみることを勧める。
