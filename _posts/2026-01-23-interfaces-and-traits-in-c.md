---
layout: post
title: "Interfaces and traits in C - Cにおけるインターフェースとトレイト"
date: 2026-01-23T17:06:53.636Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://antonz.org/interfaces-in-c/"
source_title: "Interfaces and traits in C"
source_id: 1434987565
excerpt: "メソッドテーブルとself参照でCに安全かつ効率的なインターフェース実装を解説"
image: "https://antonz.org/interfaces-in-c/cover.png"
---

# Interfaces and traits in C - Cにおけるインターフェースとトレイト
Cで“インターフェース／トレイト”を自作する——継承なしで多態性を安全かつ効率的に実現する設計メモ

## 要約
Goのインターフェース／Rustのトレイト的な多態性をCで模倣する方法を、初心者向けに段階的に解説。生の関数ポインタから「メソッドテーブル＋self参照」方式へと改良し、実用的な設計指針を示します。

## この記事を読むべき理由
Cでライブラリやプラグイン設計をするとき、継承なしに「振る舞い（インターフェース）」だけを扱える設計は便利。組込み・ゲーム・高性能Cコードを書いている日本のエンジニアに直接役立つ知見です。

## 詳細解説
- 背景：  
  Goのinterfaceは構造（structural）で、メソッドが揃えば自動で実装扱いになる。一方Rustのtraitは明示的にimplする必要がある。どちらも「実装の詳細を隠して振る舞いだけを扱う」点が利点。

- 最初のCでの試み（問題点）：  
  インスタンスごとに関数ポインタを持たせると実装は簡単だが、メモリ overhead、構造体レイアウト依存（キャスト危険）、型安全性の欠如という致命的欠点が出る。

- 改良1：interfaceにselfを持たせる（安全性向上）：  
  インターフェース型は「関数ポインタ」と「void* self」を持つ。実体側は純粋にデータのみを持ち、実装関数は具体型ポインタを受け取る。キャストと関数ポインタの束ね処理を作ることでレイアウト依存と型不一致の問題を回避する。

- 改良2：メソッドテーブル（vtable風）を共有する（効率化）：  
  各インスタンスが関数ポインタを持つのではなく、メソッドをまとめた静的テーブルを共有して参照する。インターフェースは (mtab, self) を持ち、呼び出しは mtab->Method(self, ...) で行う。これでインスタンスあたりのオーバーヘッドは固定小に。

- 代替案と注意点：  
  実装側にメソッドテーブルを置く手法もあるが、レイアウト順に依存するため複数インターフェース実装時に破綻しやすい。さらに、Goのような動的な型アサーション（あるインターフェースが別のインターフェースも満たすかのチェック）をCで再現するには追加の型情報を保持する必要があり、実装コストが高い。

- まとめの設計思想：  
  - 実体（implementor）はデータのみ。  
  - メソッドは静的なテーブルで共有。  
  - インターフェースは (mtab pointer, self pointer)。  
  - 呼び出し用のラッパー関数を用意して実装の詳細を隠蔽する。

主要スニペット（概念を示す最小限の例）：

```c
// c
typedef struct {
    size_t (*Read)(void *self, uint8_t *p, size_t len);
} ReaderTable;

typedef struct {
    const ReaderTable *mtab;
    void *self;
} Reader;

size_t Reader_Read(Reader r, uint8_t *p, size_t len) {
    return r.mtab->Read(r.self, p, len);
}
```

実装側（例：Zeros）のメソッドテーブル生成は静的に行うのが安全で効率的です。

## 実践ポイント
- ライブラリ設計では「データと振る舞いの分離」を採る（データは小さく、振る舞いはテーブルで共有）。  
- インターフェース呼び出しは必ずラッパー関数を通す（可読性と移植性向上）。  
- 複数インターフェースを同一オブジェクトで使いたい場合は、各インターフェースごとに (mtab,self) ペアを作る設計にする（レイアウト依存を避ける）。  
- 動的な「型アサーション」が必要なら、オブジェクトに「実装しているインターフェースのID一覧」を持たせる設計を検討するが、コストは高い。  
- 小さなユーティリティマクロや生成スクリプトでボイラープレートを減らすと実用的。

以上を踏まえれば、Cでも安全かつ効率的に「インターフェース／トレイト風」の設計が実現できます。必要なら、具体的なコードテンプレート（ヘッダ＋実装）を用意します。
