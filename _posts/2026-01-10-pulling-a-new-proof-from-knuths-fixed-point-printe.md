---
layout: post
title: "Pulling a New Proof from Knuth’s Fixed-Point Printer - Knuthの固定小数点プリンタから新しい証明を引き出す"
date: 2026-01-10T17:47:27.790Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://research.swtch.com/fp-knuth"
source_title: "research!rsc: Pulling a New Proof from Knuth’s Fixed-Point Printer"
source_id: 871751464
excerpt: "Russ CoxがKnuthの16ビット固定小数出力を分かりやすく証明しP2実装へ導く手順を示す"
---

# Pulling a New Proof from Knuth’s Fixed-Point Printer - Knuthの固定小数点プリンタから新しい証明を引き出す
16ビット固定小数の「最短で正確な十進表記」をなぜKnuthより分かりやすく証明できるのか？

## 要約
Knuthが提示した16ビット固定小数から最短の十進表記を出力する問題に対し、Russ Coxは「まず単純で自明な実装を書き、その後段階的にKnuthの高速版（P2）へ変換しつつ各変換の正当性を示す」ことで、より直感的で検証しやすい証明を提示している。

## この記事を読むべき理由
- 浮動小数や固定小数点の「表示」（印刷）で起きる微妙な丸め誤差は、組み込み機器や数値ライブラリ、表示層で頻出します。  
- 短く正確な十進表記を得るアルゴリズム設計と「証明付きリファクタリング」の実例は、信頼性が求められる日本の組み込み／金融／計測系ソフトに直接役立ちます。

## 詳細解説
問題設定（簡潔）
- 入力は $f = n/2^{16}$ （$n\in[0,2^{16})$）という16ビット固定小数。  
- 求めたいのは「短さ」かつ「正しく丸められ（correctly rounded）」、さらに「その十進表記を再び2^16分解能に丸め直すと元に戻る（accurate）」十進分数。

丸めの定義（要点）
- $[f]_p = \lfloor f\cdot 10^p + 1/2\rfloor / 10^p$ が「p桁に丸めた値」。
- 正確性（accuracy）は、十進表記 $d$ が $$\left\lfloor d\cdot 2^{16} + \tfrac12\right\rfloor /2^{16} = f$$ を満たすこと。
- これから導かれる重要区間は精度区間（accuracy interval）$$[f-2^{-17},\; f+2^{-17})$$ で、この区間内にある十進が「元に戻る」候補。

単純で証明が容易な実装（bin2dec）
- 方針は単純：$p=1$ から増やしていき、$[f]_p$ が精度区間に入ったら返す。五桁以内には必ず見つかる（Five‑Digit Lemma）。
- この単純実装は定義に基づく直接的な正当性証明が容易で、終端（最大5回）は明らか。

「桁を歩く（walking digits）」戦略と補題群
- 精度区間の上端・下端がp桁の十進と衝突しないこと（Endpoint Lemma）、p≤4では精度区間に入るp桁十進は一意であること（Rounding/Truncating Lemma）などを示して、
- p≤4のケースは「上端の切り捨て⌊max⌋_p を取れば良い」と整理できる。p=5だけ特殊処理が必要。

Knuth の P2 への変換
- Russ Coxはまず上の単純実装を用いて正しいことを示し、次に式変形・変数変換・整数演算への置換を段階的に適用して、最終的にKnuthの整数のみで回るP2へと変形する。  
- こうする利点は「一発で難解な証明を出す」よりも「各ステップの意味と正当性が追える」点で、実装の信頼性が高まる。

実例的な注意点
- 代表的な誤認として TeX で 0.4 → 0.39999 と表示されてしまった件がある（丸め・印字幅の問題）。これは「短く・正しく」表示するアルゴリズムを持たないことの副作用。
- 丸め規則（round half up と IEEE の round-to-even）の違いにより境界挙動が変わるため、どの丸め規則を採用するかを明確にして実装／テストする必要がある。

簡単な疑似コード（bin2dec の骨格、Ivy風）
```ivy
op bin2dec f =
  min = f - 2**-17
  max = f + 2**-17
  p = 1
  :while p <= 5
    d = p round f
    :if min <= d and d < max
      :ret p digits d * 10**p
    :end
    p = p + 1
  :end
```

## 実践ポイント
- 実装上はまず「定義に基づいた単純解」を書いて正当性を確かめ、そこから性能改善（整数演算化やループの簡素化）を段階的に行うと良い。  
- 小ビット幅（ここでは16ビット）なら全入力を列挙して総当たりテストが可能。まずは exhaustive testing で差分を潰す。  
- 実運用では既存の実績ある浮動小数表記ライブラリ（Dragon4, Ryu, Grisu 系）を検討するが、固定小数点や組込向けには整数中心のP2のような手法が有利。  
- 丸めモードの指定（round-half-up vs round-to-even）を仕様に明記し、境界ケース（例えば 0.4 など）をユニットテストに必ず含める。  
- 証明可能性を重視するなら、「まず正しい単純版→変換ごとに不変量を示す」の段階的手法を採るとレビューや形式化が容易になる。

参考（原典を追う場合）
- Knuth のオリジナル論文（1989）と、Russ Cox の「Pulling a New Proof from Knuth’s Fixed‑Point Printer」（元記事）は、アルゴリズム設計と証明手法の教科書的事例です。実装や検証に取り組む際は原文を合わせて参照してください。

この記事で触れた考え方は、数値の表示ひとつにも「正確性」「短さ」「効率」「証明可能性」という設計トレードオフがあり、特に組込み／計測／金融系で重要になる点を示しています。
