---
layout: post
title: "On rebuilding read models, Dead-Letter Queues and Why Letting Go is Sometimes the Answer - リードモデル再構築、デッドレターキュー、そして時には手放すことが答えになる理由"
date: 2026-01-19T16:54:01.250Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://event-driven.io/en/rebuilding_read_models_skipping_events/"
source_title: "On rebuilding read models, Dead-Letter Queues and Why Letting Go is Sometimes the Answer - Event-Driven.io"
source_id: 424114217
excerpt: "抜け落ちるイベントを同一トランザクションで記録し再構築後に回収する実践手法で監査対応も可能"
image: "https://event-driven.io/static/15181cbf6a5249da225a8603462fe780/2a4de/2026-01-19-cover.png"
---

# On rebuilding read models, Dead-Letter Queues and Why Letting Go is Sometimes the Answer - リードモデル再構築、デッドレターキュー、そして時には手放すことが答えになる理由
再構築で“見えない”イベントに泣かされない方法 — 防ぐのではなく「記録して回収する」アプローチ

## 要約
イベントソーシング＋PostgreSQLでインライン投影（inline projection）を再構築すると、未コミットのトランザクションのせいでイベントが投影されずに抜け落ちるレースが起きる。回避を試みる複数の工夫は新たな窓口（見えない領域）を生むため、最終的には「スキップを可視化して後で処理する」設計が現実的で強い。

## この記事を読むべき理由
- 日本の現場でもPostgres＋イベント駆動（アウトボックス／インライン投影）を採るチームが増えている。小さなタイミング差でデータ不整合が生じると障害調査が難しくなる。  
- パフォーマンスや可用性を落とさずに整合性を担保する実務的な設計パターン（スキップ記録／デッドレター的な扱い）が学べる。  

## 詳細解説
背景
- イベントを書き込みつつ、その同一トランザクション内でリードモデル（DB上の投影）を更新する「インライン投影」は、整合性とパフォーマンスの良い折衷だが、再構築(rebuild)時に問題が出る。  
- 再構築中は投影側を「rebuilding」にして、append時は投影をスキップする設計を取る。再構築が最新まで追いついたら「active」に戻す、という流れ。

問題の本質
- 再構築プロセスが「今見えているイベントは無い」と判断してactiveに戻すタイミングと、既に未コミットのappendトランザクションが「rebuildingを見てスキップする」判断をしたタイミングが噛み合わないと、イベントが永続的に投影されない（スキップされたまま残る）。  
- 未コミットトランザクションは他のトランザクションから見えない（Postgresの分離性）。これが根本原因で、「見えないもの」を同期させる試みは必ず盲点を残す。

試した「修正案」と失敗理由（概要）
1. in-flight トランザクションが終わるまで待つ  
   - 待っている間に新しいトランザクションが始まり、またスキップ判断が発生するため解決しない（ターゲットが動く）。  
2. トランザクションID(txid)を境界に使う  
   - txidは開始順だが、コミット順ではない。開始時刻とコミット時刻が逆転するケースで失敗する。  
3. 書き込みパスをロックして同期する（アドバイザリロックを独占）  
   - ロックを厳しくするとパフォーマンスが落ちる。さらに、スキップの判断は既にトランザクション内部で固まっているため、後からロックしても遅い。接続切断でロックが消える性質もあり信頼できない。

設計の転換：止めるのではなく「記録して回収する」
- 防ぎきれないなら、スキップされた事実を同一トランザクション内で記録してしまおう、という発想。  
- 実装案：emt_system_messages のような「システムイベント」テーブルに、projection_id＋イベント位置などを同じトランザクションで書く。トランザクションがロールバックすれば記録も消える。コミットされれば「何がスキップされたか」が確実に残る。  
- 再構築後にその記録を読み取り、該当イベントを再適用して記録をアーカイブ（is_archived=true）する。アーカイブやパーティショニングで運用コストを抑え、監査やデバッグに利用できるようにする。

利点のまとめ
- 見えないトランザクション問題を「見える化」して解決の責務を変える（予防→回収）。  
- スキップ情報をイベント的に扱えば監査性、追跡性、再処理が自然につく。  
- アウトボックスやデッドレターの発想と親和性が高く、既存のオペレーションと統合しやすい。

## 実践ポイント
- スキップ記録テーブルを用意する  
  - 別テーブル（システムメッセージ）を用意し、stream_id=projection名、messageデータに元イベントの参照、metadataに理由・プロセッサID等を入れる。  
- スキップ記録は必ずイベントのappendと同一トランザクション内で書く  
  - こうすることでロールバック時の整合が自動保証される。  
- 再構築フローを明確にする  
  1. projection.status = ‘rebuilding’  
  2. 履歴イベントを順に処理（通常の投影はスキップされ、スキップ記録が残る）  
  3. 再構築が追いついたら projection.status = ‘active’  
  4. スキップ記録をクエリして該当イベントを適用、処理後に記録をアーカイブする  
- スキップ記録の可視性判定はアウトボックスの手法を踏襲する（コミット済みの記録のみ処理）  
  - pg_snapshot_xmin などPostgresのスナップショット概念を理解して、未コミットの記録を誤って扱わないこと。  
- アーカイブとパーティショニングを運用設計に組み込む  
  - is_archivedフラグやパーティションで古いシステムメッセージを自動移動／削除し、テーブル肥大化を抑える。  
- モニタリングと運用用ダッシュボードを作る  
  - スキップ件数、処理待ち件数、再構築履歴を可視化しておくことで、問題発生時の切り分けが楽になる。  
- 負荷試験を忘れずに  
  - 高スループット環境でタイミング依存の欠落が出るかをシミュレーションし、スキップ→回収ルートが確実に機能することを確認する。  

短いまとめ
- 未コミットトランザクションは見えないため「完全に防ぐ」ことはコストが高く脆い。  
- 実務的には「スキップを同一トランザクションで記録し、再構築後に回収する」設計が堅実で運用に優しい。  
- 日本の現場でも、同様の可観測性（system events）を取り入れることで、障害対応と信頼性が大きく改善する。
