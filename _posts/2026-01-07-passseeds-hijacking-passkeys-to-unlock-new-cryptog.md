---
  layout: post
  title: "PassSeeds – hijacking Passkeys to unlock new cryptographic use cases - PassSeeds — パスキーをハイジャックして暗号用途を拡張"
  date: 2026-01-07T01:28:04.142Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://backalleycoder.com/posts/passseeds-an-experiment-in-hijacking-passkeys-to-unlock-cryptographic-use-cases/"
  source_title: "PassSeeds - Hijacking Passkeys to Unlock Cryptographic Use Cases | Back Alley Coder"
  source_id: 46521084
  excerpt: "パスキー公開鍵を種にしてBTCやZKP鍵を安全に生成する画期的手法"
  image: "https://csuwildcat.github.io/_astro/passseed-logo.Dtrp9Ve4.jpg"
---

# PassSeeds – hijacking Passkeys to unlock new cryptographic use cases - PassSeeds — パスキーをハイジャックして暗号用途を拡張
パスキーの「公開鍵」を再発明して、ウォレットやZKPなどパスキーが本来想定しない暗号用途のシードにする技法

## 要約
PassSeedsは、WebAuthn/PasskeyのP‑256公開鍵を“種（seed）”として再現可能にし、ECDSA公開鍵復元を使って端末から安全に取り出し（プライベートは端末内に残す）、そのハッシュをBIP‑39などに変換して他の暗号用途（Bitcoin鍵、BLSスカラー、ZKP用材料など）に派生させる手法です。

## この記事を読むべき理由
- 日本でもWeb認証（Passkeys/パスキー）の普及が進む中、既存の安全 UX を壊さずに“パスキーを秘密に近いシードとして活用”できる発想は、Wallet UX改善や企業の秘密管理、分散ID/認証連携で実用的価値があります。  
- 実装は比較的シンプルで、プラットフォームの同期（iCloud Keychain/Google/Windows）を活用すればユーザー向けのバックアップ・回復も現実的です。

## 詳細解説
- 基礎：パスキーは端末で生成される非対称鍵ペア（通常P‑256）で、生成時のオリジン（RP ID）に紐づき、プラットフォーム側でエンドツーエンドに同期される。通常はログイン署名が目的。
- 核となる着想：パスキーの公開鍵はプラットフォーム的には“同期される非常に守られたバンドル”であり、公開鍵自体を“再現可能なシード”として扱える。直接公開鍵をエクスポートしなくても、端末に残るプライベートで同一メッセージを2回署名させ、得られた2つのECDSA署名から公開鍵を復元（public‑key recovery）できる。
- フロー（要点）：
  1. 初回に navigator.credentials.create() で P‑256 のパスキーを作成（userVerification を必須にする等）。生成時に返される公開鍵は取り扱い注意（初回に取り出すか、以降は復元に任せる）。
  2. PassSeed を使いたい時は同一チャレンジ（同じメッセージ）を使って navigator.credentials.get() を2回実行し、それぞれの ECDSA 署名（r,s）を取得する。
  3. 2つの署名と署名対象のハッシュから、ECDSA の公開鍵復元アルゴリズムで候補点を算出し、両方の候補の交差を取って一意の公開鍵を得る。
  4. その公開鍵バイト列を SHA‑256 でハッシュした32バイトを PassSeed とし、必要なら BIP‑39 に変換してニーモニックでバックアップ可能にする。
  5. PassSeed から HKDF 等でドメイン分離（label）して secp256k1 用の 32 バイトを生成→クランプして Bitcoin 鍵に、あるいは BLS 用スカラに派生、といった利用が可能。
- セキュリティ上のポイント：
  - プライベート鍵は端末に残り外に出ない。だがホストページは2つの署名と復元された公開鍵を取得できるため、信頼できるホストでの利用が前提。署名にノンスやRP情報を含めることで再利用（リプレイ）を防止する必要あり。
  - プラットフォームの同期機能により別デバイスでの自動復元が可能（バックアップの優位性）。ただし、すべてのデバイスを失った場合はエクスポートしたニーモニックが復旧手段になるため、ユーザーにバックアップを推奨。
- 制約：
  - 現状はP‑256を前提にした手法。パスキーが別曲線を使う／制限の厳しい認証器では動かないことがある。
  - ホストは公開鍵を把握できるため完全な秘密保持は保証されない。規制やプライバシー要件を満たす用途か検討が必要。

## 実践ポイント
- 実装での注意点（チェックリスト）：
  - パスキー生成時に userVerification を必須にして UX とセキュリティを担保する。  
  - PassSeed 取得時は「同一チャレンジを2回署名」→2つの署名を得て ECDSA 公開鍵復元を行う。復元ライブラリ（noble‑secp256k1 等）を利用すると実装が簡単。  
  - 復元した公開鍵は SHA‑256(hash) を取って 32 バイトのシード化、必要なら BIP‑39 に変換してユーザーにニーモニックを提供する（12/24語を選べるように）。  
  - 派生鍵は HKDF + ドメインラベルで分離し、secp256k1 用はクランプ処理を忘れない。BLS 等は目的のフィールドに合わせてスカラー化する。  
  - 悪用対策：必ずノンス＋RP情報を署名対象に含め、ホスト側での再利用を防止する。ユーザーに二重署名のUI説明を出して信頼性を確保する。  
- 日本の実務的示唆：
  - 企業内の秘密鍵配布やBYOD環境での鍵管理を、専用HSMや外部デバイスを買わせずにパスキーのUXで代替できる可能性がある。  
  - Web3ウォレットや分散IDのUX改善（シードの入力不要化）に応用できるが、暗号資産や個人情報に関する日本の法令（資金決済法、個人情報保護）への配慮が必要。  
- 検証を始めるには：
  - web 製の実験環境で navigator.credentials.create()/get() を触り、署名のDER→(r,s)解析、復元ライブラリによる candidate intersection を試してみると概念が掴める。  
  - 実運用前に脅威モデル（ホストの信頼、端末紛失時の回復手順、同期の挙動）を必ず精査する。

PassSeedsは「既にある安全なUX（パスキー）を巧みに再利用して、新しい暗号的可能性を開く」シンプルかつ強力なアイデアです。プロトタイプを作り、日本のユースケース（企業鍵配布、ウォレットUX、認証と署名の統合）での実用性を評価する価値があります。
