---
layout: post
title: "Are compilers deterministic? - コンパイラは決定論的か？"
date: 2026-02-22T01:40:38.844Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://blog.onepatchdown.net/2026/02/22/are-compilers-deterministic-nerd-version/"
source_title: "Are Compilers Deterministic?"
source_id: 47106626
excerpt: "同じソースでも環境や日時・パス差でバイナリが変わる現実と、再現可能ビルドの対策を具体的に解説"
---

# Are compilers deterministic? - コンパイラは決定論的か？
クリックしたくなる日本語タイトル: コンパイラは「同じソース」で本当に同じものを出力するか？ — 再現性と実務の境界線

## 要約
コンパイラは理論上「入力が完全に同じ」なら同じ出力を返すが、実務では環境の微妙な違い（時間・パス・並列順序など）が結果を揺らし、バイナリが変わることがよくある。

## この記事を読むべき理由
バイナリの再現性やビルドの信頼性は、セキュリティパッチ、CI、パッケージ配布、そしてLLM支援開発の検証にも直結します。日本の現場でも依存するツールチェーンや配布パッケージの品質管理に役立つ知見です。

## 詳細解説
- 「決定論的」と「再現可能（reproducible）」は異なる観点です。数学的にはコンパイラは入力の完全なタプル（ソース、フラグ、コンパイラ本体、リンカ、環境変数、ファイルシステムの見え方、ロケール、時刻、カーネル挙動、並行実行など）に対して決定論的関数とみなせます。しかし現実のビルドはこの全てを揃えないことが多く、出力にばらつきが生じます。
- 実務でよく問題になる原因（ノイズ）：
  - ビルド時刻やマクロ（__DATE__, __TIME__）
  - 絶対パスやデバッグ情報へのビルドパス埋め込み
  - ロケールやソート順（LC_ALL 等）
  - ファイルシステムの列挙順、並列ビルドによるレース
  - アーカイブ（ar）やランナブルなメタデータ順序
  - ビルドIDやランダムシード、ネットワーク取得の有無
  - ツールチェーンやホストのカーネル/ライブラリ差異
  - コンパイラ内部のポインタ/ハッシュ順序の不安定さ（歴史的なバグ例あり）
- 重要な観点：コンパイラ契約は「意味論を壊さないこと」。同じ外部振る舞い（I/O、同期、定義された戻り値など）が保たれれば、命令並びやレジスタ選択が変わっても許容されます。一方で「再現可能ビルド」はバイト単位で一致させることを目指す、より厳しい目標です。
- 再現可能ビルドを目指す工学的手法（Debianなどの取り組み）：
  - ツールチェーンと依存関係を固定
  - 環境を安定化（TZ=UTC, LC_ALL=C 等）
  - SOURCE_DATE_EPOCH の導入、パス正規化（-ffile-prefix-map 等）
  - 不安定なメタデータを除去／正規化（ar -D など）
  - ネットワーク非依存のハーメチックなビルド（コンテナ／サンドボックス）
  - CIでの継続的な差分チェック
- LLM（大規模言語モデル）との関連：生成が確率的であっても、エンジニアリングでは出力を検証可能にし、再現可能なゲート（テスト・CI）で受け入れる流れが現実的。つまり「完全決定性」より「検証可能性」と「境界管理」が重要。

## 実践ポイント
- まずは再現性の低い原因をリストアップする（時間・パス・ロケール・並列性）。
- CIでビルド差分を自動比較し、変化の発生源を早期検出する。
- 環境固定（コンテナ・ツールチェーンロック）と SOURCE_DATE_EPOCH, -ffile-prefix-map などのビルドフラグ導入を検討する。
- 外部依存やネットワーク取得を避け、ハーメチックなビルドを目指す。
- LLMや自動生成コードを導入する際は、生成物を必ず既存のテスト・CIゲートで検証する運用を確立する。

この記事を読んで、まずは自分のプロジェクトで「何がノイズになっているか」を確認してみてください。再現性は一朝一夕ではなく、意図的な積み重ねで達成できます。
