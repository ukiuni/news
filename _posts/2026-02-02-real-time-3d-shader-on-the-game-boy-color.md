---
layout: post
title: "Real-time 3D shader on the Game Boy Color - ゲームボーイカラーで動くリアルタイム3Dシェーダ"
date: 2026-02-02T12:50:24.603Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://blog.otterstack.com/posts/202512-gbshader/"
source_title: "I put a real-time 3D shader on the Game Boy Color | Danny's Blog"
source_id: 411202875
excerpt: "ゲームボーイカラーで乗算を使わず対数＋ルックアップで実現したリアルタイム3Dシェーダの驚きの手法を解説"
image: "https://blog.otterstack.com/posts/202512-gbshader/og_image.jpg"
---

# Real-time 3D shader on the Game Boy Color - ゲームボーイカラーで動くリアルタイム3Dシェーダ
ゲームボーイカラーの限られた性能で「リアルタイム3Dシェーダ」を動かした奇跡的ハック

## 要約
ゲームボーイカラー上で法線マップとテーブル駆動の近似演算のみを使い、ライト操作可能なリアルタイム3Dライティングを実現したプロジェクトの解説。乗算命令がないSM83で乗算を「対数＋ルックアップ」で置き換えるのが肝。

## この記事を読むべき理由
レトロハードの制約下で「どうやって3Dライティングを計算するか」を学べる。組み込み系やリソース限定環境で効率的に数値計算をする技術は、モバイルや組み込み開発者にも役立つ知見を与える。

## 詳細解説
- 基本思想  
  ピクセルごとに事前レンダリングした法線マップ（normal map）を参照し、ライトとの内積でラアンバート陰影を計算する。通常は $v = \mathbf{N}\cdot\mathbf{L}$。

- 球面座標による最適化  
  法線とライトを単位ベクトルで表し、球面座標で内積を展開：
  $$
  (r_1,\theta_1,\varphi_1)\cdot(r_2,\theta_2,\varphi_2)=r_1r_2\big(\sin\theta_1\sin\theta_2\cos(\varphi_1-\varphi_2)+\cos\theta_1\cos\theta_2\big)
  $$
  単位長を仮定すると係数を事前にまとめて
  $$
  v = m\cos(N_\varphi-L_\varphi) + b
  $$
  として、ランタイムでは角差のコサインとテーブル参照中心の処理にする。

- 乗算がないCPUへの対処：対数とルックアップ  
  SM83は乗算/浮動小数点を持たないため、値を対数空間で表して「加算で乗算を表現」する。ROMには
  (N_\varphi, \log(m), b)
  を格納し、以下の流れで評価する：角差を引く → cos_logルックアップ → 対数空間で加算 → powルックアップ → bを足す。これで実行時は数回の加算と2回のルックアップで済む。

- 8bit分解能と表現ルール  
  値は -1.0..+1.0 を8ビット分数で表現。対数表現ではMSBを符号に割り当て、残りで対数量を符号付きで保持。底は $2^{1/6}$ のような小さな基底を選び、加算で溢れない工夫をしている。

- 実行速度と最適化テクニック  
  フレームあたり最低15タイル（約960ピクセル）を処理。1ピクセルあたり約130サイクルで、全描画で実行時間の約89%を占有。そこで自己書き換え（self-modifying code）で即値オペランドを置き換え、命令読み込みを省くことで数千〜万サイクルを節約している（例：変数を読む代わりに即値を使うほうが速い）。

- その他のポイント  
  Blender等で法線AOVをレンダリング → ROMに変換するワークフロー、疑似ディザやcryptomatteを使った部分的に固定色を持つ法線の制作、AIによるアセンブリ生成は限定的にしか有効でなかったという実践的なコメントもある。

## 実践ポイント
- 小さなCPUで乗算が必要なら「対数空間＋テーブル」で乗算を加算に置き換える手法は有効。  
- 事前に定数（ここでは $L_\theta$）を固定し、ランタイム負荷を下げる。  
- 8bit固定小数点を前提に精度管理（符号ビット・基底・飽和処理）を設計する。  
- タイル／行ごとに空行検出を入れるなどで処理負荷を可変にし、実効フレーム率を確保する。  
- 自己書き換えは強力だが保守性と安全性に注意。組み込み最適化の最後の手段として使う。

参考：原著のコード・ROM（英語、実装例）は公開リポジトリで確認できる（https://github.com/nukep/gbshader）。実機やエミュで動作確認して、低リソース最適化の考え方を学ぶと良い。
