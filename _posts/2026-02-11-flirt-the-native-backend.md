---
layout: post
title: "Flirt: The Native Backend - Flirt：ネイティブバックエンド"
date: 2026-02-11T07:15:57.723Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://blog.buenzli.dev/flirt-native-backend/"
source_title: "Flirt: The Native Backend"
source_id: 46923009
excerpt: "FlirtはGitのカスタムrefでレビューをリポジトリ内に安全保存し、rebase耐性を確保"
---

# Flirt: The Native Backend - Flirt：ネイティブバックエンド
Gitの力だけでレビューを保存する新発想 — Flirtのネイティブバックエンドを読み解く

## 要約
Flirtは「ローカル優先」で動くコードレビュー工具で、レビュー情報をGitリポジトリそのものに保存するネイティブバックエンドを設計中。git-notesを避け、カスタムrefとGitオブジェクトモデルを活かすアプローチで信頼性と効率を目指している。

## この記事を読むべき理由
- 日本でもGit中心の開発が主流。レビュー情報をGitで直接扱えると、オフラインやミニマルなワークフローでの利便性が上がる。  
- git-rebaseなどでデータが消えるリスクをどう回避するか、実務に直結する設計判断が学べる。

## 詳細解説
- 設計方針：Flirtは「コミット単位でのレビュー」を推奨し、マルチパッチの統合差分へのコメントは原則非対応。コミットメッセージ／ヘッダへのコメントや行レンジ（複数行）へのコメントはサポートする方針だが、行内の文字範囲指定（Gerritの細かい機能）は優先度を下げている。  
- スレッドと解決管理：スレッド化は重要。ただしGitHubのように解決状態が「共有のみ」になる問題を避けるため、共有解決とローカル解決の二層トグルを想定。ローカル優先ツールならではの柔軟性だ。  
- レビュー判定（verdict）：バックエンドごとに取り扱いが違う（GitHubのApprove/Request changes、Gerritのスコア、メーリングリストの慣習）。Flirtはバックエンド／プロジェクトごとのカスタム判定を許容する設計にする必要がある。  
- ストレージ設計：git-notesはコミット書き換え（rebase、amend、GC）でメタ情報が消えるリスクがあり、Flirtはこれを採らない判断。代わりにカスタムref（例: .git/refs/flirt/）を使い、レビュー情報を含むGitオブジェクト（コミット＋ツリー＋spirit.json）を指す方式に。これにより：
  - カスタムrefがある限りオブジェクトはGCから守られる。  
  - カスタムrefがコミットを指すことでそのコミットの先祖もfetchされ、過去の送信（submission）の履歴をローカルで辿れる。  
  - JSON blobだけでなくGitのオブジェクトモデルを活用することで効率的な取得と参照が可能に。  
- 将来展望：コメントスレッドの「実体化（materialize）」や、スレッドの移動（thread relocation）など運用上の細かい改善を検討中。

## 実践ポイント
- プロジェクトでレビューメタをリポジトリに置くなら、git-notesは避け、カスタムref＋オブジェクト指向（コミット→tree→spirit.json）を検討する。  
- rebase/amendを多用するワークフローでは、レビューデータの「参照先が変わる」問題を必ず設計段階で扱うこと。  
- 「共有解決」と「個人用解決」を分離するとレビュー運用が圧倒的に楽になる（特にメンテ／レビュアーが頻繁に交代するOSSや企業プロジェクトで有効）。  
- Flirtの方向性は、オフラインやミニマルなリポジトリ運用をする日本のチーム（メールベースや自前のForgeを使うケース）に親和性が高い。動きが気になる方はリポジトリ設計やrefの取り扱いを今のうちに見直しておくと良い。

元記事: https://blog.buenzli.dev/flirt-native-backend/
