---
layout: post
title: "Eertree - an interactive guide"
date: 2025-12-27T15:42:10.946Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://ufukhaciogullari.com/blog/eertree/"
source_title: "Eertree - an interactive guide"
source_id: 438184342
excerpt: "Eertreeで文字列を左からオンライン処理し、全回文を高速検出・出現頻度まで集計する実装ガイド"
---

# Eertree - an interactive guide
回文ツリー（Eertree）で文字列の“鏡”を高速に見つける — 直感と実装の最短ガイド


## 要約
Eertree（回文ツリー）は、文字列中のすべての回文をオンラインで発見・管理できるデータ構造で、追加文字ごとに定数回の遷移で処理できるため実装次第で実質線形時間で動作します。

## この記事を読むべき理由
回文探索は単純に見えて応用範囲が広く、最長回文、異なる回文の個数、回文出現頻度の集計など多くの問題でボトルネックになります。Eertreeは競技プログラミングだけでなく、NLPやログ解析、バイオインフォマティクスなど日本の実務にも応用可能です。

## 詳細解説
- 回文の分類  
  - 長さ $1$ の単一文字  
  - 同じ文字が並ぶ長さ $2$ の回文（例: "aa"）  
  - 「同じ文字で両端を挟んだ」既存の回文（長さが $n$ の回文を両側に同じ文字を付けて長さ $n+2$ にする）  

- ノードの意味  
  Eertree の各ノードは「ある回文」を表す（実装上は回文そのものを保持する必要はなく、長さと遷移だけで十分）。ノードは以下を持つのが基本：
  - length: 回文の長さ（$-1$ や $0$ を含む特別ノードあり）  
  - suffix link: その回文の最長真部分回文（長い接尾回文）への参照（各ノードちょうど1つ）  
  - edges (transitions): 文字ごとの「両側にその文字を付けて作れる回文」への遷移（0個以上）

- 特殊ノード  
  - imaginary root（奇数根）: length = $-1$。単一文字回文への遷移を持ち、自身へ向かう suffix link を持つ。  
  - empty root（偶数根）: length = $0$。長さ $2$ の回文への遷移を持ち、suffix link は imaginary root を指す。

- 構築アルゴリズム（要点）  
  文字列を左から順に追加していき、現在処理済み接尾で最長の回文（max_suffix）を保持する。新しい文字を追加するときは、max_suffix から suffix link をたどりながら「両端に新しい文字を加えられるか」をチェックする（端から見て左右の文字が一致すれば延長可能）。延長できれば長さが $n+2$ の新ノードを作り遷移を設定。存在すれば作らず既存ノードを max_suffix に更新する。最終的に各ノードに出現回数を累積することで頻度情報も得られる。

- 計算量と利点  
  各文字追加は平均的に少数の suffix 遷移しか行わないため、実装が適切であれば実質 $O(N)$（$N$ は文字列長）で全回文情報を列挙・集計できる。オンライン構築が可能な点が Manacher 法（最長回文を $O(N)$ で求める）と異なる利点で、逐次到着するデータや頻度集計に向く。

- 実装上の注意点  
  - ノードは回文文字列を保存するより長さだけを保持してメモリを節約する。  
  - 文字遷移はハッシュマップか固定配列で管理（アルファベットサイズに応じて選択）。  
  - 追加時の新ノードの suffix link を求める処理を忘れない（新ノードの最長接尾回文は既存ノードの遷移から決定される）。  
  - 出現回数は追加時に1増やし、最後に suffix リンクで逆伝播して合計出現回数を得る。

簡潔な擬似コード（追加処理）：

```python
def add(char, pos):
    cur = max_suffix
    while True:
        if s[pos - 1 - cur.length] == char:
            break
        cur = cur.suffix
    if char not in cur.next:
        new = Node(length=cur.length + 2)
        new.suffix = find_suffix_for(new)
        cur.next[char] = new
    max_suffix = cur.next[char]
    max_suffix.count += 1
```

## 実践ポイント
- まずは小さな実装で動かしてみる（VS Code の統合端末とテスト機能を使うと反復が速い）。  
- 目的別に最適化：  
  - 「最長回文」だけ欲しいなら add の戻り値で更新するだけで十分（余分な traversal を省ける）。  
  - 「異なる回文の全列挙／出現回数」ならノードを全て作成し、最後に suffix 経由で出現回数を集計する。  
- 日本語テキスト（UTF-8）の処理では文字単位の扱いに注意（バイト列ではなくコードポイント単位で処理）。  
- 実務適用例：ログの対称パターン検出、ユーザー名やシークエンスの回文頻度分析、競技プログラミングの練習題材に最適。

