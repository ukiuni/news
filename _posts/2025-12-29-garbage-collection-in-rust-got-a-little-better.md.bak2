---
layout: post
title: "Garbage collection in Rust got a little better"
date: 2025-12-29T16:27:27.670Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://claytonwramsey.com/blog/dumpster2/"
source_title: "Garbage collection in Rust got a little better"
source_id: 959856699
excerpt: "dumpsterでRustの動的trait対応GCと自己参照生成が安全に効率化"
---

# Garbage collection in Rust got a little better
RustにGCを持ち込む試みがさらに実用的に — dumpsterの最近の改良点


## 要約
Rust製のガベージコレクタライブラリ「dumpster」が、動的ディスパッチ対応（dyn互換）と自己参照オブジェクト生成の利便性を大幅に改善した。性能を犠牲にせず「安全に」循環参照を扱える点が最大の特徴。

## この記事を読むべき理由
- Rustで“言語ランタイム級”のオブジェクト管理や、グラフ構造／インタプリタ実装を考えている日本のエンジニアにとって直接役立つ知見が得られる。  
- 従来のRc/Arcでは困る自己参照や複雑なポインタグラフを、比較的安全かつ効率的に扱える手法が紹介されている。

## 詳細解説
dumpsterは Gc<T> 型を提供するライブラリで、ユーザーが循環参照を気にせずオブジェクトを扱えるようにすることを目的としている。重要な技術的柱は「Trace」トレイトとVisitorパターンで、GCがオブジェクト内のGc参照を走査できるようにする仕組みだ。

問題点としては「動的ディスパッチ（dyn）に対応していなかった」ことが挙げられる。従来の設計ではTrace::acceptがジェネリクス<V: Visitor>で定義され、呼び出し側のVisitorの型がコンパイル時に固定される必要があったため、Gc<dyn Any>のような使い方ができなかった。

解決策はトレイト分割による「固定された訪問者集合」をライブラリ側で定義し、クライアントにはその集合に合わせて実装させる形にすること。具体的には Trace を直接実装させるのではなく、TraceWith<V> を V の集合につき実装させ、内部的に TraceWithV（すべての必要な Visitor を列挙した非ジェネリクスなトレイト）を経由する設計にした。これにより Trace が dyn 互換になり、G C が trait object を内包するケースが扱えるようになった。利点は以下：

- コンパイル時の最適化を生かしつつ、実行時に型消去（dyn）を許可
- Gc<dyn Trait> のような柔軟な使い方が可能

もう一つの改良点は new_cyclic 相当のAPI（自己参照オブジェクトを簡単に構築する助け）。標準ライブラリの Rc::new_cyclic に倣いつつ、dumpster特有の制約（Gcは常に「ほぼ有効」な値であるべき）を回避するために「死んだ（dummy）Gcを渡しておき、構築後にそれらを“再生（rehydrate）”する」というトリックを使う。主要な安全根拠は：

- dead Gcが参照外しされたらプログラムを停止（未定義動作を隠さない）
- 関数から値をムーブして返すことで、一時的な借用が残らない（Rustの所有権が味方になる）
- Trace 実装で禁止した型があれば、その悪影響を封じられる

これらにより single-threaded の unsync 実装だけでなく、より広い場面で合理的に利用できる設計が整った。

## 実践ポイント
- いつ使うか：インタプリタ／言語ランタイム、複雑なグラフアルゴリズム、自己参照が自然に出るデータ構造で検討する価値あり。性能/予測可能性が重要な場面ではGCのコストを評価してから採用すること。  
- 入門手順：
  1. dumpster を依存に追加し、まずは unsync::Gc で単純な値を試す。  
  2. #[derive(Trace)]（あるいは手動実装）で型をトレース可能にする。  
  3. new_cyclic 相当のAPIで自己参照オブジェクトを作り、collectで回収される挙動を確認する。
- 注意点：dyn化されたGcは使いやすいが少し冗長な型操作（coerce等）が必要になる場合がある。dead Gc の一時的露出はライブラリ側でガードされる前提だが、未定義動作を起こさないよう Trace の契約を守ること。  
- 今後の期待：Option<Gc>のゼロオーバーヘッド最適化など、更なる微性能改善が計画されているため、高性能化が続く。

短評：Rustの所有権モデルとうまく折り合いをつけつつ、動的なオブジェクト表現と循環検出を両立させた興味深いアプローチ。プロトタイプや言語実装をRustでやるなら、一度試してみる価値が高い。
