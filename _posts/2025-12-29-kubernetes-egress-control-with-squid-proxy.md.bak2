---
layout: post
title: "Kubernetes egress control with squid proxy"
date: 2025-12-29T12:30:51.718Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://interlaye.red/kubernetes_002degress_002dsquid.html"
source_title: "Kubernetes Egress Control with Squid proxy (interlaye.red)"
source_id: 46419659
excerpt: "Squid＋NetworkPolicyでKubernetesの外向き通信を可視化し強制する簡単手法"
---

# Kubernetes egress control with squid proxy
クラスタが「何と話しているか」を丸裸にする方法 — Squid＋NetworkPolicyで実現する最小限のKubernetes Egress制御


## 要約
Squidプロキシをクラスタ内に立て、ワークロードにHTTP_PROXY/HTTPS_PROXYを渡してNetworkPolicyで直接egressを遮断するだけで、外向き通信の可視化と強制をシンプルに実現できる。

## この記事を読むべき理由
社内コンプライアンス、監査、トラブルシュートで「クラスタからどこに接続しているか」を把握したい日本の開発・運用チームにとって、複雑なCNIやサービスメッシュに頼らず短期間で導入できる実用的な手法を提示する。

## 詳細解説
アーキテクチャは極めて単純：
- egress-proxyという専用NamespaceにSquidをデプロイ。
- ワークロード側はHTTP_PROXY/HTTPS_PROXY環境変数でSquidを指す。
- ワークロードNamespaceにNetworkPolicyを置き、DNSとproxyへの通信だけ許可し「直接外部へ出る」トラフィックを遮断する。

利点
- 可視化：Squidのaccess.logに接続元Pod・宛先ホスト:ポート・タイムスタンプ・転送バイト数が残る（HTTPSはCONNECTトンネルとして記録）。
- 強制：NetworkPolicyによりプロキシ経由が必須になる。
- シンプル：追加のCNI/CRD/メッシュ不要で導入が速い。

制約
- HTTPSはデフォルトでホスト:ポートしか見えない（パスは見えない。SSLインターセプトすれば可だがCA配布など運用コストが発生する）。
- HTTP/HTTPSが前提。gRPCや生TCPは別途対処が必要。
- アプリが環境変数を使わない場合は明示的なproxy設定が必要。
- 中央管理（単一のsquid.conf）のため、細かいテナント別ルールは別途設計が必要。

簡単な設定例（抜粋）
yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: squid-config
  namespace: egress-proxy
data:
  squid.conf: |
    http_port 3128
    access_log /var/log/squid/access.log combined
    cache deny all
    acl localnet src 10.0.0.0/8
    http_access allow localnet
    http_access deny all

yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: enforce-egress-proxy
  namespace: horizons
spec:
  podSelector: {}
  policyTypes: ["Egress"]
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: kube-system
      ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
    - to:
        - namespaceSelector:
            matchLabels:
              purpose: egress-control
      ports:
        - protocol: TCP
          port: 3128

yaml
# ワークロードに渡す環境変数例
env:
  - name: HTTP_PROXY
    value: "http://squid.egress-proxy.svc.cluster.local:3128"
  - name: HTTPS_PROXY
    value: "http://squid.egress-proxy.svc.cluster.local:3128"
  - name: NO_PROXY
    value: "localhost,127.0.0.1,.svc,.svc.cluster.local,10.0.0.0/8"

運用メモ
- SquidログはノードのhostPathに出すと外部集約や解析（goaccess等）が楽になる。
- コネクションプールの影響でログがまとめられることがある（頻度を上げたいならアプリ側でkeep-alive設定を見直す）。
- HTTPSのフルURLが必要ならssl-bumpを検討するが、証明書配布とプライバシー/セキュリティのトレードオフが発生する。

## 実践ポイント
- まずは開発環境でSquidを1レプリカで立て、ワークロードNamespaceに上記NetworkPolicyを適用して動作確認する。
- アプリが環境変数を参照しているか必ずテスト。参照しないクライアントは明示的なproxy設定が必要。
- access.logを定期的に集約し可視化（goaccessやログ集約プラットフォーム）して、外向き通信トップネームや頻度を監視する。
- 次の拡張案：Squidのincludeでネームスペース別設定を分離、透明プロキシ（iptables経由）、あるいは最終的にサービスメッシュ/コントローラによるポリシー管理へ移行する設計を検討する。

短時間で「クラスタが何と話しているか」を把握・制御したい場合、Squid＋NetworkPolicyは導入コストが低く効果が高い選択肢になる。
