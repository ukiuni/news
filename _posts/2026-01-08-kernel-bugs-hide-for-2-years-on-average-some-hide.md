---
  layout: post
  title: "Kernel bugs hide for 2 years on average. Some hide for 20 - カーネルのバグは平均2年潜伏、最長20年も"
  date: 2026-01-08T03:18:48.441Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://pebblebed.com/blog/kernel-bugs"
  source_title: "Kernel bugs hide for 2 years on average. Some hide for 20. - Pebblebed"
  source_id: 46536340
  excerpt: "Linuxカーネルの脆弱性は平均2年潜伏、最長20年放置の原因と対策"
  ---

# Kernel bugs hide for 2 years on average. Some hide for 20 - カーネルのバグは平均2年潜伏、最長20年も
魅力的な日本語タイトル: カーネルの「潜伏バグ」裁判 — 発見まで平均2年、あるいは20年放置される理由と今すぐできる対策

## 要約
LinuxカーネルのFixes:タグを解析した調査で、125,183件のバグ修正ペアから平均潜伏期間が$2.1$年（最長$20.7$年）と判明。近年は発見が速くなっているが、古いバグのバックログは残る。研究者はコミット段階で脆弱性を高精度に検出するモデル（VulnBERT）も提示している。

## この記事を読むべき理由
- 日本の企業や組込み・IoTデバイス、Android端末、クラウド基盤もLinuxカーネルに依存しており、長期間発見されないバグは現場の可用性とセキュリティに直結する。  
- 開発者・運用者は「どの種類のバグが見つかりにくいか」「どうすれば早期発見できるか」を実務に取り入れられる。

## 詳細解説
調査手法とデータ
- 2005年のgit移行以降のコミットからFixes:タグを全抽出し、総レコード数は$125,183$。タグの使われ方は全体の約28%にとどまり、データは「トレースできる修正」に限られる（つまり保守が丁寧に追跡されたケース）。
- 平均潜伏期間はフル歴史で$2.1$年、中央値は$0.7$年。2025年だけを見た初期解析は古いバグの偏りで平均が高く出た（$2.8$年）。

時間経過と改善
- 導入年別に見ると、「導入から1年以内に見つかる割合」が2010年は$0\%$、2022年は$69\%$に改善。SyzkallerやKASAN/KMSAN/KCSAN、静的解析、増えたレビューが効いている。ただし右切り（right-censoring）に注意：最近導入されたバグはまだ長期的な測定ができない。

サブシステム別の差
- CANドライバ平均$4.2$年、SCTPネットワーク$4.0$年とニッチ領域で潜伏が長く、GPUやBPFは専用のファズ環境で早期発見されやすい（GPU平均$1.4$年、BPF$1.1$年）。

バグ種別の難易度
- レースコンディションが最難関で平均$5.1$年。次いで整数オーバーフロー$3.9$年、use-after-free$3.2$年。非決定的なタイミングや特定状態でしか発現しないため発見が遅れる。

長期化する原因の典型パターン
- 参照カウントの漏れ、NULLチェックの後出し、サイズ計算の整数オーバーフロー、状態機械の競合など。多くは「稀にしか現れない」「古いコードでレビューが少ない」「再現テストが特殊」という共通点を持つ。

実例（分かりやすいケース）
- netfilterのrefcountリーク：2006年導入、2025年修正で潜伏$19$年。特定の自己テスト（conntrack_resize.shを繰り返す）やメモリ圧力下でしか顕在化せず、コンテナのネットワーク名前空間（netns）解放が永久に止まる事象を引き起こしていた。
- 最長ケースはethtoolのバッファオーバーフローで$20.7$年。

検出支援と機械学習（VulnBERT）
- 研究者はコミット差分を入力に、手工特徴とCodeBERT系の表現を組み合わせたVulnBERTを構築。保持検証セットでの再現率（recall）は$92.2\%$、偽陽性率は$1.2\%$と良好（対照でCodeBERT単体は偽陽性率$48\%$）。長い差分をチャンク化して注意を学習するなどの工夫が奏功している。

注意点（バイアス）
- Fixes:タグに依存する解析は「きちんと追跡された」修正に偏る。タグを使わない修正や検出不能の未修正バグは含まれない。

## 実践ポイント
- サニタイザとファジングを導入する：KASAN/KMSAN/KCSAN、Syzkallerはカーネル脆弱性検出に有効。特にネットワークやステートフルプロトコルには専用シナリオが必要。
- レガシーコードを重点テスト：CAN・SCTP・古いnetfilterなど「目が届きにくい」サブシステムはテストとレビュー対象に優先度を上げる。
- CIでコミットスキャンを導入：差分ベースの脆弱性検出（VulnBERT風のモデルやルールセット）を差分チェックに組み込み、疑わしいコミットを早期にブロック／レビュー依頼する。
- テストスイートを拡張：再現が難しい現象（例：conntrack_resize.shをループ、コンテナのネットワーク解放テスト、特定NUMAトポロジでの負荷等）を自動化して定期実行する。
- Fixes:タグ運用を推進：修正時に導入コミットを明示することで、将来の解析・影響追跡が容易になる。プロジェクト運営者はこの慣習を奨励すべき。
- コードレビューでフラグを意識：コミットメッセージに「UB」「I couldn't trigger but…」のような文言があれば追加の検査・テストを要求する。

短いまとめ：カーネルのバグは今も長く潜むが、サニタイザ／ファズ／差分検知（機械学習の応用）を組み合わせれば発見は確実に速くなっている。日本の現場でも「古いコード」「ニッチなプロトコル」「再現困難なテスト」を重点化して対策を進めることが得策だ。
