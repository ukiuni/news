---
layout: post
title: "Quickly restoring 1M+ files from backup"
date: 2025-12-29T13:28:49.869Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://blog.axiorema.com/engineering/quickly-restoring-1m-files-from-backup/"
source_title: "Quickly restoring 1M+ files from backup"
source_id: 435474144
excerpt: "ボリュームを一度だけフラッシュして100万ファイルを秒単位で復元する実用手法"
---

# Quickly restoring 1M+ files from backup
100万ファイルを秒単位で「耐久的に」復元する——Windowsで実運用に耐える現実解


## 要約
大規模（100万ファイル級）のリポジトリ復元でボトルネックになるのは「1ファイルごとの同期（Flush）」。全ファイルを個別にフラッシュすると数倍〜数時間の遅延が発生するが、ボリューム（またはボリュームのルートディレクトリ）を一度だけフラッシュすることで実用的な耐久性と高速性を両立できるという実践的な手法。

## この記事を読むべき理由
日本の企業でもWindows上で古いSubversionや長期間運用されたファイルベースのストレージを扱うケースが多い。災害復旧（BCP）やオンプレ運用で「復元が遅くて現場が止まる」問題に直面しているなら、本記事の原理と実装ヒントは即戦力になる。

## 詳細解説
- 問題点：復元時に「書き込んだデータが物理ディスクに確実に残る」ことを保証するには FlushFileBuffers 等で同期（フラッシュ）する必要がある。しかしこれは同期処理であり、ファイル数が増えると待ち時間が線形に積み上がる（HDDだとさらに顕著）。実測で壁時計時間が5–10倍になることもある。
- 試したアプローチと短所：
  - FILE_FLAG_WRITE_THROUGH：書き込み直通化だが多数の小ファイルでは物理フラッシュが各Writeごとに発生し効果が限定的。
  - 大量非同期書き込み：OSの合成に頼るが、ディレクトリ構造や依存関係（ディレクトリ作成→ファイル作成）で並列度は限定され、ハンドル管理も複雑化。
  - リポジトリをオンザフライで再パック：バックアップの「元データと同一」でないと成立しないため現実的でない。
  - ボリューム全体のフラッシュ（FlushFileBuffers on volume）：理想的だが通常は管理者権限が必要。
- 実用的トリック：ボリュームのルートディレクトリをディレクトリハンドルとして開き FlushFileBuffers を呼ぶと、ファイルシステムドライバ（FAT/NTFS/ReFS等）によってはボリューム全体の同期と同等の物理フラッシュが発動する。これにより復元処理は「多数の非同期書き込み」＋「1回のボリュームフラッシュ」で済み、スループットが劇的に改善する。
- 注意点と限界：この振る舞いは厳密にはドキュメント化されておらず、SMB上の共有や権限がない場合は使えない。将来のOS変更で保証が変わる可能性があるため、フォールバックと検出処理を必須にする。

参考になるAPI: CreateFile（FILE_FLAG_BACKUP_SEMANTICS でディレクトリを開く）、FlushFileBuffers、（低レイヤでは NtFlushBuffersFileEx 等）。

コード例（簡略）:
```c
// C
WCHAR volumePath[MAX_PATH];
// GetVolumePathName(filePath, volumePath, _countof(volumePath));
HANDLE h = CreateFileW(volumePath,
    FILE_APPEND_DATA,
    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
    NULL, OPEN_EXISTING,
    FILE_FLAG_BACKUP_SEMANTICS, NULL);
if (h == INVALID_HANDLE_VALUE) {
    h = CreateFileW(volumePath, FILE_WRITE_DATA,
        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
        NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
}
if (h != INVALID_HANDLE_VALUE) {
    FlushFileBuffers(h);
    CloseHandle(h);
}
```

## 実践ポイント
- まず環境判定：対象がローカルボリュームか、SMB/ネットワークか、ユーザ権限はどうかを必ず判定する。SMBではこの方法は効かない。
- フォールバック実装：ルートフラッシュが失敗したら、影響範囲ごとにまとめてフラッシュするか、最終手段として per-file flush を行い、ユーザに復元時間を通知する。
- 原子性の担保：部分的なファイルが見えてしまうのを避けるため、テンポラリ名で書いてからアトミックリネームするか、排他フラグを組み合わせる。
- 測定とログ：復元処理は必ず計測（書込速度、Flush時間）し、異常時はオペレーションを中断して管理者に通知する。Process Monitor 等で実挙動を確認すること。
- 保守上の注意：この手法は現場で効果的だが「未公開の振る舞い」に依存する部分があるため、運用ドキュメントに明記し、OSアップデート時に挙動確認を行うこと。

短くまとめると、「大量ファイルの耐久的復元は、1ファイルずつ確実に同期するのではなく、非同期で書き出してからボリューム単位で同期する」という戦術が現実的な折衷案となる。実装では環境判定・フォールバック・計測を忘れずに。
