---
layout: post
title: "Learning Lean: Part 1 - Leanを学ぶ（パート1）"
date: 2026-02-18T20:22:48.743Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://rkirov.github.io/posts/lean1/"
source_title: "Learning Lean: Part 1 | Rado&#39;s Radical Reflections"
source_id: 47022604
excerpt: "Lean入門で初心者が陥る主な落とし穴と最短学習ルートを実践的に解説。"
---

# Learning Lean: Part 1 - Leanを学ぶ（パート1）
証明が「コード」になる世界 — 初心者がLeanで最初につまずく箇所と、今すぐ試すべき学習ルート

## 要約
Leanは数学の「形式化（formalization）」を促進する定理証明器で、証明を機械的に検証することで誤りを減らし、論文を「直感＋物語」と「機械検証（GitHub等の付録）」に分離できる利点がある。本記事は著者の学習ノートを元に、PL（プログラミング言語）的な落とし穴と初歩的な対処法を整理する。

## この記事を読むべき理由
日本でも数理分野の再現性・共同研究・AI活用が注目されており、Leanは数学的知見を機械に正確に渡す手段として重要。ソフトウェア開発者や教育者が知っておくと、研究とツール作りの両面で先行優位を得られる。

## 詳細解説
- なぜLeanか：検証可能な証明は共同研究での「信頼コスト」を下げ、論文を人間向けの直感説明に集中させる。将来はLLMと組んで高レベル戦略は会話AI、形式証明の構築はLeanが担う想像ができる。
- 三層のオブジェクトモデル：Leanでは値（terms）、型（types）、そして型の型である宇宙（universes）があり、$Type_0, Type_1, \dots$ と階層化される。これにより「型の型は何か？」という問題が階層的に解決されるが、初心者には混乱しやすい。
- ホモアイコニシティと型/値の混在：型と値の境界が薄く、型が値の文脈で現れ得るため、どこで何を書けるか追いづらい。一方でツール化には強力。
- 変数名と型の「省略可能性」：依存型のため、引数名を型側につけることができ、同じシンタックスでも位置によって意味が変わる（例：`(x : α)` と `(aa : a)` の混乱）。
- 数値リテラルと型クラス：数値リテラルが型クラスで実装されているため、入門時に「1を書くだけでエラー」が起きることがある（Haskell経験者に似たつまずき）。
- カリー＝ハワードと実務の差：理論上はプログラム＝証明だが、実践では $Prop$ と $Type$ が分離され、証明向けのタクティクスや暗黙引数など証明特有の工夫がある。
- 未解決感（著者の疑問）：定義的等号と証明が必要なケースの直感、$Prop$ と可判定性（Decidable）の使い分け、`#eval` と `#reduce` の評価モデル差、`simp` と CAS の比較などは実験で慣れる必要がある。
- 教材とコミュニティ：著者はまず Natural Number Game と Set Game をクリア。Lean Zulip や Kevin Buzzard の講演が学習リソースとして有用。

## 実践ポイント
- まずはブラウザ版や VSCode + Lean プラグインで Natural Number Game / Set Game を触る（ハンズオンが最短）。
- 最初は「型理論／基礎論」の不足を前提に学ぶ。用語（term/type/universe）に慣れるだけで格段に理解が進む。
- 小さな定理を形式化して GitHub に置き、論文本文は「直感・戦略」に集中するワークフローを試す。
- 新しいエラー（リテラルや型クラス）で躓いたら Zulip 等のコミュニティで質問する。日本語／英語問わず活発。
- ソフトウェアエンジニアはTypeScriptなどの型経験を活かせるが、依存型特有の「型が値を参照する」点に注意する。

（参照）まず試す：Natural Number Game、Set Game、Leanコミュニティ（Zulip）、Kevin Buzzard の講演。
