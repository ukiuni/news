---
layout: post
title: "Sorted string tables (SST) from first principles - 基本原理からわかるソート済みストリングテーブル（SST）"
date: 2026-01-09T14:30:26.117Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.bitsxpages.com/p/sorted-string-tables-sst-from-first"
source_title: "sorted string tables (SST) from first principles"
source_id: 46506143
excerpt: "SSD特性を活かし読み取り爆速化するSSTの設計と実践要点がわかる"
image: "https://substackcdn.com/image/fetch/$s_!ZRFn!,w_1200,h_675,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbb889d77-4989-402c-b401-a9111a33d428_1200x628.png"
---

# Sorted string tables (SST) from first principles - 基本原理からわかるソート済みストリングテーブル（SST）
SSD時代の「データ保存の万能ナイフ」SSTをやさしく解説 — なぜ速く、どう作るのか

## 要約
SST（Sorted String Table）は、SSDの特性に合う不変（immutable）なブロック単位のキー・バリュー保存フォーマットで、ページサイズやブロック消去特性を活かして読み取りを高速化しつつ書き込みの効率を出す仕組みです。

## この記事を読むべき理由
クラウドの多くはNVMe/SSDを使い、読み書きのレイテンシ特性がシステム設計に直結します。日本のSaaS／eコマース運用でも、SSTの理解はスループット改善・コスト最適化・運用設計で即役立ちます。

## 詳細解説
- ページと読み取り増幅（read amplification）  
  SSDはI/Oの最小単位がページ（通常4KB）で、たとえ1バイトしか要求していなくてもページ全体を読む必要があります。読み取り増幅は実際に読み込んだデータ量と必要な量の比で表され、例えば256Bの行を読みに行って4KBを読んだ場合は  
  $A = \dfrac{\text{page\_size}}{\text{needed\_bytes}} = \dfrac{4096}{256} = 16$  
  のように増幅が発生します。

- 空間的・時間的局所性  
  読み取りは「一緒にアクセスされやすいデータ」を同一ページや近接領域に配置することで効果的に高速化できます。キー設計で類似キーを連続させる（時間順やユーザ別プレフィックスなど）ことが重要です。

- SSDの書き換え制約と不変性の利点  
  SSDはページ単位で書けても、消去はブロック（128–256KB等）単位です。頻繁に小さく更新すると内部で書き換え（write amplification）が発生するため、不変なバッチ書き込み（append-only）設計が有利になります。

- ログ vs SST  
  単純なappend-onlyログは書き込み効率が良い一方でランダム読み取りが遅い。SSTは「キーでソートした不変ブロック」を作り、ブロック内部は二分探索可能にしてランダム読み取りを高速化します。SSTはメモリ上でソート→まとまったサイズでディスクへ書くフローが基本です。

- SSTの構成要素（簡潔に）  
  - データブロック：キー順に並べたレコードのシリアライズ塊。ブロック内部は二分探索で特定キーを探せる。  
  - インデックス（メインインデックス）：各データブロックの先頭キーとファイルオフセットの集合。インメモリに置き、どのブロックを読むべきか高速に判断する。  
  - フィルタ：そのSSTにキーが存在する可能性を高速に否定できる仕組み。最小/最大キーやBloomフィルタが一般的。Bloomは「存在しない」を100%保証できるが「存在する」は確率的（偽陽性あり）。

- ブロックサイズとトレードオフ  
  小さなデータブロックは読み取り増幅を減らすが、インデックスが増えメモリ消費が増える。大きなブロックはディスクサイズ効率は良いがランダム読みが重くなる。実測例でもブロックサイズを変えるとメモリ使用量と読み取りスループットがトレードオフすることが示されています。

- 実装メモ（概念的なコード例）  
  データブロック内部はソート＋二分探索でシンプルに実装できる（例：Rust風の擬似コード）。
  ```rust
  // rust
  fn find_record(block: &SstDataBlock, key: &[u8]) -> Option<&Record> {
      block.records.binary_search_by(|r| r.key.as_slice().cmp(key))
           .ok().map(|i| &block.records[i])
  }
  ```

## 実践ポイント
- キー設計で局所性を作る：アクセスパターンに合わせてプレフィックスを設計するとページキャッシュを活かせる。  
- ブロックサイズはワークロードで決める：読み込み中心なら小ブロック（メモリ増）、スループット重視なら大ブロック。A/Bテストで評価する。  
- インデックスとフィルタはメモリに乗せる前提でコスト計算：インデックス増は運用メモリに直結する。  
- 書き込みはバッチ化・不変化する：SSDの内部特性を活かすため、メモリでまとめてソート→大きな塊で書く。  
- Bloomフィルタを適切に使う：偽陽性率を調整して不必要なディスクアクセスを減らすが、フィルタ自体のメモリ消費も見積もる。

以上のポイントは、日本のクラウド環境（AWS/GCP/Azureや国内クラウド）でのストレージチューニングや、eコマースやログ集約サービスの設計改善にそのまま役立ちます。必要なら、SSTを使ったLSMツリーやBツリーとの比較、具体的なパラメータ設計（ブロックサイズ／フィルタサイズ）について実例付きで続編を作れます。希望があれば伝えてください。
