---
layout: post
title: "The Architecture Is The Plan: Fixing Agent Context Drift - アーキテクチャが計画である：エージェントのコンテキストドリフトを直す"
date: 2026-01-27T19:48:33.806Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://medium.com/@TimSylvester/the-architecture-is-the-plan-fixing-agent-context-drift-78095b67d838"
source_title: "The Architecture Is The Plan: Fixing Agent Context Drift"
source_id: 415992664
excerpt: "ファイル単位で不変アドレス化し、AIエージェントの文脈ドリフトを防ぐ設計手法を実践解説"
---

# The Architecture Is The Plan: Fixing Agent Context Drift - アーキテクチャが計画である：エージェントのコンテキストドリフトを直す
クリックを誘う邦題: 「AIエージェントが迷子にならない設計——ファイルで作る“変わらない計画”」

## 要約
AIコーディングエージェントは作業中に「コンテキストウィンドウ」が埋まり、元の意図を見失う。著者は「番号付きチェックリスト」から脱却し、ファイルパスを不変アドレスとした有向グラフ（ノード＝アーティファクト）で作業を定義する手法を提案する。

## この記事を読むべき理由
エージェントや分散チームによる開発が増える日本の現場で、局所的に検証可能な設計ルールは生産性と品質を両立する実務的な解決策になるから。ドリフトを防ぎ、ドキュメントと実装を一致させるアイデアは保守性や規制対応でも有利です。

## 詳細解説
- 問題点：従来の番号付き作業リストは位置依存で壊れやすく、発見（要件追加）に弱い。番号を変えると参照が崩れるためフローが脆くなる。
- 提案：各作業項目を「リポジトリ内の一意なパス（ファイル／フォルダ）」で表現する。つまりノード＝アーティファクトで、アドレスは不変。
- ノードの構成（各ノードは目標状態を表す）
  - objective.md（なぜこのノードがあるか）
  - role.md（アーキテクチャ内での役割）
  - module.md（境界とコンテキスト）
  - deps.md（必要な提供者・依存）
  - interface/*.ts、interface/tests/*（インターフェイス定義と契約テスト）
  - guards/*（境界の実装）
  - unit/*（単体テスト）
  - [function].ts（実装）
  - integration/*（結合テスト）
  - provides/*（モジュールの外部窓口）
  - requirements.md（受け入れ基準）
  - Commit（「タイプ アドレス 要旨」のコミットメッセージ）
- 利点：
  - 参照可能性：ファイルパスで一意に指せるので挿入・変更が安全。
  - 局所検証：ノード単位で「完成／未完成」が判定できれば、エージェントは局所ファイルだけで作業可能→グローバルコンテキスト不要。
  - ドキュメント＝実装：ドキュメントを先に定義し、実装はそれを満たす作業になるためドリフトが減る。
  - 動的な依存ソート：depsから有向非巡回グラフを作り、任意の終点までの順序を導出できる（トップソート）。
  - 並列作業：依存が満たされているノードは複数のエージェント/開発者で並列に処理可能。
- 本質：チェックリストは「やること」ではなく「満たすべき不変条件のグラフ」へ変わる。すべてのノードが整合ならシステム全体も整合する。

## 実践ポイント
- まずは1モジュールをノード化する：objective.md→interface→guard→unit→impl→integration→requires→commitの流れを試す。
- コミット規約を決める：「[type] [path] [short desc]」の形式で変更履歴と作業ログを一致させる。
- deps.mdを徹底する：外部依存と提供（provides）を明示するとトップソートが信頼できる。
- CIで「ノード単位の完了チェック」を自動化する：interfaceテスト・ガード・requirementsチェックを通らないとマージ不可にする。
- 小さく始めて拡張する：既存リポジトリでは一部フォルダでノード化し、導入効果を測る。

この記事は、エージェント活用や分散開発で「局所的に完結する実装ルール」を求める現場に直接役立つ実践的な設計パターンを提示します。
