---
layout: post
title: "Complexity, logic and data - 複雑さ、ロジック、データ"
date: 2026-01-12T17:23:18.477Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://legacyfreecode.medium.com/solving-essential-complexity-8f932de3a467"
source_title: "Complexity, logic and data"
source_id: 428560035
excerpt: "コードを書き換えずに業務ルールをデータ化し、非開発者で安全に運用できる設計法を実例で解説"
---

# Complexity, logic and data - 複雑さ、ロジック、データ
コードを書き換えずに“複雑さ”をやっつける — ビジネスロジックをデータ化して開発を加速する方法

## 要約
ソフトウェアの「本質的な複雑さ（業務ロジック）」はツールだけでは消せないが、それを「データ」に移す（DSL・設定・ルール化）ことで、ソースコードをシンプルなエンジンにし、変更や運用を楽にできるという提案。

## この記事を読むべき理由
日本企業は長期稼働する基幹システムや細かい業務ルールが多く、頻繁な仕様変更やサポート負荷に悩まされています。本記事の考え方は、ソースコードの泥沼化を防ぎ、非開発者にも安全に業務変更を任せられる設計アプローチを示します。

## 詳細解説
- 本質的複雑さ vs 偶発的複雑さ  
  フレッド・ブルックスの区別を踏まえると、テンプレート化やフレームワークで減るのは「偶発的複雑さ（ボイラープレート等）」。一方で業務ルールそのものは「本質的複雑さ」で、ここをどう扱うかが改善の鍵です。

- 分解（decomposition）の重要性  
  ジョン・オースターホウトが説くように、問題を小さな部品に分解し、その部品を適切に組み合わせられるようにすることが設計の中心。良い分解ができれば、部品を再利用してスケールできます。

- ロジックを「コード」から「データ」へ移す発想  
  SQL、Dockerfile、HTMLなどはすでにロジックをデータ化している例です。同様に業務ルールやフロー、条件分岐を外部データ（DSL、ルールDB、ワークフローディスクラプション、マップ、AIの重みなど）に移すことで、ソースは「評価・実行するエンジン」になり、業務変更はデータ編集で済みます。

- エンジン設計の要点  
  1) コンポーネントの境界を明確にし、特別扱い（nullチェック、optionalパラメータ）を避ける。  
  2) 入力データを構造化（ツリー／グラフ／再帰表現）し、表現力と信頼性を高める。  
  3) エンジンは入力に応じてサブルーチンのスタックを組み立て、結果を返すだけにする（ドメイン例外はデータで表現）。  
  4) バリデーション、バージョン管理、デザインツール（ビルダー）を用意して、非開発者でも安全に編集できるようにする。

- トレードオフと注意点  
  エンジン自体は複雑になり得るので、設計・テスト・ガバナンスが重要。データの誤りは運用インパクトが大きくなるため、検証・ロールバック・監査ログを必須にする必要があります。

## 実践ポイント
- まず「本質的複雑さ」を特定する：頻繁に変わるルールや多分岐の条件を洗い出す。  
- 小さなドメインから試す：料金計算や割引ルールなど、境界がはっきりした領域でDSL/ルール化を試す。  
- エンジンAPIを定義する：入力スキーマ、出力契約、エラーモードを明確にする。JSON/YAMLスキーマやOpenAPIで仕様化。  
- 編集ツールを用意する：運用チームが編集できるUI（ルールビルダー）を作るか既成のルールエンジンを採用する。  
- 自動テストとバリデーションを整備する：データ変更時にシナリオテストと型検査を回す。  
- バージョン管理と監査を導入する：データ（ルール/設定）には必ず履歴・差分・ロールバックを用意する。  
- 段階的移行：既存のネストしたcase文を一気に置き換えず、ラッパーやフェーズで移行する。  
- 日本企業向けの追加配慮：法規対応・ローカライズ・承認ワークフローをルール管理に組み込む。

短期的には設計とツールの投資が必要ですが、中長期で見るとデプロイ頻度の削減、運用短縮、サポート負荷の軽減につながります。まずは小さなドメインで「ロジックをデータ化」する実験をして、効果を確かめてください。
