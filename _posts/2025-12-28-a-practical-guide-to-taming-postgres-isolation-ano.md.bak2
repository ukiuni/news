---
layout: post
title: "A Practical Guide to Taming Postgres Isolation Anomalies"
date: 2025-12-28 08:18:28.105000+00:00
categories:
- tech
- world-news
tags:
- tech-news
- japan
source_url: https://dansvetlov.me/postgres-anomalies/
source_title: A Practical Guide to Taming Postgres Isolation Anomalies - dansvetlov.me
source_id: 436343139
excerpt: Postgresの分離レベルとロックで予約・在庫の競合を即防ぐ実践ガイド
---
# A Practical Guide to Taming Postgres Isolation Anomalies
Postgresの“トランザクションの落とし穴”を回避する実践ガイド


## 要約
Postgresの同時実行制御は強力だが、分かりにくい「分離性（Isolation）」の違いで意図しない不整合（lost update / write skew / phantom など）が起こる。適切な分離レベル、ロック、制約や楽観ロックを組み合わせることでこれらを実務で防げる。

## この記事を読むべき理由
国内の予約・決済・在庫管理など高同時接続が要求されるシステムでは、見た目は正しくてもレースでデータ整合性が崩れる事例が頻出する。Postgres特有の振る舞いを理解し、実務で即使える回避策を知ることで障害や顧客クレームを未然に防げる。

## 詳細解説
Postgresの重要な性質は「原子性（Atomicity）」と「分離性（Isolation）」。原子性はトランザクション内の複数操作を全部成功・全部失敗にする性質で、BEGIN … COMMIT（あるいはORMのトランザクション）で担保される。

分離性について押さえるべきポイント：
- Read Committed（デフォルト）  
  - 各ステートメントは直前にコミットされたデータを読む。ステートメント間で読み取り結果が変わる（non-repeatable read）ことがある。lost updateやwrite skewに弱い。
- Repeatable Read（スナップショット分離 = Snapshot Isolation, SI）  
  - トランザクション開始時のスナップショットに基づいて全ての読み取りを行うため、non-repeatable readやphantomは防げるが、SI固有の問題である write skew（互いに別行を書き分けると整合性破綻）を許す。
- Serializable（PostgresのSSI採用）  
  - 実質的に直列化可能な振る舞いを保証し、SIで起きうる危険な相互作用を検出してトランザクションを中止（Serialization Failure）させる。正しさは高いがリトライ処理が必要。

よく起きる「異常（anomalies）」と回避法（抜粋）：
- Lost Update（上書きされて消える更新）  
  - 問題例：2つのトランザクションが同じ行を読み、別々に演算してUPDATEすると片方が上書きされる。  
  - 対処：SELECT … FOR UPDATEで行ロック、あるいはUPDATE文で条件付き更新を行い行数チェック。
  - 例：
```sql
-- 行ロックで安全に取る
BEGIN;
SELECT seat_count FROM bookings WHERE id = '...'
  FOR UPDATE;
UPDATE bookings SET seat_count = seat_count - 1 WHERE id = '...';
COMMIT;
```
- 制約とユニークインデックス／INSERT ... ON CONFLICT  
  - アプリレベルでのチェックだけでは競合に弱い。DBの制約（UNIQUE、CHECK）やON CONFLICTで原子的に扱う。
```sql
INSERT INTO seats (event_id, seat_no) VALUES (1, 42)
  ON CONFLICT (event_id, seat_no) DO NOTHING;
```
- Write Skew（書き分けによる整合性崩壊）  
  - SI下で互いに相手の変更を見ずに別行を更新すると制約違反が生じるケース。  
  - 対処：Serializableにしてリトライ、または明示的なロック（SELECT FOR UPDATE）やアドバイザリロックで排他制御。
- Optimistic Locking（バージョンカラム）  
  - 小さいクリティカルセクションで競合検知→リトライするのに有効。App側でversionカラムをチェックして更新。
```sql
UPDATE bookings
SET seat_count = seat_count - 1, version = version + 1
WHERE id = '...' AND version = 3;
-- 更新件数が0なら競合→再試行
```
- Advisory Lock（軽量なアプリロック）  
  - 複数行にまたがるロジックをアプリ単位で排他化したい時に便利。DB接続に紐づくので短時間で使う。

最終的には「分離レベルの選択」「トランザクションを短くする」「DB制約を活かす」「必要な場所で明示的ロックや楽観ロックを使う」の組合せが実務解。

補足：Postgres 17時点の挙動を前提に説明している。将来のバージョンで仕様が変わる可能性あり。

## 実践ポイント
- 重要な更新はSerializableで実行し、SerializationFailureを受けてリトライ実装を行う（短時間で再試行する戦略を用意する）。  
- 高スループット箇所はまずユニーク制約／DB制約で防御し、必要ならSELECT FOR UPDATEで局所的にロック。  
- INSERT競合はINSERT ... ON CONFLICTで原子的に処理する。  
- 楽観ロック（versionカラム）を採用して、衝突時は自動リトライまたはユーザーに通知するUI設計にする。  
- ローカルで同時実行テスト（pgbenchや並列テスト）を用意して、実際に発生しうる異常を再現・検証する。  
- マネージドPostgres（RDS / Cloud SQL等）を利用する場合、デフォルトの設定や接続プールの挙動がアプリの同期表現に影響するため確認する。  
- 日本市場ではピーク時の集中アクセス（イベント・ECセール）や金融・規制要件が多いため、整合性優先の設計判断（多少のスループット犠牲を許容）を検討する価値が高い。

