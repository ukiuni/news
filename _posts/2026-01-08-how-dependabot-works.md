---
  layout: post
  title: "How dependabot works - Dependabotはどう動くのか"
  date: 2026-01-08T03:19:45.150Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://nesbitt.io/2026/01/02/how-dependabot-actually-works.html"
  source_title: "How Dependabot Actually Works | Andrew Nesbitt"
  source_id: 46470927
  excerpt: "Dependabotの中身と自前で安全な自動更新を作る要点解説"
  image: "https://nesbitt.io/images/boxes.png"
---

# How dependabot works - Dependabotはどう動くのか
Dependabotの「裏側」を知れば、社内で安全かつ効率的な自動更新を自分たちで作れる

## 要約
Dependabotのコア（dependabot-core）は依存関係の解析と更新差分生成を行うステートレスなRubyライブラリで、スケジューリングやPR状態管理、CVE集約などの「コーディネーション」はGitHub側の閉源インフラが担っている。自前で同等の仕組みを作るには、その周辺（スケジューラ、DB、イベント連携）が必要になる。

## この記事を読むべき理由
- 依存関係の自動更新はセキュリティ対策と開発生産性の両面で重要。GitHubに依存しすぎない選択肢を持つことは、企業やOSS運営者にとって価値が高い。  
- 日本の組織でも「自社ホスティング」「プライベートレジストリ」「企業ポリシー」に合わせた実装が求められる局面が増えているため、Dependabotの中身を知ることは実務的に有益。

## 詳細解説
- コアの役割  
  dependabot-coreは「何を更新すべきか」「どのようにファイルを書き換えるか」を担当する純粋なライブラリ。主な処理フローは、リポジトリからマニフェスト/ロックファイルを取得（FileFetcher）、依存関係を抽出（FileParser）、レジストリを照会して新バージョンを判定（UpdateChecker）、PR用の差分を生成（FileUpdater）、という4つのクラス群で構成される。

- ステートレス設計の意味  
  ライブラリ自体は実行ごとに状態を持たず、ジョブ定義（どのコミットを見て、既存PRは何があるか、どのCVEが関連するか等）を外部から渡されることを前提に動作する。既存PRや脆弱性情報はGitHubなどホスト側が用意してジョブに注入する。

- GitHub側でやっていること（閉源）  
  スケジューリング、ジョブ状態追跡、API経由でのgit操作、CVE/Advisoryの注入、PRの作成・更新・クローズ判定、レート制御など。dependabot-coreは結果としての「ファイル差分」を返すだけで、実際のpushやPR作成の呼び出しはホスト側が行う。

- 実装の現実的な複雑さ  
  対応エコシステムは25以上で、npm、pip、bundler、Go modules、NuGetなどで挙動が大きく異なる。多くのネイティブツールや古いバージョンの取り扱い（複数Pythonバイナリのバンドル、Yarnフォーク、npmの互換レイヤー等）があり、単純なパーサだけでは済まない工夫が大量にある。

- オープンな周辺実装例（dependabot-gitlab）  
  GitLab向けに作られたdependabot-gitlabは、スケジューラやDBスキーマ（projects, update_jobs, update_runs, merge_requests, vulnerabilities等）を公開しており、何を管理すべきかの実例を示している。重要なのは「コーディネータ」は比較的作れるが、依存関係の全体像を効率よく保持する部分（依存性インデックス）が鍵であること。

- ポーリング vs イベント駆動  
  現行モデルはリポジトリ内のすべての依存を定期スキャンする「力任せ（brute-force）」方式。代替は、レジストリの公開イベント（新バージョン通知）やリポジトリのマニフェスト変更Webhookと、依存性インデックスを組み合わせたイベント駆動モデル。これにより無駄なレジストリ問い合わせが激減するが、「どのリポジトリがどのパッケージを使っているか」を持つ中央インデックスが必要となる。ecosyste.msのようなデータはその例。

- 他プロジェクトとの比較  
  Renovateもコアはステートレスで、商用版がスケジューラやUI/運用機能を提供する点で似ている。Dependabotの差は、GitHubがその周辺を閉じているため「GitHub上でのシームレスな実装」が可能である点。

## 実践ポイント
- まずはdependabot-coreを試す：更新ロジックはMITで公開されているため、ローカル実行で差分生成を確認できる。ただしスケジューラやPR管理は自分で用意する必要がある。  
- 小規模での自前運用案：  
  - スケジューラ（cron or job queue）、実行履歴テーブル、open-PRトラッキングを用意する。  
  - 既存PRのリストやセキュリティアドバイザリはホスト側で集約してジョブに渡す設計にする。  
- 無駄なレジストリ問い合わせを減らす工夫：依存性インデックスを部分的に作る、またはレジストリの公開Feedを購読してイベント駆動を混ぜる。これでスケールコストを下げられる。  
- 日本向けの注意点：プライベートパッケージや社内レジストリ、オンプレ版GitLab/Giteaなどの利用が多い場合、認証周りとパッケージ取得のためのプロキシ設計（キャッシュ、ミラー）が重要。  
- 参考実装を読む：dependabot-coreリポジトリ、dependabot-gitlab、Renovateの設計を参照すると、どの部分が「コア」でどの部分が「周辺」かが具体的に分かる。  
- 実務的短期施策：まずはGitHub/GitLabの既存機能で自動PRを有効にし、どの依存が多く上がるかを観察。問題点が見えたらステートレスコアを実行して差分生成を自動化し、徐々にスケジューラやイベント連携を追加する。

この話は「Dependabotという魔法の箱」のカラクリを暴くと同時に、OSSとプロプライエタリの境界をどう扱うかという実運用の課題を教えてくれます。社内で安全なサプライチェーンを作るなら、コア技術を理解して周辺を自分で設計する視点が必須です。
