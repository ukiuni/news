---
layout: post
title: Faster practical modular inversion
date: 2025-12-27 13:40:48.242000+00:00
categories:
- tech
- world-news
tags:
- tech-news
- japan
source_url: https://purplesyringa.moe/blog/faster-practical-modular-inversion/
source_title: Faster practical modular inversion | purplesyringa's blog
source_id: 46341904
excerpt: 拡張Stein実装でモジュラー逆数を平均1.3–2倍高速化、CPUやコンパイラ依存の最適化手法を解説
---
# 実用的に速い「拡張Stein（2進）互除法」でモジュラー逆数を爆速化する方法

## 要約
拡張Euclidの2進バージョン（拡張Steinアルゴリズム）を実装・最適化することで、モジュラー逆数計算が教科書実装より平均1.3–2倍速くなる可能性がある。だが、コンパイラやマイクロアーキテクチャ次第で結果は大きく変わるので実装とベンチの精査が必須。

## この記事を読むべき理由
暗号、数論的ライブラリ、組込み・モバイル環境での高速モジュラー演算は性能に直結する。日本のプロダクト（スマホアプリ、IoT機器、セキュリティライブラリ）でも、レイテンシや消費電力を削る上で有用な技術であり、実装上の落とし穴（定数時間性、コンパイラ最適化、CPU差）を知っておくべきだから。

## 詳細解説
- 問題設定  
  モジュラー逆数とは与えられた$a$と法$m$について $a\cdot x \bmod m = 1$ を満たす$x$を求める問題。教科書的には拡張Euclid（拡張互除法）を用いるが、2進（binary）版に当たる拡張Steinを適用するとビットシフト中心の処理になり、整数レジスタ上で高速化しやすい。

- Stein（2進）GCD の要点  
  2の冪因子を取り除く性質を利用する：  
  $$\gcd(2^k a, b)=\gcd(a,b)$$  
  また奇数同士なら $a-b$ が偶数になるため次の反復でシフトで除去できる。これにより反復ごとに少なくとも1ビットは減るため計算量は $O(\log a)$。

- 拡張Stein（拡張2進互除法）への拡張  
  逆元を求めるには単にGCDをとるだけでなく、係数を同時に追跡する必要がある（拡張Euclidと同様）。2進の利点は乗除算よりもシフト・加減算に偏らせられる点で、レジスタでの高速命令を活かしやすい。既存の研究（Porninらの論文）で基礎は示されており、実装上の最適化余地が大きい。

- 実装と最適化のポイント（元記事の工夫）  
  - 反復での余分な分岐を減らしてパイプラインに優しいコード生成を狙う。  
  - 可能な限りビットスキャン（trailing_zeros）や単純シフトで因子$2$を除去する。  
  - 符号付き演算や負値回避のために値を入れ替えるロジックを明確にする。  
  - 長整数を扱う際の定数時間性（暗号用途）と高速化はトレードオフになるため注意。  
  - 実装はRustで公開されており、ライブラリとして組み込みやすい。

- ベンチ結果の注意点  
  著者の測定では8/16/32/64ビット幅でSteinが教科書版より大幅に速いケースが多かった（機種によっては40〜56%改善など）。ただしコンパイラ（GCC vs Clang、バージョン）、最適化フラグ（-O2/-O3）、マイクロアーキテクチャ（Haswell/Alder Lake/M1/M2/M4/Zen系/ARM）で結果が大きく変動する。M1や一部ARMで例外的な振る舞いが観測され、アセンブリを直接確認してチューニングするのが最も確実。

## 実践ポイント
- まずは自分のターゲット環境でベンチする  
  実装をライブラリ（例：元記事のRust実装）から取り、ターゲットCPU上で実測ベンチを回す。結果がコンパイラやCPUで大きく変わるため、CIで複数環境を測ると良い。
- コンパイラ最適化を試す  
  -O2/-O3、LTO、アーキテクチャ固有フラグ（-march/-mtune）を切り替え、アセンブリ比較で命令発行パターンを確認する。
- 暗号用途なら定数時間性を厳格に評価する  
  ビット依存の分岐やメモリアクセスでタイミング差が出ないか。必要なら定数時間版を優先し、性能と安全性を天秤にかける。
- フォールバック実装を用意する  
  あるCPUでSteinが遅い場合に備えて、従来の拡張Euclidを条件付きで切り替えられる設計にする。
- 組込み／モバイル向け最適化  
  小さめのビット幅（8/16/32）やARM系コアでは挙動が特異な場合があるため、インライン化、分岐予測に優しいコードを目指す。バッテリ・消費電力も計測項目に入れる。
- 実装確認の実務チェックリスト  
  - 単体テストで逆元の正当性を確認（ランダム入力／特異ケース）。  
  - アセンブリ差分チェックでホットループを解析。  
  - ベンチ結果をヒストグラムで確認して分布の偏りを把握。

