---
layout: post
title: "Broken proofs and broken provers - 壊れた証明と壊れた定理証明器"
date: 2026-02-04T23:24:24.193Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://lawrencecpaulson.github.io/2026/01/15/Broken_proofs.html"
source_title: "Broken proofs and broken provers"
source_id: 1281211165
excerpt: "定理証明器の致命的な見落とし事例と、現場で役立つ具体的対策を解説"
---

# Broken proofs and broken provers - 壊れた証明と壊れた定理証明器
証明は「完璧」じゃない——機械証明器の見落としと安全性の限界

## 要約
定理証明器は人間のミスや実装の不備によって誤った結果を出すことがあるが、設計や運用を工夫すれば実用上の信頼性を高められる、という話です。

## この記事を読むべき理由
機械的検証が普及する日本の開発・研究現場で、証明器の限界や落とし穴を知ることは、誤検知や見落としを避ける実務力になります。

## 詳細解説
- 証明と期待値：数学的証明は「完璧」と思われがちだが、背景仮定の書き間違いや定義の誤りで体系全体が無効化されることがある。例として論文で全定理に $\forall z.\, z\not=0$ と書いてしまい、実際は $\forall z.\, z\not=0 \to \cdots$ とすべきだったケースを紹介。こうしたミスは人間の読み飛ばしで見落とされる。
- 証明支援系の使い方で防げるミス：Isabelle の locale 機構や、定理に前提を明示するスタイルは、この種の誤りを防ぐのに有効。Sledgehammer の矛盾検出など自動支援も役立つ。
- 実行時の副作用：ある学生が偽の命題を「証明」してしまったのは、証明処理の並列化で片方のスレッドが詰まると他のスレッドが先へ進んでしまうという挙動（最終的にバッチ実行でタイムアウトすれば発覚）。並列処理やインタラクティブ実行の注意点。
- 定義の危険性：証明器では定義によって矛盾が導かれない（$1=0$ を証明できない）仕組みが重要。ただし誤った定義は定理の意味を歪める（例：除算の扱いで $x/0=0$ のように見えるが、定理が除算を含まなければ影響しない）。
- サウンドネス（公理的一貫性）バグの実例：Isabelle/HOL で2025年に正規化手法がカーネルを迂回して偽を導けたバグ、2015年のオーバーロード定義の問題、2005年の定義チェック不足など。LCF 系（HOL族、Isabelle）は設計上の堅牢性が高く、PVS のようにカーネルを持たない系は過去に重大な問題があった。
- 検証技術の最前線：HOL Light の小さなカーネル、さらに CakeML に移植・検証された Candle など、定理証明器自身を機械的に検証する取り組みが進んでいる。依存型理論系では機能拡張がカーネルまで及ぶことがあり、そこにリスクがある点も指摘される。

## 実践ポイント
- 定理の前提は明示する（Isabelle の locale や明示的な前提リストを活用）。
- バッチモードで理論全体を定期的に実行し、並列実行やタイムアウトでの不整合を検出する。
- 定義を作るときは簡潔に。主要定理に出ない複雑な定義は慎重に扱う。
- 証明器のリリースノート・バグトラッカーを定期確認し、重要なサウンドネス修正は速やかに取り込む。
- 高い信頼が必要なら、検証済みカーネル（HOL Light / Candle 等）や LCF スタイルのツールを優先する。

短く言えば、「証明器は魔法ではない」——工具の仕組みと限界を知り、運用ルールを整えることが実用的な信頼性向上に直結します。
