---
layout: post
title: "The Second Great Error Model Convergence"
date: 2025-12-29T14:28:08.930Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://matklad.github.io/2025/12/29/second-error-model-convergence.html"
source_title: "The Second Great Error Model Convergence"
source_id: 1365869258
excerpt: "呼び出し側で失敗を明示するエラー値設計が再評価され、API改修と運用信頼性を強化"
---

# 第2のエラーモデル収束 — なぜ今「エラーを値にする」設計が再び勝ち組になったのか

## 要約
最近の言語群は例外ベースの古い合意から離れ、呼び出し側で失敗可能性を明示する「エラーが値である」モデルへと収束している。これは型安全性、API設計、運用の観点で明確な利点を生んでいる。

## この記事を読むべき理由
日本の現場では、サーバーサイドの可用性、マイクロサービス間のエラー伝播、モバイル・組み込みの信頼性向上が重要課題。言語ごとのエラーモデルの違いを理解すれば、設計・実装・運用での落とし穴を避けられる。

## 詳細解説
近年のトレンドを端的にまとめると次の3点が共通になっている。

1) 呼び出し側で失敗可能性を明示する  
- 旧来の throw/catch では呼び出し側に失敗の痕跡が残らないことが多かった。  
- 現代の言語群（Rust, Go, Swift, Zig 等）は呼び出し側で try/?/err チェックや戻り値の形で「ここは失敗する可能性がある」と明示する。これにより関数契約を変更した際に呼び出しコード全体が追随するため、意図せぬエラー漏れを抑制できる。

2) バグ（検出可能な致命的状況）は別経路で扱う  
- 配列範囲外アクセスやヌル参照などの「プログラミングエラー」は、Java のような例外経路と同じ扱いだったが、Rust/Go/Swift/Zig 等は panic や abort といった別の道筋で処理するのが一般化している。  
- これにより「通常の運用エラー」と「致命的なバグ」を区別し、型システムやドキュメントで違いを表現できる。

3) 失敗結果が第一級値である  
- Rust の Result<T, E> に代表されるように、エラーを型として扱い、関数の戻り値として明示する。Swift の throws や Go の (T, error) も同種の考え方。  
- ただし言語ごとに「エラー値の形」に差があり、列挙型（sum type）で厳密に扱うか、任意型のユニバーサルエラーで柔軟に扱うかは分かれている。

エラー値の表現はスペクトル上にある：
- 完全に列挙可能（内部処理での厳密な網羅）→ sum type（例: Rust enum）。利点はコンパイル時に取りこぼしを検出できること。  
- 完全に型消去されたユニバーサルエラー（例: Go error, Swift の Error）→ 柔軟で API 境界に向くが、どのエラーが実際に来るかは実行時にしか分からない。  
- 中間（実務上よく使われる折衷）→ 内部では enum/型を使い、外部境界ではユニバーサルエラーでラップする、といったパターンが多い。検討すべきトレードオフは「厳密さ」と「実装や運用のコスト」。

歴史的には checked exceptions の問題（例: Java の throws がチェーン全体を壊す）を経て、今回は「チェックは呼び出し側で簡単に分かる」かつ「エラーが値である」手法が再び支持を得ている、というのが世代的な変化。

言語別の特徴（簡潔に）
- Rust: Result<T,E> 主流。内部は enum、外部に出すときは anyhow 等を使う流儀も。  
- Go: (T, error) とシンプルなユニバーサルエラー。可搬性・簡潔さを重視。  
- Swift: throws を特別扱い。ライブラリ設計でエラーの伝播を明示。  
- Zig: コンパイル時の閉世界仮定を活かし、関数横断的に誰が何を投げるかを推論。  
- Kotlin/Dart: 伝統的な例外スタイルを継承しつつ、言語の癖で差分あり。

## 実践ポイント
- API 境界を意識してエラーの抽象度を決める：内部は列挙型で厳密に、外部は汎用的なエラーでラップする。  
- 呼び出し側で失敗可能性が見えるようにする（try/?/Result 等を活用）。副作用や再設計のコストを下げる。  
- 例外の「チェック地獄」を避ける：Java の checked exceptions のようにチェーン全体が脆弱にならない設計を目指す。  
- エラーに文脈を付与してログとトレース可能にする（wrap + context）。運用時の原因特定が早くなる。  
- 上位層では「致命的バグ」と「運用エラー」を分離し、トップレベルで一元的に 500 相当のハンドリングを用意する。  
- チームのコーディング規約に「エラー表現の方針」を明記する（いつ enum、いつ汎用 error を使うか）。CI やリンタで一貫性を担保する。

短期的には「呼び出し側で失敗を明示する」習慣をチームに取り入れるだけで、不具合検出やAPI改修コストが改善するケースが多い。言語の流行を追うだけでなく、設計上のトレードオフを明確にし、境界ごとに適切なエラーモデルを採用しよう。
