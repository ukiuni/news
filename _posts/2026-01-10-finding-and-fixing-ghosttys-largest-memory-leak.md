---
layout: post
title: "Finding and Fixing Ghostty's Largest Memory Leak - Ghosttyの最大のメモリリークを発見して修正する"
date: 2026-01-10T21:11:46.446Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://mitchellh.com/writing/ghostty-memory-leak-fix"
source_title: "Finding and Fixing Ghostty&#x27;s Largest Memory Leak – Mitchell Hashimoto"
source_id: 46568794
excerpt: "絵文字多発が誘発したGhosttyの37GB級メモリ漏洩原因と簡潔な修正手順を解説"
---

# Finding and Fixing Ghostty's Largest Memory Leak - Ghosttyの最大のメモリリークを発見して修正する
37GB消費の正体を暴く：端末の「使い回し」が招いた見えにくいメモリ漏洩の話

## 要約
Ghosttyのスクロールバック最適化にあるメタデータの不整合が原因で、大きなmmap割当が解放されずメモリが蓄積していた。修正はマージ済みで、夜間ビルドと次期1.3で利用可能。

## この記事を読むべき理由
CLIや端末を多用する日本の開発者にとって、絵文字やマルチコードポイント文字列が増えた現代のワークロードは同様の不具合を露呈しやすい。原因と対策を知っておけば、怪しいメモリ増加を早く見つけて対応できます。

## 詳細解説
- 背景（PageListとページ）  
  Ghosttyは端末内容をPageListという双方向リストで管理します。各「ページ」はメモリの連続ブロックで、通常は標準サイズをプールから再利用します（高速化のため）。しかし、絵文字や複雑なスタイルで1行あたりのデータが多いと、標準サイズより大きな非標準ページを直接mmapで割当てします。

- 最適化（スクロールバックの再利用）  
  スクロールバック上限に達したとき、古いページを捨てる代わりに先頭ページを末尾に移してそのまま再利用する最適化を入れていました。これにより頻繁な割当/解放を避け高速化されます。

- バグの本質（メタデータと実際の割当の不整合）  
  再利用の際に「ページのサイズを標準に戻した」ことをメタデータ上でだけ記録していました。だが実際のメモリ割当（mmapで確保した大きな領域）はそのまま。後でそのページを「標準サイズだからプールへ返却」と扱い、munmapを呼ばずに放置してしまいメモリ漏れに繋がりました。

- なぜ最近になって顕在化したか  
  非標準ページはこれまで稀でしたが、Claude CodeのようなCLIが多くのマルチコードポイント出力（絵文字等）と大量のスクロールバックを同時に作り出し、非標準ページが大量に生成される条件を満たしたため、初めて大規模なリークとして報告が相次ぎました。これはアプリ側の「悪さ」ではなく、Ghosttyが露呈した設計の限界です。

- 修正内容  
  非標準ページをスクロールバック再利用に回さず、見つけたら正しくmunmapで破棄してから標準サイズの新しいページをプールから取るようにしました。核心は単純な条件判定です：

```zig
if (first.data.memory.len > std_size) {
    self.destroyNode(first);
    break :prune;
}
```

- デバッグ支援（macOSのVMタグ）  
  macOS向けにメモリ割当にタグ付けを行い、ツールでGhosttyのPageList領域を特定できるようにしました。これで発見・検証が容易になります。

- テストと予防策  
  再現テストを追加し、CIでvalgrindやリーク検出器を回して回帰を防ぐ仕組みを強化しました。

## 実践ポイント
- すぐやるべきこと  
  - Ghosttyを最新のnightlyか1.3以降にアップデートする（修正はマージ済み）。  
  - 自分の環境でメモリ異常を観測したら、まずターミナル再起動でリセットし、再現手順を記録する。  

- 調査ツール（環境別）  
  - macOS: InstrumentsやvmmapでプロセスのVM領域を確認。Ghosttyはタグ付けで見つけやすくなっています。  
  - Linux: valgrindやsmemでRSS/VMを監視。  
  - CI: unitテストでのメモリ検査を有効にする（valgrindや言語のテスト用アロケータ）。

- 自分でできる対策  
  - 大量の絵文字や複雑な出力を生むCLI（LLM系やコード補完ツール）を使う際は、メモリ使用量を注意深くモニタする。  
  - 再現手順を残してプロジェクトに報告する（どのコマンド、どれくらいの出力で発生したか）。開発者にとって再現可能なケースが最も有益です。

- 開発者向け学び  
  - プール最適化は速いが、メタデータと実メモリの不整合が致命的なリークに繋がることがある。  
  - 再現性の低いバグほど、実行条件（特定の文字列・出力パターン）を突き止めることが鍵。  

――以上。端末やCLIをヘビーに使う人は、今回の事例を教訓にアップデートと監視を習慣化してください。
