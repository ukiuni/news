---
layout: post
title: "GNU Mes and the module system"
date: 2025-12-26 14:30:07.531000+00:00
categories:
- tech
- world-news
tags:
- tech-news
- japan
source_url: https://ekaitz.elenq.tech/fasterMes5.html
source_title: Ekaitz's tech blog
source_id: 1374285791
excerpt: GNU Mesが暴いた、モジュールで起動遅延が起きる真相と対策
---
# GNU Mes and the module system
起動が遅いのはモジュールのせい？GNU Mesが暴いたモジュールシステムの真相


## 要約
GNU Mesの実装を辿ると、モジュールシステムがランタイムをほぼ“ハイジャック”しており、ブート時やマクロ展開、AOTコンパイルの各段階でモジュールが頻繁にロードされるため、起動性能や実装の複雑さに直結していることが分かる。

## この記事を読むべき理由
Guile互換のScheme実装や、言語ランタイム／パッケージ管理を扱う日本のエンジニアにとって、モジュール設計がブート時間・コンパイル戦略・マクロの振る舞いに与える影響は実務的で大きい。Mesの事例は、同様の問題に直面したときに取るべき対策を学べる良い教材です。

## 詳細解説
- MesはGuileのモジュール実装を参照しており、mes/module/mes/guile-module.mes（Guileの ice-9/boot-9.scm 相当）にモジュールシステムのコアが収められている。元実装からの移植で内部APIに合わせた変更はあるが、概念はGuileのまま。
- モジュールはグローバルに管理される「レコード」で、主なフィールドは名前、種類（kind）、obarray（そのモジュール内の定義を持つハッシュ様構造）、および依存モジュールの集合（uses）。さらに動的に変更できる振る舞いとして、eval-closure（シンボル探索戦略）、重複解決用の手続き、モジュール変化時に呼ばれるオブザーバなどがある。
- Guileの「interface」はモジュールの公開面だけを切り出したモジュール種別で、実体モジュールとその公開インターフェースを分けることで可視性を制御する。参照演算子として @ と @@ があり、公開部のみ／内部も含めた参照を使い分けられる。
- マクロは特別扱いされず通常の定義として管理されるため、マクロの定義・展開タイミングもモジュールのロード戦略に強く依存する。AOTコンパイラ、実行時評価、マクロ展開それぞれが別々のタイミングでモジュールを要求するため、eval-when を正確に使い分ける必要がある。
- 結果として、モジュールシステムはブートプロセス全体を支配し、些細な依存やマクロの位置で起動順序や性能が大きく変わる。実装コードは高レベルだが間に層が多く、理解と最適化が難しい構造になっている。

## 実践ポイント
- ブートパスのプロファイリングを最優先に：どのモジュールがいつロードされるか（AOT・マクロ展開・実行時）をログして特定する。
- ブート時に不要なマクロや動的定義を避ける：可能ならマクロは事前にコンパイルしておき、評価時依存を減らす。
- インターフェース（interface）を活用して公開範囲を明確に：余計なシンボルの露出を抑えることで検索コストと衝突解決を軽減できる。
- eval-when を使い分ける：コンパイル時／ロード時／実行時のどの段階で何が必要かを明示してモジュールの重複ロードを防ぐ。
- モジュール依存グラフを整理する：深い相互依存や循環参照はロード順問題と性能劣化の元。依存を疎にしてAOTコンパイルで解決できるものは前倒しでコンパイルする。
- 既存のGuile実装（boot-9.scm など）を読む：実運用で使われているパターンから学ぶことで、Mes等の互換層で起きる微妙な差異に対応しやすくなる。

