---
layout: post
title: "We tasked Opus 4.6 using agent teams to build a C Compiler - Opus 4.6にエージェントチームでCコンパイラを作らせた話"
date: 2026-02-05T21:32:16.411Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.anthropic.com/engineering/building-c-compiler"
source_title: "Building a C compiler with a team of parallel Claudes \ Anthropic"
source_id: 46903616
excerpt: "16エージェントでほぼ自律的にRust製10万行のCコンパイラを作りLinuxをビルド"
image: "https://cdn.sanity.io/images/4zrzovbb/website/6cc87859f5453e9481278681aa6409856d61153c-2400x1260.png"
---

# We tasked Opus 4.6 using agent teams to build a C Compiler - Opus 4.6にエージェントチームでCコンパイラを作らせた話
AIチームが「ほぼ自律」で作った100,000行コンパイラ――日本の開発現場に突き付ける可能性と注意点

## 要約
Anthropicの研究で、16のClaude（Opus 4.6）エージェントを並列に動かし、ほぼ自律的にRust製のCコンパイラ（約100,000行）を構築し、Linux 6.9をx86/ARM/RISC-Vでビルド可能にした実験の報告です。運用設計、テスト設計、並列化の工夫と限界が主題です。

## この記事を読むべき理由
AIが「長期・大規模開発タスク」を人手を最小化して進める現実味が出てきたため、日本のプロジェクト管理、組込み系やLinuxベースの製品開発、ソフトウェア品質保証の現場に即した示唆が得られます。

## 詳細解説
- アーキテクチャ概略  
  - 「エージェントチーム」：複数のClaudeインスタンスが同一リポジトリを共有し並列作業。各エージェントは独立コンテナで作業し、ローカルで編集→upstreamへpush。作業の競合はファイルベースの“ロック”で調整。  
  - 永続ループ：エージェントを停止させず次々タスクを取り続けるハーネス（簡易的な無限ループ）で自律性を担保。例（簡略）:

```bash
#!/bin/bash
while true; do
  COMMIT=$(git rev-parse --short=6 HEAD)
  LOGFILE="agent_logs/agent_${COMMIT}.log"
  claude --dangerously-skip-permissions \
    -p "$(cat AGENT_PROMPT.md)" \
    --model claude-opus-X-Y &>> "$LOGFILE"
done
```

- 並列化の工夫  
  - テスト単位で分割できれば各エージェントに自動分担が可能。巨大単一タスク（例：カーネル全体）では全員が同じバグで足踏みする問題が発生。  
  - 対策として「GCCを既知良好オラクルにしてランダムに多くをGCCでコンパイルし、問題切り分けをする」ハーネスを作り、エージェントが異なるファイル群で平行して修正できるようにした。デルタデバッグで依存ペアも探索。

- テスト／ハーネス設計の重要性  
  - テストが曖昧だとエージェントは「間違った最適化」を進めるため、検証器（テスト）は高精度である必要。ログは機械処理しやすく、出力はコンテキスト汚染しないよう最小化。時間感覚の欠如対策で短縮サンプリング(--fast)を導入。CIパイプラインで回帰防止を強化。

- 役割分担と専門化  
  - ドキュメント担当、性能改善担当、重複コード統合担当、設計批評担当など役割を分けることで並列の価値を最大化。

- 成果と限界  
  - 成果：約2,000セッション、2B入力トークン/140M出力トークン、費用約$20,000で100,000行のコンパイラがLinux 6.9をビルド可能に。多くのOSSをビルド、GCC tortureテストで高い合格率。Doomもビルド可。  
  - 限界：16bit x86ブート用コードは未完（GCCに依存）、アセンブラ/リンカは不完全、生成コード効率は低め、Rustコードの人間的品質は限定的。自律運用でのテスト通過は必ずしも「信頼できる動作」を意味しない点に注意。

## 実践ポイント
- 小規模で再現する流れ（入門用）  
  1. 専用コンテナで各エージェントの作業環境を用意し、bare git repoをupstreamに設定。  
  2. タスクロック（current_tasks/*.txt）で簡易同期を実装。  
  3. 高品質な自動テスト群とCIを用意し、ログは機械可読（ERROR: 一行）に。  
  4. 大きな単位は外部“オラクル”（既存コンパイラなど）で分割して並列化し、デルタデバッグで依存関係を切る。  
  5. 役割（ドキュメント、リファクタ、性能、QA）を与え、定期的に人が成果を検査するレビューループを入れる。

- 日本の現場で考えるべき点  
  - 組込み/ファームウェアでの16bitやブート工程はAIのみで完結しにくく、専門家の介入が必須。  
  - セキュリティ、規制、品質保証（特に医療・自動車分野）では「テストが通った=信頼できる」ではないため必ず人による検証を残す。  
  - 人件費や時間と比較するとAPI費用は相対的に安く感じられる場面があるが、長期運用コストとリスク評価を行うこと。

読みどころ：ハーネスとテスト設計によって「自律エージェント」が実際に大規模ソフトウェアを構築できる一方で、「どこまで任せられるか」の線引きと検証設計がいかに重要かが学べます。
