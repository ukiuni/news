---
layout: post
title: "&&&&&&&&&&&&&&str - アンパサンド多めの str"
date: 2026-01-09T15:44:25.716Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://ohadravid.github.io/posts/2026-01-09-fourteen-ref/"
source_title: "&&&&&&&&&&&&&&amp;str"
source_id: 1156147504
excerpt: "Rustの参照深度が13→14で急に遅くなる理由と回避法を笑えて学べる"
image: "https://ohadravid.github.io/"
---

# &&&&&&&&&&&&&&str - アンパサンド多めの str
Rustが「13参照までは最適化、14参照で急に遅くなる」理由とは？ — ちょっと笑えて学びになるコンパイラの雑学

## 要約
標準ライブラリのマクロが「&...&str」（参照を重ねた型）に対して多数の特殊化実装をコピーして用意しているため、ある段階（記事では13参照）までは効率的なコードが生成されるが、リストにない参照深度（ここでは14参照）になると汎用のDisplay経路にフォールバックして性能が落ちる、という話。

## この記事を読むべき理由
- Rustの小さな実装選択がアセンブリや実行性能に直結することを理解できる。  
- 標準ライブラリやコンパイラ周りの「テストで見るべきポイント」「デバッグの方法」が学べる。  
- 日本でも増えるRust採用プロジェクト（組込み、低レイテンシサービス等）での性能落差を回避するヒントになる。

## 詳細解説
元記事は、Rustコンパイラのテストで見つかった「奇妙なコード生成の差」を追っています。要点はこうです。

- 標準ライブラリにはマクロで同じようなimplを大量に並べるパターンがあり、特定の型・参照深度に対して専用実装（specialized impl）を提供しています。  
- そのマクロ（記事中では to_string_str!）は &str に対していくつかの参照深度を列挙して実装を生成しています。例（抜粋）:

```rust
rust
pub fn thirteen_ref(input: &&&&&&&&&&&&&str) -> String {
    // ここでは専用implが使われ、String::from のように単純なコピーになる
    input.to_string()
}

// これを生成しているマクロ（概略）
macro_rules! to_string_str {
    { $($type: ty,)* } => {
        $( impl SpecToString for $type {
            #[inline] fn spec_to_string(&self) -> String {
                let s: &str = self;
                String::from(s)
            }
        })*
    };
}
```

- その結果、例えば13個までのアンパサンドに対しては専用実装があり、アセンブリ上では単純な割り当て＋memcpyになる。一方、マクロに列挙されていない（例：14個）と汎用経路にフォールバックし、`<str as core::fmt::Display>::fmt` 経由の処理になってしまい、余計な処理で遅くなる。  
- テストはLLVMのFileCheckで、生成される呼び出しが専用実装（memcpy）かDisplay経路かを検査しており、差分として検出されます。元記事のジョークは「Rustは13参照あれば十分だと思っているようだ」です。

## 実践ポイント
- まずは現場で再現する方法を押さえる：Godboltやcargo asm、cargo rustc --release -- -C llvm-args...、あるいはLLVMのFileCheckでアセンブリを比較すると違いが見える。  
- マクロ展開を確認するには cargo expand を使う。どの参照深度に対してimplが用意されているかが分かる。  
- コード側の対策案：
  - to_string() を無条件に使うのではなく、明示的に String::from(s) / s.to_owned() を使う（型が確定しているなら確実に効率的）。  
  - 深い参照チェーンを作らない、あるいは一度 deref して &str を取り出してから処理する。  
- ライブラリ/コンパイラ寄りの対応：
  - 問題の再現や回避のためにマクロの対象を増やす、あるいは逆に過剰な特殊化を減らす判断もあり得る（元記事ではテストが変ならマクロ除去を検討せよとコメントがある）。  
- 日本の現場での意義：組込みやレイテンシ敏感なサーバーコードでは、こうした小さな差が実運用で顕著になることがある。CIにアセンブリ差分チェックやベンチを入れておくと安心。

短い話ですが、言語実装や標準ライブラリの「地味な」実装選択が実行性能に直結する好例です。Rustを使うなら、型が曖昧な場面では明示的に処理を書いて期待するコードが生成されるか確認する習慣をつけると無駄なハマりを避けられます。
