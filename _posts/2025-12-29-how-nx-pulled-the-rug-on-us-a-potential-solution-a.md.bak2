---
layout: post
title: "How Nx \"pulled the rug\" on us, a potential solution and lessons learned"
date: 2025-12-29T09:50:42.540Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://salvozappa.com/how-nx-pulled-the-rug-on-us.html"
source_title: "How Nx \"pulled the rug\" on us, a potential solution and lessons learned - Salvatore Zappalà's Weblog"
source_id: 435538555
excerpt: "CIのファイルキャッシュ＋単一GoバイナリでNxのリモートキャッシュを追加サービス無しで実現"
---

# How Nx \"pulled the rug\" on us, a potential solution and lessons learned
Nxが“足元”を掬ったときに使う最速の裏技 — CIのファイルキャッシュで実現するNxリモートキャッシュ


## 要約
Nxがカスタムタスクランナーを廃止した問題に対し、CIのファイルキャッシュを利用するローカルHTTPキャッシュ（Go製の単一バイナリ）で代替する手法を紹介する。手間をかけずにリモートキャッシュ相当の効果を得られる現実的な解だ。

## この記事を読むべき理由
大規模なNode.jsモノレポでNxを使っている日本のチームは、Nxの商用化戦略に伴う仕様変更でCIパイプラインやコスト面の影響を受ける可能性が高い。調達（プロキュアメント）が重い企業環境でも導入しやすい代替策を知っておくと、ビルド時間削減や運用の柔軟性を確保できる。

## 詳細解説
背景
- Nxは便利なリモートキャッシュ／リモート実行を提供するが、商用機能（Nx Cloud）へユーザーを導くビジネスモデルを取っている。
- 以前はカスタムタスクランナーで独自のリモートキャッシュを作れたが、Nx側がカスタムランナーを廃止。代替として無料のPowerpack（ただし商用ライセンスが必要）やOpenAPI仕様が提示された。

OpenAPI仕様の制約と問題点
- 提供されたOpenAPIは「バルク取得」をサポートしない設計。アーティファクト毎にHTTPリクエストが必要になり、商用サービスと性能面で差がつく。
- 本格的なリモートキャッシュサービスを自前で運用するのは手間とコストがかかる（監視、スケーリング、耐障害性など）。

実装アイデア（回避策）
- CI（例：GitLab CI）のファイルキャッシュを使い、キャッシュ物理ファイルをランナーのファイルシステム上に置くローカルHTTPサーバーを動かす。
- 要点は「Nxが期待するOpenAPIエンドポイントをローカルで実装」し、アーティファクトを.gitlab-ciなどで保存/復元するディレクトリ（例：.portable-nx-cache）に書き込むこと。
- これにより、フルサービスを管理せずともリモートキャッシュと同等の挙動をCI上で実現できる。

アーキテクチャ（流れ）
1. CIジョブ開始時に前回の`.portable-nx-cache`がCIキャッシュから復元される。  
2. ローカルのキャッシュバイナリ（単一のGoバイナリ）をバックグラウンドで起動し、NxはローカルHTTPサーバーへキャッシュ問い合わせを行う。  
3. ビルド成果物は`.portable-nx-cache/`に保存される。ジョブ終了後、CIがこのディレクトリをキャッシュとして保存。  
4. 次回ジョブでは保存されたアーティファクトが即座に利用可能になる。

メリットと注意点
- 単一バイナリで依存なし、CIに落とし込めば追加サービス不要。  
- MITライセンス等でオープンに使える実装が存在する（自身でビルドして使う想定）。  
- NxのOpenAPI仕様が将来変更されると互換性が壊れるリスクがあるため、Nxのバージョンや仕様変更に注意が必要。  
- パフォーマンスはOpenAPI仕様の制約内でかなり高いが、極端に大量の小ファイルや多数の同時リクエストがあるケースは考慮が必要。

簡易GitLab CI設定例
```yaml
# yaml
variables:
  PORTABLE_NX_CACHE_PORT: "8080"
  PORTABLE_NX_CACHE_TOKEN: "portable-nx-cache"
  NX_SELF_HOSTED_REMOTE_CACHE_ACCESS_TOKEN: "portable-nx-cache"
  NX_SELF_HOSTED_REMOTE_CACHE_SERVER: "http://localhost:$PORTABLE_NX_CACHE_PORT"

.restore-cache:
  before_script:
    - ./tools/portable-nx-cache &> portable-nx-cache.log 2>&1 &
    - until curl --silent --fail http://localhost:$PORTABLE_NX_CACHE_PORT/ready; do sleep 1; done
  cache:
    key: portable-nx-cache
    paths:
      - .portable-nx-cache

build:
  stage: build
  extends: .restore-cache
  script:
    - nx affected --base=$BASE_SHA --head=$HEAD_SHA --target=build
  artifacts:
    paths:
      - portable-nx-cache.log
```

## 実践ポイント
- まず小さなブランチやマージリクエストで試験導入して、キャッシュヒット率やビルド時間の改善を計測する。  
- CIのキャッシュキー運用（ブランチ/コミット戦略）を決め、不要な肥大化を防ぐ。  
- NxのOpenAPI仕様と使っているNxバージョンを固定（lock）して、将来の破壊的変更に備える。  
- プロキシやネットワーク制限のある環境ではlocalhostアクセスが可能か事前確認する。  
- 長期戦略としては「ベンダーのビジネスモデルを評価」し、将来的に商用サービスへ移行するか、自前運用を継続するかの判断基準（コスト／運用負荷／機能）を整理しておく。  

短期的には、CIのファイルキャッシュ＋ローカルキャッシュサーバーは「調達やコスト制約のある現場で即効性のある解決策」になる。Nx周辺の仕様変化に注意しつつ、まずは検証から始めるのが現実的だ。
