---
  layout: post
  title: "Is tree-sitter good enough? (2022) - tree-sitterは十分か？"
  date: 2026-01-03T05:33:39.132Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://blog.jez.io/tree-sitter-limitations/"
  source_title: "Is tree-sitter good enough? – Jake Zimmerman"
  source_id: 1010068151
  excerpt: "高速で多言語対応のtree-sitterがIDE級補完や未完成コードで誤認する実例と対策を解説"
---

# Is tree-sitter good enough? (2022) - tree-sitterは十分か？
tree-sitter、便利だけど「実務での一歩先」は任せられるか？

## 要約
tree-sitterは高速でエラー耐性のあるパーサ生成ツール／既存パーサ群として多くの用途で強力だが、単一言語に対して高精度な補完や文法エラーの精密な扱いが求められるケースでは限界がある。

## この記事を読むべき理由
GitHubや多くのエディタが採用するtree-sitterは、日本のプロダクトやIDE統合でも存在感が増しています。だが「動作は速いが微妙に誤る」事例は、IDEの補完やリファクタリング、CIの自動判定といった開発ワークフローで致命的な誤動作を招く可能性があります。導入を検討するエンジニアやプロダクト責任者は、そのトレードオフを理解しておくべきです。

## 詳細解説
- tree-sitterの特徴
  - インクリメンタルで速いパース、エラー回復機能を持つ宣言型の文法DSLを提供。
  - 多言語対応が簡単で、構文ハイライト／基本的なコードナビゲーションに強みがある。
  - GitHubのsemanticツールなど実運用での採用実績が多数。

- 強みが効く場面
  - 「多数言語のざっくりサポート」が重要なツール（ハイライター、一般的なコードビューア）。
  - 変更が局所的かつ厳密な構文精度が不要な分析（大規模な言語対応や差分ベースの判定）。
  - CIで「構文木が変わっていないか」を高速にチェックするような運用上の簡易ルール。

- 問題点（元記事の示す具体例に基づく要点）
  - 宣言型DSLゆえに「文脈に応じたカスタム処理」が書きにくい。
  - 開発者がエディタでよく打ち込む「未完成コード」や括弧・ブレースの不一致に対して、期待する局所的なノード（例：未完のメソッド呼び出しのreceiver＋ERRORノード）を返さず、誤った木構造を生成することがある。
  - その結果、オートコンプリートは「カーソルが置かれた位置の意味」を誤解し、全く無関係な候補を返す可能性がある。
  - カスタムの構文エラーメッセージを文脈に沿って出したい場合、ツール内で任意の処理を差し込めないと実現が難しい。
  - いくつかは特定言語（tree-sitter-ruby 等）固有の文法問題かもしれないが、同様の誤認識はJavaScriptや他言語でも再現される。

- 重要な問い
  1. 「未完成／エラー混在のバッファで補完を提供すること」が主要ユースケースか？ → 高精度が必要なら慎重に。
  2. 「文脈依存のエラー報告やカスタム回復」が必要か？ → 宣言型だけでは限界がある。

- 結論（元記事の趣旨）
  - tree-sitterは素晴らしいツールだが万能ではない。用途に応じて、tree-sitterを中心に据えるのか、（あるいは）手書きパーサや言語専用の解析器を用いるか判断すべき。

（補足の簡単なコード例：未完のメソッド呼び出しが期待するASTとずれる例）
```ruby
f = ->(x) { x. }
# 編集途中のこのようなコードは、期待通り「受信オブジェクト + 未完のメソッド位置」を表すノードにならない場合がある
```

## 実践ポイント
- ユースケースで評価する
  - 多言語対応で「おおよその解析」を重視するならtree-sitterは有力。
  - 単一言語で「補完／リファクタ／厳密なエラー位置」が重要なら、手書きパーサや既存の言語サーバーを検討。

- ハイブリッド戦略を採る
  - まずはtree-sitterで広くカバーし、重要な言語だけ専用の解析パス（フルパーサやセマンティクス層）を追加する。
  - tree-sitterの出力に対するポストプロセス（ノード修正や補完向けの箇所抽出）を実装して補う。

- 実装／運用のチェックリスト
  - 実際の編集フロー（未完成コード・カーソル位置）でparse結果を網羅的にテストする。
  - grammarのバグか汎用的な限界か切り分け、改善できる箇所はGrammarにPRを送る。
  - 補完やエラーメッセージはtree-sitterのみで完結させず、追加の文脈解析や型情報を組み合わせる。

- コスト判断
  - grammar調整で問題解決に大幅な工数がかかるなら、最初から専用実装の方が総コストは安くなる可能性が高い。

短く言えば：tree-sitterは「速くて便利」だが、IDE級の精度を一言語で追求するなら慎重に。まずは実編集シナリオでの挙動検証を最優先に行ってください。
