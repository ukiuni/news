---
layout: post
title: "LLVM: The bad parts - LLVM の問題点"
date: 2026-01-11T20:45:20.560Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.npopov.com/2026/01/11/LLVM-The-bad-parts.html"
source_title: "LLVM: The bad parts"
source_id: 1708470320
excerpt: "LLVMの裏側を暴き、レビュー不足・テスト欠如・IR欠陥の実情と対策を示す"
---

# LLVM: The bad parts - LLVM の問題点
LLVMの「裏側」を覗く：なぜ使い続けるべきか、どこを直すべきか

## 要約
LLVMの主要メンテナが指摘する「改善余地」の一覧。レビュー不足、ビルド／CIの現実、テスト不足、IR設計の難点など、プロジェクト規模ゆえの痛みが技術的に整理されています。

## この記事を読むべき理由
LLVMはコンパイラ基盤としてRust、Clang、LLVMベースのバックエンドや組み込みツールチェーンに広く使われており、日本の組込み・半導体・ゲーム・クラウド系開発にも直接影響します。問題点を知れば、導入時のリスク回避や社内での改善提案に役立ちます。

## 詳細解説
以下は原著が挙げる主要な問題点と簡単な解説です。

- レビュー能力の不足  
  - 参加者は多いが「レビューできる人」が足りない。PRは作者にレビュー依頼の責任があり、新参が誰に頼ればいいか分からない。結果的に質の担保が難しい。  
  - 対策例：Rust流の自動アサインやレビュー割当を導入する案が挙がる。

- コード／IRの頻繁な変更（Churn）  
  - C++ APIやLLVM IRは安定性より進化を優先する設計になりやすく、下流（フロントエンドやバックエンド）での維持コストが増加。  
  - 「upstream or GTFO」的文化があり、アップストリームに寄与しないと声が反映されにくい。

- ビルド時間と開発体験  
  - LLVMは巨大（数百万行C++）、デバッグビルドはリンクやメモリ面で重い。低スペックPCでのビルドは非現実的。  
  - 改善策としてプリコンパイルヘッダ、dylibデフォルト、lldやsplit dwarfの活用が挙がる。

- CIの安定性（ビルドボットのフラッキーさ）  
  - 多数のビルド構成と長時間のビルドが混在するため、通知ノイズが多く本当に対処すべき失敗が埋もれがち。プレマージ検証は改善したが根本問題は残る。

- End-to-end（E2E）テストの不足  
  - パス単位のテストは充実しているが、ミドルエンド＋バックエンドを通した実行時テストは少ない。実行可能テストは別リポジトリにあり日常開発で使われにくい。  
  - 型や浮動小数点、ベクトル長の組合せなど、現実的なバリエーションの網羅が足りない。

- バックエンドの乖離（Target divergence）  
  - 特定ターゲット向けに局所最適化やフックが増え、ターゲット間で重複や差異が拡大。E2Eテスト不足がこれを助長する。

- コンパイル時間（特に -O0）  
  - 最適化を行わないモードでも速くない。JITや大量IR生成を行う言語でのペインポイント。

- 性能トラッキングの不足  
  - 公式の継続的な性能追跡インフラが整っておらず、変更の影響評価がやりにくい。LNTはあるがUX/運用で課題あり。

IR（中間表現）設計に関する技術的課題：
- undef と poison の扱い  
  - undef（任意値）は扱いが難しく、変換での多用が最適化を難しくする。poison（未定義振舞いの表現）は最適化向けに有利だがメモリ中のpoison扱いは未整備で追加IR機能が必要になる可能性がある（例：バイト型の導入）。

- 仕様不完全性と非健全性（unsoundness）  
  - 実際の誤最適化が理論的にしか現れないケースもあるが、IR設計そのものの欠陥が原因で修正が難しいことがある。値の由来（provenance）周りは特に複雑。

- 制約情報のエンコーディング  
  - 「この値は非負」などの情報をどのようにIRで表現し最適化過程で保持するか。metadata/assume/attributes/poisonなど手法が分散しており、それぞれ利害がある（消えすぎる／残りすぎる等）。

- 浮動小数点（FP）セマンティクスの取り扱い  
  - sNaN、例外、デノーマル、FTZ（flush-to-zero）、過剰精度（x87）など現実環境の差分を正しく扱うのが難しい。現在の表現（constrained FP intrinsics 等）は完璧ではない。

その他：大規模プロジェクトゆえの「部分的な移行」で変更が長期間掛かる点など。

## 実践ポイント
- LLVM導入時のチェックリスト（短期対策）  
  - ビルド：プリコンパイルヘッダ、lld、dylibビルドを検討し、ローカル開発用に軽量化。  
  - CI：PRごとのプレマージテストを必須化し、フラッキー検出用の追加ログを入れる。  
  - テスト：重要なコードパスは小さなE2Eテストを自前で用意（整数幅／浮動小数点／ベクトル等）。Zigなど型表現の豊富な言語を試すのも手。  
  - コンパイル時間：-O0ワークフローが重い場合は専用の軽量バックエンドやキャッシュ戦略を検討。

- コントリビュート／組織的改善案（中長期）  
  - 社内でLLVMのレビュー能力を育て、PRレビューのローテーションや「誰が何をレビューできるか」の可視化を行う。  
  - ターゲットのバグ修正はなるべくアップストリームに戻し、ターゲット間の分岐を減らす取り組みを支援する。  
  - 性能追跡を社内ワークロードで自動化・公開し、OSS側へのデータ共有を検討する（LNT改善支援など）。

- 学習ポイント（初級者向け）  
  - 「IRとは何か」「undef と poison の概念」「フロントエンド／ミドルエンド／バックエンドの役割」を押さえるとLLVMの議論が読みやすくなる。  
  - 小さな最適化パッチでレビュー経験を積むと、コミュニティでの信頼を得やすい。

短評：この記事は「LLVMをやめろ」という主張ではなく、巨大な基盤をより良くするための現実的な課題一覧です。日本の現場でも直面しやすい問題が多いため、導入・運用の判断材料として有益です。
