---
  layout: post
  title: "Clean Code vs. A Philosophy Of Software Design - クリーンコード vs. ソフトウェア設計の哲学"
  date: 2026-01-05T20:42:02.696Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://github.com/johnousterhout/aposd-vs-clean-code"
  source_title: "GitHub - johnousterhout/aposd-vs-clean-code: A discussion between John Ousterhout and Robert Martin about differences between John&#39;s book &quot;A Philosophy of Software Design&quot; and Bob&#39;s book &quot;Clean Code&quot;."
  source_id: 470270903
  excerpt: "短いメソッドは正解か？設計の情報局所性を巡るオースターハウト対マーティンの激論"
  image: "https://opengraph.githubassets.com/689ff061602654c3fd264386839512b4a07aa0029e25b138e8231efd47ba9f26/johnousterhout/aposd-vs-clean-code"
---

# Clean Code vs. A Philosophy Of Software Design - クリーンコード vs. ソフトウェア設計の哲学
なぜ「短いメソッド」が必ずしも正解ではないのか？――オースターハウトと“アンチョク”ボブがぶつけ合う設計の本質

## 要約
ジョン・オースターハウト（APOSD）とロバート・マーティン（Clean Code）の討論は、メソッド長・抽象化・テスト手法をめぐる設計哲学の根本的な違いを浮き彫りにする。小さく分割することの利点と「分割しすぎ」が招く情報散逸（entanglement）をどうバランスするかが肝だ。

## この記事を読むべき理由
日本のソフトウェア開発現場は保守やコードレビュー、長期運用が重視される。短期的な可読性と長期的な保守性を両立させる設計判断は日々の仕事に直結する。本対話は「なぜその判断をするのか」を理論と実践の両面から示してくれる。

## 詳細解説
- 目的の違い
  - オースターハウト（APOSD）は「複雑さ（complexity）を減らし、変更しやすくすること」を設計の中心に据える。重要なのは、開発者が頭の中で保持しなければならない情報量と、その情報の分散具合。
  - マーティン（Clean Code）は「小さく単一責任の関数」を強く推し、読み手がコードを素早く理解できる状態を重視する。特にTDD運用下での短い関数群を好む傾向がある。

- メソッド長のトレードオフ
  - 小さく分割する利点：局所的に理解できる、テストが書きやすい、名前によって意図を表現しやすい。
  - 分割しすぎる欠点（オースターハウトの指摘）：インタフェースが浅くなり「深い機能」を隠せない。関連する処理が別々のメソッドに散らばり、理解のために実装を行ったり来たり（entanglement／conjoined methods）する必要が出る。
  - 「深い（deep）メソッド」と「浅い（shallow）メソッド」：深いメソッドは少ないインタフェースで多くの意味を内包する（情報の隠蔽による認知コスト低下）。浅いメソッドは分割だけれど実装を理解するためには複数のメソッドを読む必要がある。

- 「One Thing」ルールの議論
  - マーティンは「メソッドは一つのことをすべき」と主張し、実践的に短い関数を推奨。だが、オースターハウトは「‘一つのこと’は曖昧で乱用されやすい」と反論。例えばロック獲得＋クリティカル処理は本質的に一体の振る舞いとして扱うべき場合がある。

- 判断のための指標（両者の折衷点）
  - 情報の局所性：関連するロジックが同じ箇所にまとまっているか。
  - 名前の抽象度：抽出したメソッド名が十分に抽象で深さを隠せているか。
  - 振り返り頻度：理解するために別メソッドへ行ったり来たりする頻度が高ければ過分割の兆候。
  - 変更の原子性：ある変更で複数のメソッドをまたいで同時修正が常ならば結合を疑う。

- TDDと設計
  - マーティンはTDDと短い関数の親和性を評価。オースターハウトはTDDや抽象化の優先順（abstraction-first）について慎重で、テストの出発点が設計に与える影響を問題視する場合がある。

## 実践ポイント
- 数値ルールに依存しない：2〜4行などの固定行数ルールは目安に過ぎない。行数ではなく「情報のまとまり」と「理解のしやすさ」を基準に。
- 「振り返りテスト」：コードレビュー時に自分が理解するために何回別のメソッドを参照したか数えてみる。3回以上往復するなら再統合を検討。
- 名前で深さを測る：抽出メソッドの名前が具体的すぎるなら浅い。抽象度が低い（実装詳細をそのまま名前にしている）なら合成してよい。
- 単体変更で複数ファイル/メソッドを頻繁に直すなら過分割のサイン。リファクタで「情報の局所化」を試みる。
- 小さく分けて保守性を試す実験：新機能を実装する際、まず分割してみてレビューで使い勝手を確かめ、必要ならインライン化して比較する。TDDを使うなら、テストが設計のバイアスを生まないか意識する。
- ツール活用：静的解析・コード検索・呼び出しグラフで「実装の横断性」を可視化し、entanglementの有無をチェックする。

元記事（議論の全体）は GitHub リポジトリ "johnousterhout/aposd-vs-clean-code" にまとまっている。議論から得られる教訓は「ルールを盲信せず、情報の局所化と抽象の深さを両方見ること」。日本の長期運用案件やコードレビュー中心の文化では、このバランスを意識した設計判断が差を生む。
