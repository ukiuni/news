---
layout: post
title: "Elasticsearch Was Never a Database - Elasticsearchは決してデータベースではなかった"
date: 2026-01-16T19:54:00.133Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://www.paradedb.com/blog/elasticsearch-was-never-a-database"
source_title: "Elasticsearch Was Never a Database | ParadeDB"
source_id: 46579954
excerpt: "Elasticsearchを唯一の保存先にすると整合性や運用で破綻する5つの落とし穴とは？"
image: "https://www.paradedb.com/blog/elasticsearch-was-never-a-database/images/opengraph-image.png"
---

# Elasticsearch Was Never a Database - Elasticsearchは決してデータベースではなかった
Elasticsearch神話の終焉：検索エンジンを「真のデータベース」にしてはいけない5つの理由

## 要約
Elasticsearchは強力な全文検索エンジンだが、トランザクション、スキーマ変更、複雑なリレーショナルクエリ、運用耐性といった「システム・オブ・レコード」に求められる要件を満たすよう設計されていないため、単独で主座（ソース・オブ・トゥルース）にするのは危険である、という主張。

## この記事を読むべき理由
多くのスタートアップやプロダクトチームが「検索もできて便利だから」とElasticsearchを唯一の保存先にして失敗している実例は日本の開発現場でも起きうる。技術的な落とし穴と現実的な対策を理解して、運用リスクを避けるために必読。

## 詳細解説
- 役割の違い  
  ElasticsearchはApache Lucene上の高速な検索インデックスで、「検索に最適化された二次ストア」として設計されている。一方、PostgresやMySQLのようなRDBはトランザクション性・一貫性・スキーマ進化・複雑クエリを担う「一次ストア」だ。

- トランザクションと一貫性の欠如  
  RDBのような複数行にまたがる原子的な更新（例：注文作成と在庫減少の同時成功保証）は、Elasticsearchでは基本的に保証できない。ドキュメント単位の書き込みは独立し、途中で失敗すると不整合が残る。検索結果は索引の「リフレッシュ」タイミングに依存するため、直後に反映されないこともある。

- スキーマ変更の困難さ  
  インデックスのマッピングは不変要素が多く、型変更やフィールド名変更は再インデックス（全データの移行）を伴うことが多い。一次データソースがあれば再構築はリプレイ可能だが、Elasticsearch単体だと移行リスクが高い。

- リレーショナルクエリの限界  
  JOINや複雑な集計はRDBが得意だが、Elasticsearchでは正攻法が乏しい（デノーマライズ、アプリ側で結合、子ドキュメント設計などの代替案が必要）。複数のクエリ言語が存在し用途が分散している点も混乱を招く。

- 障害復旧・運用の違い  
  データベースはWALなどでトランザクション単位の耐久性を確保するが、Elasticsearchは主にドキュメント単位の耐久性。クラスタ再配置、シャードの偏り、JVMチューニング、再インデックス作業は運用負荷を増す。

- コストと複雑さの増幅  
  「一本化＝簡略化」のつもりが、整合性補填のための再試行・リコンシリエーション、エラー処理、複雑な運用作業が集中し、結果として工数とコストが膨らむ。

- 代替案（記事で触れられる観点）  
  一次ストアをRDBに置き、Elasticsearchは二次インデックスに留める。あるいは、OLTPと全文検索を両立する設計のデータベース（例：Postgresの全文検索拡張や、記事が取り上げるParadeDBのようなアプローチ）を検討する。

## 実践ポイント
- まず設計で役割を明確にする：Elasticsearchは「検索インデックス」として扱い、マスターのソースはRDBにする。  
- 同期手段は堅牢に：CDC（DebeziumやPostgresの論理レプリケーション等）を使い、冪等な更新・再試行ロジックを実装する。  
- クリティカルな操作はRDBで完結させる：在庫や課金など整合性が必須の領域はElasticsearchに頼らない。  
- スキーマ変更は計画的に：再インデックス手順を用意し、ブルー/グリーンやフォールバックを試す。  
- クエリ設計を見直す：複雑な集計や結合はアプリ側で無理に解決せず、適切なDBを使う。  
- 運用監視を強化：シャードバランス、リフレッシュ遅延、JVMメモリ圧迫などを常時監視する。  
- 選択肢を比較する：Postgresの全文検索拡張、あるいはOLTP＋検索を目指す新しいストア（候補の一つとしてParadeDBのようなソリューション）を評価する。

短く言えば、Elasticsearchは最高の検索ツールだが、「何でもかんでもこれ1本で済ませる」設計は将来的な事故の種になる。運用リスクを避けるために役割分担と堅牢な同期設計を最優先に。
