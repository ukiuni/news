---
  layout: post
  title: "Freestyle linked lists tricks - フリースタイル連結リストの小技"
  date: 2026-01-07T10:29:30.009Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://nullprogram.com/blog/2025/12/31/"
  source_title: "Freestyle linked lists tricks"
  source_id: 1233443916
  excerpt: "連結リストを壊さず後から高速検索や定数時間索引を付与する実践テクニック集"
  ---

# Freestyle linked lists tricks - フリースタイル連結リストの小技
連結リストを捨てないで！「後から」高速検索やインデックスを付けられる小さな工夫

## 要約
連結リストを基本のまま保持しつつ、わずかなフィールド追加や補助構造で検索性能を逐次改善する手法を解説する。構築時の順序制御、ビットトライを使った対数時間検索、そして後付け可能な定数時間インデックス化（MSIテーブル）という3段階が中心。

## この記事を読むべき理由
連結リストは軽量でメモリ割り当てが単純なため組み込み機器やWasm、低レイヤのツールで根強く使われる。初期設計のままでも将来の要件（高速検索やマルチマップ対応）に対応できる設計パターンを知っておけば、日本のIoT／組み込み開発やサーバーツール開発でコストを抑えつつ性能を伸ばせる。

## 詳細解説
1) 基本：逆順スタックと順序維持の二重ポインタ
- 典型的な作り方は新ノードを先頭に差し込むだけ。実装は3行程度で済む（new, next設定, head更新）。
- ソース順を保持したければ「最後のポインタを指すポインタ（Env **tail = &head）」を使う。空リストでも簡潔に機能する。

短いイメージ（C）:
```c
// 逆順挿入（簡略）
env->next = head;
head = env;

// 順序維持（尾ポインタ）
*tail = env;
tail = &env->next;
```

2) ログ時間探索：ノードに child[2] を追加してハッシュビットで辿るビットトライ（intrusive hash trie）
- 各ノードに child[2] を追加し、hash の上位ビットを1ビットずつ使ってツリーを降る。
- 挿入はハッシュを左シフトしながら空き子にノードを作る（要はハッシュのビット列を経路にする）。
- 探索は同じビット列を辿ればよく、最初に見つかる一致がソース順（FIFO）に対応するためマルチマップとして機能する。
- マルチヒットのためのイテレータ（ハッシュの現在位置と次ノードを保持）を用意すると、順序通りに全ヒットを列挙できる。

3) 定数時間探索：後付けのインデックス表（MSI hash table）
- リストを構築した後、別領域に固定長のスロット配列（power-of-two サイズ）を作り、オープンアドレス風にリスト要素を配置する。
- テーブルはリスト自体を破壊しない（非侵襲）。必要なら複数の性質ごとのテーブルを作れる。
- テーブルは定数時間探索を提供するが、リストが成長すると再構築が必要になる（テーブルだけを再構築すれば良い）。
- ここでも「先に挿入された要素を優先する」プローブ方式により、マルチマップの最初の一致を返せる。マルチヒット用のイテレータも同様に作れる。

設計上の注目点
- bump allocator（ポインタのみで増えるアロケータ）を使えばノードは連続配置され、キャッシュ不利の懸念は小さい。
- 各段階は互換性を保ちつつ段階的に導入可能：まずリスト、必要ならトライ、さらに必要ならテーブル。
- どの手法もランタイム支援を必要とせず、組み込みやWasm向けに有利。

## 実践ポイント
- 小規模・成長する可能性があるデータ：まず順序を保持する単純リスト（tailポインタ）で十分。実装が最小限で保守しやすい。
- 多数の検索が発生する：child[2] を加えたビットトライでログ時間探索を提供。マルチマップの列挙も可能でメモリ増はノード当たり2ポインタ分。
- リストはほぼ静的、検索が圧倒的に多い：MSIテーブルを後付けして定数時間探索。テーブル再構築のコストを許容できるか評価すること。
- 組み込み/Wasm環境ではアロケータの特性を活かす（bump allocatorで連続配置するとキャッシュ効率が向上）。
- API設計：マルチマップ用のイテレータを用意しておくと、検索結果の列挙やソース順処理が簡潔に書ける。
- テスト：順序（先勝/後勝）やハッシュ衝突時の挙動、増加時の再構築をユニットテストでカバーする。

元記事のアイデアは「最初に軽く作って、要件が出たら構造を壊さず拡張する」という実用的な設計哲学に立っている。特にメモリ制約や低レイテンシが重視される日本の組み込み・インフラ開発では即戦力になるテクニック群と言える。
