---
  layout: post
  title: "Beating myself at chess - チェスで自分に勝つ"
  date: 2026-01-03T21:05:12.065Z
  categories: [tech, world-news]
  tags: [tech-news, japan]
  source_url: "https://log.schemescape.com/posts/diy/beating-myself-at-chess.html"
  source_title: "Beating myself at chess"
  source_id: 46433967
  excerpt: "6KBのC製チェスAIでレトロ機へ移植、実践的最小開発術とテスト教訓"
  ---

# Beating myself at chess - チェスで自分に勝つ
レトロ環境で作る「6KB」のチェスAI — 自分に勝てるほどシンプルなチェスエンジンの作り方

## 要約
著者はCで依存を極力排した超小型チェスエンジンとAIを作り、WebAssembly化してブラウザでも遊べるようにした。テストを書かずに進めたことでバグに苦しみつつも、最終的には自分に勝てるAIを完成させたという話。

## この記事を読むべき理由
- リソース制約下で「実用的に動く」ソフトを作る手法が学べる。  
- WebAssemblyや古いマシン向けポーティング、XBoardプロトコルとの連携など実務でも応用できる技術知見が詰まっている。  
- 日本でもRaspberry PiやレトロPC愛好家が多く、軽量化やレガシー環境対応の参考になる。

## 詳細解説
- 開発方針: 目的は「できるだけシンプルに、依存を減らす」こと。C言語で書き、コアは動的メモリを使わず固定サイズのバッファのみ。チェスエンジン本体は600行未満、AIは150行未満に収められている。  
- サイズと移植性: WebAssemblyにコンパイルすると全体で6KB未満になるほど小さい。これによりPentiumやRaspberry Pi B、場合によってはDOSやAmigaといったレトロ環境へも移植できる可能性がある。  
- 開発環境: 常時接続ではない軽量環境を好み、古典的なツール群（GNU Screen、Vim、entr、w3m）を使った“コージー”な開発を楽しんだ。  
- 入出力と統合: 初期は端末ASCII表示を試したが視認性の問題からGUIは作らず既存プロトコル/ライブラリを利用。具体的には
  - XBoard（CECP）での連携。XBoardは行ベースのテキストプロトコルで実装が簡単。実験時の小ネタとしてnetcatで試す場合は feature sigint=0 done=1 を送らないとプロセスがSIGINTで終了してしまう点に注意する。  
  - ブラウザ連携はcm-chessboardをフロントに、CをWebAssemblyにしたものを組み合わせ。文字列マッピングを避けるため、盤上の動きを整数にエンコードして渡している（例：ランク3ビット／ファイル3ビット／プロモーション3ビットなどをビットパックしてNumberの精度内に収める）。  
- テストの重要性: 当初テストを後回しにしていたが、アンパッサンやキャスリングなど複雑な移動ルールのリファクタでテスト基盤を途中から構築する羽目になり、結果的に多数のバグを発見した。結論は「テストを書け」。

## 実践ポイント
- 小さく始める: まずCで最小限のデータ構造（固定配列）とルール実装から。動的確保を避けると移植が容易。  
- WebAssembly化を視野に: 文字列マッピングを減らし、整数でmoveをやり取りする設計はパフォーマンスと相互運用性に有利。  
- 既存プロトコル/ライブラリを活用: XBoardでチェスエンジン連携、cm-chessboardでブラウザ表示。日本の開発現場でもnpm不要で手早くデモを作れる利点がある。  
- テストは早めに: 特に特殊ルール（en passant、castling、昇格）はユニットテストで網羅しておく。  
- レトロ/省資源ターゲットを想定する: 小型デバイスや教育用ボード（Raspberry Pi）での実行も視野に入れると学びが深い。

この記事は「小さくて動くもの」を作りたいエンジニアに向けた実践的なケーススタディになる。元記事のブラウザ版デモやソースを参考に、まずは自分用のミニチェスエンジンを一度作ってみることを勧める。
