---
layout: post
title: "Garbage collected handles are lifetime-contravariant - ガベージコレクションされたハンドルはライフタイムで反変（コントラバリアント）である"
date: 2026-01-10T08:20:46.337Z
categories: [tech, world-news]
tags: [tech-news, japan]
source_url: "https://trynova.dev/blog/garbage-collection-is-contrarian"
source_title: "Garbage collection is contrarian · Nova"
source_id: 1145432122
excerpt: "Novaの実装から学ぶ、GCハンドルがライフタイムで反変する理由とその安全性トレードオフ"
---

# Garbage collected handles are lifetime-contravariant - ガベージコレクションされたハンドルはライフタイムで反変（コントラバリアント）である
Rust×GCの“逆説”――Novaエンジンから学ぶ、ハンドルの寿命が逆向きに振る舞う理由

## 要約
Rustで実装したガベージコレクタ（GC）のハンドルは、直感に反してライフタイムに関して「反変（contravariant）」に振る舞う。これがコンパイラのチェックと実装上のトレードオフを生み、安全性と利便性の間で苦闘する原因になっている。

## この記事を読むべき理由
日本でもブラウザ・ランタイム・組み込みJS・Wasmの需要が高まり、RustでGCを扱う実装例（Novaのようなエンジン）は増えている。ライフタイムや可変性（variance）の誤解は深刻なセキュリティ問題に発展するため、初級者でも理解しておきたい基本的なアーキテクチャ的知見が得られる。

## 詳細解説
- 背景：GCシステムはヒープ上に「ハンドル」を置き、そのハンドルが指すデータ（T）を生存させる。ヒープ内にあるハンドルはヒープの外的所有者（例: プログラム終了まで）により長く生きることが多く、便宜上 `'static` 相当で考えたくなる。一方、スタック上の非ルート（unrooted）ハンドルは次のGCまでしか保証できない短いライフタイムを持つ。

- 問題点：ローカルな短いライフタイムのハンドルをヒープ（長いライフタイム）にコピーして「ルート化」したい場面がある。しかし、Rustの標準的な振る舞いではライフタイムパラメータは共変（covariant）で扱われるため、短いライフタイムの参照を長いライフタイムの場所に入れることはコンパイルエラーになる。これは一見不便だが、無効な参照をヒープに残すことで発生するuse-after-freeを防ぐため正しい挙動でもある。

- contravariant（反変）への気づき：Novaでは実際には安全性を外部検査（読み時にチェック）で担保する戦略を取り、暗黙に「短いライフタイムの値を長いライフタイムのスロットに移す」操作をunsafeで行っている。これは型理論で言うところの反変性に相当し、一般に
  $T \le U$ のとき
  $$C\langle U\rangle \le C\langle T\rangle$$
  のように順序が逆転する性質で表される。関数型での例は分かりやすく、引数を取る関数型はその引数のライフタイムに対して反変になり得る（例: fn(&'a T)）。

- 直感的説明：反変な型は「書き込み専用のシンク（sink）」と考えると分かりやすい。書き込みは許して読み出しを保証しない。GCハンドルも同様で、ヒープに保存＝ルート化で寿命を伸ばす操作は書き込み的な性質を帯びるため、反変的な扱いの方が論理的に自然になる場面がある。

- 安全性対策と設計上の課題：反変ハンドルを関数境界で受け渡すと、呼び出し側／呼び出され側のどちらかが間違うと重大な不整合を招く。理想的には「callee内で終わる」ような一時的なライフタイムを渡せる機能が欲しいが、現行Rustのライフタイムモデルではそれが難しい。Novaは以下のような現実的対策を取っている：
  - ハンドルを読む前に都度検査して不整合を吸収（境界チェックでpanicや値の変化に変換）
  - 必要なら世代番号（generational handles）等でより強い整合性を付加（Novaでは未使用ビットがある）
  - unsafeに明確な安全性コメントを付け、最小限に留める

- コード例（問題になる割当て、簡略化）:

```rust
let local_handle: Handle<'local, T> = local;
let heap_mut: &mut Handle<'static, T> = heap.get_mut();
// SAFETY: 実装上の理由でライフタイム短縮を行う（詳細な注釈必須）
let heap_mut: &mut Handle<'local, T> = unsafe { core::mem::transmute(heap_mut) };
*heap_mut = local_handle;
```

この unsafe は見た目にはライフタイムを縮めているが、実際には「ローカルをヒープへ移す」操作の意味合いを持つため、反変的扱いが自然に見える。

## 実践ポイント
- ライフタイムとvarianceの概念を理解する：$T \le U$ と $C\langle U\rangle \le C\langle T\rangle$ の関係が何を意味するか押さえる。
- unsafe を使うときは明確な「安全性コメント」を必須に：誰がどの条件で不整合を防ぐかをコード内で記述する。
- 読み取り時のチェックを怠らない：ハンドルの読み出し前に検査することで、Rust未定義動作を避けつつ言語レベルの安全性を補える。
- 必要なら世代番号付きハンドル（generational handles）を導入：ビットを使って世代を追跡すると、古いハンドル参照を検出できる。
- API設計で「書き込み専用（sink）」や証明（proof）値を明示する：反変的な性質を持つ値は、読み取り可能になるまでの証明をどう渡すかを設計に組み込む。
- Rust本体やコミュニティの議論をフォローする：ライフタイム仕様や新機能（callee内で終わるライフタイム等）の議論は、今後の安全設計に直結する。

この記事は、RustでGCや言語ランタイムを作る際に遭遇する「直感に反する」挙動の本質を示すものです。日本のランタイム開発者や組み込み・Wasm分野のエンジニアにとって、設計上の落とし穴と実務的回避策を整理する良い出発点になります。
